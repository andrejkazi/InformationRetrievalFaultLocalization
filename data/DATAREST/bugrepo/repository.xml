<?xml version = "1.0" encoding = "UTF-8" ?>
<bugrepository name="DATAREST">
	<bug id="23" opendate="2012-07-23 23:50:43" fixdate="2012-07-31 11:48:16" resolution="Complete">
		<buginformation>
			<summary>Searches which returns null gives NPE</summary>
			<description>A search which returns null gives NullPointerException in RepositoryRestController. 
Example stack trace:
java.lang.NullPointerException
	at org.springframework.data.rest.webmvc.RepositoryRestController.query(RepositoryRestController.java:442)
	at org.springframework.data.rest.webmvc.RepositoryRestController$$FastClassByCGLIB$$5ba1a185.invoke(&amp;lt;generated&amp;gt;)
	at net.sf.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204)
	at org.springframework.aop.framework.Cglib2AopProxy$CglibMethodInvocation.invokeJoinpoint(Cglib2AopProxy.java:689)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:150)
	at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:80)
	at 
xxx(xxx.java:31)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:621)
	at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:610)
	at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:65)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:161)
	at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:80)
	at 
xxx(xxx.java:26)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:621)
	at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:610)
	at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:65)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:161)
	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:90)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)
	at org.springframework.aop.framework.Cglib2AopProxy$DynamicAdvisedInterceptor.intercept(Cglib2AopProxy.java:622)
	at org.springframework.data.rest.webmvc.RepositoryRestController$$EnhancerByCGLIB$$eb30ada5.query(&amp;lt;generated&amp;gt;)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at org.springframework.web.method.support.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:213)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:126)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:96)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:617)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:578)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:80)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:923)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:852)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:882)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:778)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:735)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:848)
A simple fix would be to add a if(null != result) before doing l.add(result) around line 429 in RepositoryRestController</description>
			<version>1.0.0.RC1</version>
			<fixedVersion>1.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryRestController.java</file>
		</fixedFiles>
	</bug>
	<bug id="21" opendate="2012-07-11 05:49:56" fixdate="2012-07-31 11:49:25" resolution="Complete">
		<buginformation>
			<summary>paging with parameters</summary>
			<description>missing parameter findBy in href .prev and .next
Page&amp;lt;LoanInfo&amp;gt; findByNsn(@Param("nsn") String nsn, Pageable pageable);
http://localhost:9090/hateos/loaninfo/search/findByNsn?nsn=2355-DE-004-0342&amp;amp;page=2&amp;amp;limit=5
 
{
        "rel": "loaninfo.prev",
        "href": "http://localhost:9090/hateos/loaninfo/search/findByNsn?page=1&amp;amp;limit=5"
    }
,
    {
        "rel": "loaninfo.next",
        "href": "http://localhost:9090/hateos/loaninfo/search/findByNsn?page=3&amp;amp;limit=5"
    }

]</description>
			<version>1.0.0.RC1</version>
			<fixedVersion>1.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryRestConfiguration.java</file>
			<file type="D">org.springframework.data.rest.webmvc.UriListView.java</file>
			<file type="M">org.springframework.data.rest.webmvc.ServerHttpRequestMethodArgumentResolver.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryRestMvcConfiguration.java</file>
			<file type="D">org.springframework.data.rest.webmvc.JsonView.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryRestHandlerAdapter.java</file>
			<file type="M">org.springframework.data.rest.core.util.FluentBeanSerializer.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryRestController.java</file>
			<file type="D">org.springframework.data.rest.webmvc.RepositoryRestViewResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="41" opendate="2012-08-28 22:16:00" fixdate="2012-09-05 06:07:58" resolution="Complete">
		<buginformation>
			<summary>No update on objects</summary>
			<description>When I try to update an object, the only think happening is a select of the persisted object in the database. The put object itself does not get updated.
The SELECT statement occurs, during the execution of readIncoming(request, incomingMediaType, domainType).</description>
			<version>1.0.0.RC2</version>
			<fixedVersion>1.0.0.RC3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.json.RepositoryAwareJacksonModule.java</file>
		</fixedFiles>
	</bug>
	<bug id="45" opendate="2012-08-31 07:11:04" fixdate="2012-09-05 06:09:20" resolution="Complete">
		<buginformation>
			<summary>No IDs in href of objects displayed</summary>
			<description>Browsing to: http://localhost:8080/rest/sla results in the gist.</description>
			<version>1.0.0.RC2</version>
			<fixedVersion>1.0.0.RC3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.EntityToResourceConverter.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryRestController.java</file>
		</fixedFiles>
	</bug>
	<bug id="38" opendate="2012-08-15 08:36:53" fixdate="2012-09-05 06:29:43" resolution="Complete">
		<buginformation>
			<summary>Listing relations with Accept:application/x-spring-data-compact-json does not contain self link.</summary>
			<description>When loading a relation like this: 
http://localhost:8080/rest/entity/6bf64863-2c1f-4661-b54b-7611971b36aa/relation/a6ae6a94-31f9-47a5-9904-329477ab54d0
with: 
"application/x-spring-data-compact+json" as Accept-Type, the result does not contain a self link. The same for "application/json" as Accept-Type.
This worked before and also works for:
http://localhost:8080/rest/entity/ etc.</description>
			<version>1.0.0.RC2</version>
			<fixedVersion>1.0.0.RC3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryRestController.java</file>
		</fixedFiles>
	</bug>
	<bug id="48" opendate="2012-09-13 05:17:17" fixdate="2012-09-13 12:00:12" resolution="Complete">
		<buginformation>
			<summary>Executing /search/findEntityById?id=823892389 with x-spring-data-compact+json does not return any value.</summary>
			<description>When I try to execute a search with the following URL: 
http://localhorst:8080/rest/entity/search/findEntityById?id=823892389 setting Accept : application/x-spring-data-compact+json the result is:
{
  "links" : [ ],
  "content" : [ ]
}
Doing the exactly same request with 
Accept : application/json returns
{
  "links" : [ ],
  "content" : [ {
    "links" : [  
{
      "rel" : "self",
      "href" : "http://localhost:8080/rest/entity/453234243"
    }
,  ],
    "enabled" : false,
    ....
  } ]
}
In the previous build it worked. </description>
			<version>1.0.0.RC2</version>
			<fixedVersion>1.0.0.RC3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryRestController.java</file>
		</fixedFiles>
	</bug>
	<bug id="47" opendate="2012-09-07 03:54:18" fixdate="2012-09-13 12:00:46" resolution="Complete">
		<buginformation>
			<summary>POST fails, when links : null</summary>
			<description>Since the last update fixing the update problem with links, there is a new error. Doing a POST with empty links results in a:
org.springframework.http.converter.HttpMessageNotReadableException: Property &amp;amp;apos;links&amp;amp;apos; is not of array type. Either eliminate this property from the document or make it an array.
Adding the links like this: 
entity.setLinks(new ArrayList&amp;lt;LinkType&amp;gt;());
and it works, without any issues. 
From my point of view it should also work with Links : null.</description>
			<version>1.0.0.RC2</version>
			<fixedVersion>1.0.0.RC3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.json.RepositoryAwareJacksonModule.java</file>
		</fixedFiles>
	</bug>
	<bug id="44" opendate="2012-08-31 00:31:31" fixdate="2012-09-13 12:01:50" resolution="Complete">
		<buginformation>
			<summary>Issue on Entity without @Version attribute when using Eclipselink as provider</summary>
			<description>If using EclipseLink as persistence provider, the exporter fails with this error:
"java.lang.IllegalArgumentException: No @Version attribute exists on the identifiable type"
I have isolated the error at line 35 of JpaEntityMetadata class, seems that the metod entityType.getVersion(Long.class) fails in eclipselink if no @Version is defined.
In attachment the log file</description>
			<version>1.0.0.RC2</version>
			<fixedVersion>1.0.0.RC3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.repository.jpa.JpaEntityMetadata.java</file>
		</fixedFiles>
	</bug>
	<bug id="83" opendate="2013-05-04 10:26:47" fixdate="2013-06-05 11:55:02" resolution="Fixed">
		<buginformation>
			<summary>Controller implementations should not be annotated with @Controller</summary>
			<description>The controller implementations are currently annotated with @Controller which causes issues when you use Spring Data REST in the same application context in which you have Spring MVC activated through @EnableWebMvc. The latter registers a RequestHandlerMapping that scans the ApplicationContext for all beans annotated with @Controller and will find the SD REST controllers. As the RequestHandlerMapping has higher precedence than the RepositoryRestHandlerMapping it will take over the execution of the controllers which causes trouble in case the additional functionality applied in RRHM is (e.g. baseUri configuration etc.) needed.
Actually the classes don&amp;amp;apos;t need to be annotated with @Controller as they are registered explicitly and the RRHM explicitly considers these classes anyway.</description>
			<version>1.1.0.M1</version>
			<fixedVersion>2.0 M1 (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryController.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryEntityController.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryPropertyReferenceController.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositorySearchController.java</file>
			<file type="M">org.springframework.data.rest.webmvc.AbstractRepositoryRestController.java</file>
		</fixedFiles>
	</bug>
	<bug id="163" opendate="2013-09-23 23:12:45" fixdate="2013-11-14 02:02:38" resolution="Fixed">
		<buginformation>
			<summary>One-to-one relations in embedded Mongo Documents do not get rendered...</summary>
			<description>In documents with subdocuments being a one-to-one relation ship, SD REST is neither able to render them correctly, nor to accept them in a POST/PUT. </description>
			<version>2.0 M1 (Codd)</version>
			<fixedVersion>2.0 M1 (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.core.domain.mongodb.MongoDbRepositoryConfig.java</file>
			<file type="M">org.springframework.data.rest.webmvc.mongodb.MongoDbRepositoryConfig.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module.java</file>
			<file type="M">org.springframework.data.rest.webmvc.mongodb.MongoWebTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="199" opendate="2013-12-04 11:52:55" fixdate="2013-12-04 22:53:11" resolution="Fixed">
		<buginformation>
			<summary>Collection/Object conversion broken in PersistentEntityJackson2Module</summary>
			<description>I am trying to post to localhost:8080/credentials/
{
   "customer":
{
      "rel":"self",
      "href":"http://localhost:8080/web/customers/60"
   }
,
   "credentialProperties":[

{
         "name":"Access Key",
         "value":"123456"
      }
,
      {
         "name":"Secrect Access Key",
         "value":"12344567"
      }
   ],
   "name":"12344567",
   "service":
{
      "rel":"self",
      "href":"http://localhost:8080/web/services/50"
   }
,
   "vendorType":"1234567"
}
The according object looks like that:
@Entity
public class Credential extends AbstractEntity {
	private String name;
	private boolean disabled;
	private String disablingReason;
	private String vendorType;
	@ManyToOne
	@JoinColumn(name = "customer_id")
	private Customer customer;
	@JoinColumn(name = "service_id")
	private Service service;
	@OneToMany(mappedBy = "credential", fetch = FetchType.EAGER, cascade = CascadeType.ALL)
	private Set&amp;lt;CredentialProperty&amp;gt; credentialProperties;
	@OneToOne(cascade = CascadeType.ALL)
    @PrimaryKeyJoinColumn
	private CredentialSettings credentialSettings;
And the Exception is as follows:
java.lang.IllegalArgumentException: argument type mismatch
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.7.0_45]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) ~[na:1.7.0_45]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.7.0_45]
	at java.lang.reflect.Method.invoke(Method.java:606) ~[na:1.7.0_45]
	at org.springframework.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:191) ~[spring-core-3.2.5.RELEASE.jar:3.2.5.RELEASE]
	at org.springframework.data.mapping.model.BeanWrapper.setProperty(BeanWrapper.java:97) ~[spring-data-commons-1.7.0.M1.jar:na]
	at org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module$ResourceDeserializer.deserialize(PersistentEntityJackson2Module.java:241) ~[PersistentEntityJackson2Module$ResourceDeserializer.class:na]
	at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:2888) ~[jackson-databind-2.2.2.jar:2.2.2]
	at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2094) ~[jackson-databind-2.2.2.jar:2.2.2]
	at org.springframework.http.converter.json.MappingJackson2HttpMessageConverter.readJavaType(MappingJackson2HttpMessageConverter.java:178) ~[spring-web-3.2.5.RELEASE.jar:3.2.5.RELEASE]
	at org.springframework.http.converter.json.MappingJackson2HttpMessageConverter.readInternal(MappingJackson2HttpMessageConverter.java:166) ~[spring-web-3.2.5.RELEASE.jar:3.2.5.RELEASE]
	at org.springframework.http.converter.AbstractHttpMessageConverter.read(AbstractHttpMessageConverter.java:153) ~[spring-web-3.2.5.RELEASE.jar:3.2.5.RELEASE]
	at org.springframework.data.rest.webmvc.PersistentEntityResourceHandlerMethodArgumentResolver.resolveArgument(PersistentEntityResourceHandlerMethodArgumentResolver.java:48) ~[spring-data-rest-webmvc-2.0.0.BUILD-SNAPSHOT.jar:na]
	at org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:77) ~[spring-web-3.2.5.RELEASE.jar:3.2.5.RELEASE]
	at org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:162) ~[spring-web-3.2.5.RELEASE.jar:3.2.5.RELEASE]
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:123) ~[spring-web-3.2.5.RELEASE.jar:3.2.5.RELEASE]
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:104) ~[spring-webmvc-3.2.5.RELEASE.jar:3.2.5.RELEASE]
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandleMethod(RequestMappingHandlerAdapter.java:745) ~[spring-webmvc-3.2.5.RELEASE.jar:3.2.5.RELEASE]
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:686) ~[spring-webmvc-3.2.5.RELEASE.jar:3.2.5.RELEASE]
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:80) ~[spring-webmvc-3.2.5.RELEASE.jar:3.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:925) ~[spring-webmvc-3.2.5.RELEASE.jar:3.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:856) ~[spring-webmvc-3.2.5.RELEASE.jar:3.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:936) [spring-webmvc-3.2.5.RELEASE.jar:3.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:838) [spring-webmvc-3.2.5.RELEASE.jar:3.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:647) [servlet-api.jar:na]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:812) [spring-webmvc-3.2.5.RELEASE.jar:3.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:728) [servlet-api.jar:na]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:305) [catalina.jar:7.0.39.B]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210) [catalina.jar:7.0.39.B]
	at com.thetransactioncompany.cors.CORSFilter.doFilter(Unknown Source) [cors-filter-1.5.jar:na]
	at com.thetransactioncompany.cors.CORSFilter.doFilter(Unknown Source) [cors-filter-1.5.jar:na]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:243) [catalina.jar:7.0.39.B]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210) [catalina.jar:7.0.39.B]
	at org.springframework.orm.jpa.support.OpenEntityManagerInViewFilter.doFilterInternal(OpenEntityManagerInViewFilter.java:180) [spring-orm-3.2.5.RELEASE.jar:3.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-3.2.5.RELEASE.jar:3.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:243) [catalina.jar:7.0.39.B]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210) [catalina.jar:7.0.39.B]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) [spring-security-web-3.1.4.RELEASE.jar:3.1.4.RELEASE]
	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:118) [spring-security-web-3.1.4.RELEASE.jar:3.1.4.RELEASE]
	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:84) [spring-security-web-3.1.4.RELEASE.jar:3.1.4.RELEASE]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) [spring-security-web-3.1.4.RELEASE.jar:3.1.4.RELEASE]
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:113) [spring-security-web-3.1.4.RELEASE.jar:3.1.4.RELEASE]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) [spring-security-web-3.1.4.RELEASE.jar:3.1.4.RELEASE]
	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:113) [spring-security-web-3.1.4.RELEASE.jar:3.1.4.RELEASE]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) [spring-security-web-3.1.4.RELEASE.jar:3.1.4.RELEASE]
	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:54) [spring-security-web-3.1.4.RELEASE.jar:3.1.4.RELEASE]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) [spring-security-web-3.1.4.RELEASE.jar:3.1.4.RELEASE]
	at de.cloudscale.security.filter.BaseAuthenticationTokenProcessingFilter.doFilter(BaseAuthenticationTokenProcessingFilter.java:86) [BaseAuthenticationTokenProcessingFilter.class:na]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) [spring-security-web-3.1.4.RELEASE.jar:3.1.4.RELEASE]
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:183) [spring-security-web-3.1.4.RELEASE.jar:3.1.4.RELEASE]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) [spring-security-web-3.1.4.RELEASE.jar:3.1.4.RELEASE]
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:105) [spring-security-web-3.1.4.RELEASE.jar:3.1.4.RELEASE]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) [spring-security-web-3.1.4.RELEASE.jar:3.1.4.RELEASE]
	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:87) [spring-security-web-3.1.4.RELEASE.jar:3.1.4.RELEASE]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) [spring-security-web-3.1.4.RELEASE.jar:3.1.4.RELEASE]
	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:192) [spring-security-web-3.1.4.RELEASE.jar:3.1.4.RELEASE]
	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:160) [spring-security-web-3.1.4.RELEASE.jar:3.1.4.RELEASE]
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:343) [spring-web-3.2.5.RELEASE.jar:3.2.5.RELEASE]
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:260) [spring-web-3.2.5.RELEASE.jar:3.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:243) [catalina.jar:7.0.39.B]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210) [catalina.jar:7.0.39.B]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:222) [catalina.jar:7.0.39.B]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:123) [catalina.jar:7.0.39.B]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:472) [catalina.jar:7.0.39.B]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:171) [catalina.jar:7.0.39.B]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:99) [catalina.jar:7.0.39.B]
	at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:947) [catalina.jar:7.0.39.B]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:118) [catalina.jar:7.0.39.B]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:408) [catalina.jar:7.0.39.B]
	at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1009) [tomcat-coyote.jar:7.0.39.B]
	at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:589) [tomcat-coyote.jar:7.0.39.B]
	at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:312) [tomcat-coyote.jar:7.0.39.B]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) [na:1.7.0_45]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) [na:1.7.0_45]
	at java.lang.Thread.run(Thread.java:744) [na:1.7.0_45]
I guess the reason for that is as follows:
@SuppressWarnings("unchecked")
	private &amp;lt;S&amp;gt; S getPotentiallyConvertedValue(Object source, Class&amp;lt;S&amp;gt; targetType) {
		boolean conversionServiceAvailable = conversionService != null;
		boolean conversionNeeded = source == null || !targetType.isAssignableFrom(source.getClass());
		if (conversionServiceAvailable &amp;amp;&amp;amp; conversionNeeded) 
{
			return conversionService.convert(source, targetType);
		}

		return (S) source;
	}
In BeanWrapper.java the NPE for conversion service is thrown. Maybe it is not autowired?</description>
			<version>2.0 M1 (Codd)</version>
			<fixedVersion>2.0 RC1 (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.RepositoryTestsConfig.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.JpaWebTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.AbstractWebIntegrationTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">188</link>
		</links>
	</bug>
	<bug id="200" opendate="2013-12-04 12:38:23" fixdate="2013-12-04 22:53:20" resolution="Fixed">
		<buginformation>
			<summary>Embedded associations do not get rendered</summary>
			<description>





class Order {









  Set&amp;lt;LineItems&amp;gt; lineItems;




}






If Order is repository managed but LineItems is not, the line items do not get rendered at all.</description>
			<version>2.0 M1 (Codd)</version>
			<fixedVersion>2.0 RC1 (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.jpa.TestDataPopulator.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.JpaWebTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.Order.java</file>
		</fixedFiles>
	</bug>
	<bug id="188" opendate="2013-11-18 22:52:37" fixdate="2013-12-05 06:17:55" resolution="Fixed">
		<buginformation>
			<summary>Spring data rest wrongly handles jpa collection attributes</summary>
			<description>Given an entity with a collection attribute






@Entity




public class MyEntity {




......




	@ElementCollection(fetch=FetchType.EAGER)




	private Set&amp;lt;String&amp;gt; myAttribute;




.......






when you try to create a new instance with spring data rest, it throws an exception






01:01:03.453 [qtp1456083854-24] ERROR o.s.d.r.w.AbstractRepositoryRestController - argument type mismatch




java.lang.IllegalArgumentException: argument type mismatch




        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.7.0_40]




        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) ~[na:1.7.0_40]




        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.7.0_40]




        at java.lang.reflect.Method.invoke(Method.java:606) ~[na:1.7.0_40]




        at org.springframework.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:191) ~[spring-core-3.2.5.RELEASE.jar:3.2.5.RELEASE]




        at org.springframework.data.mapping.model.BeanWrapper.setProperty(BeanWrapper.java:97) ~[spring-data-commons-1.7.0.BUILD-SNAPSHOT.jar:na]




        at org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module$ResourceDeserializer.deserialize(PersistentEntityJackson2Module.java:226) ~[




spring-data-rest-webmvc-2.0.0.BUILD-SNAPSHOT.jar:na]




        at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:2888) ~[jackson-databind-2.2.2.jar:2.2.2]




        at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2094) ~[jackson-databind-2.2.2.jar:2.2.2]




        at org.springframework.http.converter.json.MappingJackson2HttpMessageConverter.readJavaType(MappingJackson2HttpMessageConverter.java:178) ~[spring-web-3




.2.5.RELEASE.jar:3.2.5.RELEASE]




        at org.springframework.http.converter.json.MappingJackson2HttpMessageConverter.readInternal(MappingJackson2HttpMessageConverter.java:166) ~[spring-web-3




.2.5.RELEASE.jar:3.2.5.RELEASE]




        at org.springframework.http.converter.AbstractHttpMessageConverter.read(AbstractHttpMessageConverter.java:153) ~[spring-web-3.2.5.RELEASE.jar:3.2.5.RELE




ASE]




        at org.springframework.data.rest.webmvc.PersistentEntityResourceHandlerMethodArgumentResolver.resolveArgument(PersistentEntityResourceHandlerMethodArgum




entResolver.java:48) ~[spring-data-rest-webmvc-2.0.0.BUILD-SNAPSHOT.jar:na]




        at org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:77) ~[sprin




g-web-3.2.5.RELEASE.jar:3.2.5.RELEASE]




        at org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:162) ~[spring-web-3.2.5.RELEASE.jar




:3.2.5.RELEASE]




        at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:123) ~[spring-web-3.2.5.RELEASE.jar:3.2.5.




RELEASE]




        at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:104) ~[spring-




webmvc-3.2.5.RELEASE.jar:3.2.5.RELEASE]




        at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandleMethod(RequestMappingHandlerAdapter.java:745) ~[spring




-webmvc-3.2.5.RELEASE.jar:3.2.5.RELEASE]




        at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:686) ~[spring-web






I think the problem is with PersistentEntityJackson2Module#deserialize where the collections are handled






if (Collection.class.isAssignableFrom(ctype)) {




	c = new ArrayList&amp;lt;Object&amp;gt;();




} else if (Set.class.isAssignableFrom(ctype)) {




	c = new HashSet&amp;lt;Object&amp;gt;();




}





 and it should be 






if (Set.class.isAssignableFrom(ctype)) {




	c = new HashSet&amp;lt;Object&amp;gt;();




} else if (Collection.class.isAssignableFrom(ctype)) {




	c = new ArrayList&amp;lt;Object&amp;gt;();




}





 or the first branch should consider List.class instead of Collection.class</description>
			<version>2.0 M1 (Codd)</version>
			<fixedVersion>2.0 RC1 (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.RepositoryTestsConfig.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.JpaWebTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.AbstractWebIntegrationTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">199</link>
		</links>
	</bug>
	<bug id="213" opendate="2013-12-27 06:36:24" fixdate="2013-12-29 11:34:42" resolution="Fixed">
		<buginformation>
			<summary>Make old presentation available for smooth migration to HAL</summary>
			<description>For people using SD Rest a bit longer, the migration towards HAL could take some time. So I think there a many people, which would really appreciate the opportunity of a smooth migration by default enabling both, the old and the new representation.
That would help, to be able to get the bugfixes regarding SDF 4.0 and for example the previously filed sorting bug.</description>
			<version>2.0 M1 (Codd)</version>
			<fixedVersion>2.0 RC1 (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">203</link>
		</links>
	</bug>
	<bug id="107" opendate="2013-08-15 23:57:55" fixdate="2014-01-13 12:23:51" resolution="Complete">
		<buginformation>
			<summary>@RestResource exported=false ignored on methods</summary>
			<description>The following will currently fail with duplicate mapping errors.






public interface CustomerRepository extends PagingAndSortingRepository&amp;lt;Customer, Long&amp;gt; {









	@RestResource(exported=false)




	List&amp;lt;Customer&amp;gt; findByUserId(Long id);









	Page&amp;lt;Customer&amp;gt; findByUserId(Long id, Pageable pageable);









}





</description>
			<version>1.1.0.M1</version>
			<fixedVersion>2.0 RC1 (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.core.mapping.ResourceMappingsIntegrationTest.java</file>
			<file type="M">org.springframework.data.rest.core.domain.jpa.PersonRepository.java</file>
			<file type="M">org.springframework.data.rest.core.mapping.ResourceMappings.java</file>
		</fixedFiles>
	</bug>
	<bug id="204" opendate="2013-12-13 05:35:58" fixdate="2014-01-18 09:02:14" resolution="Duplicate">
		<buginformation>
			<summary>Collection References not working with SF 4.0 due to generics changes</summary>
			<description>When calling an object relation like provider/3487T/services. The call fails with an NPE in ResourceProcessorHandlerMethodReturnValueHandler. The stacktrace is a follows: 






java.lang.NullPointerException




	org.springframework.data.rest.webmvc.ResourceProcessorHandlerMethodReturnValueHandler.handleReturnValue(ResourceProcessorHandlerMethodReturnValueHandler.java:161)




	org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite.handleReturnValue(HandlerMethodReturnValueHandlerComposite.java:71)




	org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:122)




	org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandleMethod(RequestMappingHandlerAdapter.java:748)




	org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:689)




	org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:83)




	org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:945)




	org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:876)




	org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:931)




	org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:822)




	javax.servlet.http.HttpServlet.service(HttpServlet.java:621)




	org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:807)




	javax.servlet.http.HttpServlet.service(HttpServlet.java:728)




	com.thetransactioncompany.cors.CORSFilter.doFilter(Unknown Source)




	com.thetransactioncompany.cors.CORSFilter.doFilter(Unknown Source)




	org.springframework.orm.jpa.support.OpenEntityManagerInViewFilter.doFilterInternal(OpenEntityManagerInViewFilter.java:177)




	org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:108)




	org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330)




	org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:118)




	org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:84)




	org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:113)




	org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:113)




	org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:54)




	org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	de.cloudscale.security.filter.BaseAuthenticationTokenProcessingFilter.doFilter(BaseAuthenticationTokenProcessingFilter.java:86)




	org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:183)




	org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:105)




	org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:87)




	org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:192)




	org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:160)




	org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:344)




	org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:261)






Error occurs in the following lines:






if (!elementTargetType.getType().equals(elementTypeInformation.getType())) {




  elementTargetType = elementTypeInformation;




}






as elementTargetType is null.</description>
			<version>2.0 M1 (Codd)</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryPropertyReferenceController.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.JpaWebTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.AbstractWebIntegrationTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.TestDataPopulator.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">198</link>
			<link type="Relate" description="relates to">181</link>
		</links>
	</bug>
	<bug id="198" opendate="2013-12-04 06:20:36" fixdate="2014-01-20 03:22:28" resolution="Fixed">
		<buginformation>
			<summary>NullPointerException when accessing OneToMany Relationship</summary>
			<description>I have a OneToMany relationship, when I try to access the elements of the collection using the link I get the following Exception: 






java.lang.NullPointerException




	at org.springframework.data.rest.webmvc.ResourceProcessorHandlerMethodReturnValueHandler.handleReturnValue(ResourceProcessorHandlerMethodReturnValueHandler.java:161)




	at org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite.handleReturnValue(HandlerMethodReturnValueHandlerComposite.java:71)




	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:122)




	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandleMethod(RequestMappingHandlerAdapter.java:748)




	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:689)




	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:83)




	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:947)




	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:878)




	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:946)




	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:837)




	at javax.servlet.http.HttpServlet.service(HttpServlet.java:621)




	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:822)




	at javax.servlet.http.HttpServlet.service(HttpServlet.java:728)




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:305)




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210)




	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:222)




	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:123)




	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:472)




	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:171)




	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:99)




	at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:947)




	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:118)




	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:408)




	at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1009)




	at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:589)




	at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:312)




	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)




	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)




	at java.lang.Thread.run(Thread.java:744)





</description>
			<version>2.0 M1 (Codd)</version>
			<fixedVersion>2.0 RC1 (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryPropertyReferenceController.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.JpaWebTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.AbstractWebIntegrationTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.TestDataPopulator.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="depends on">422</link>
			<link type="Duplicate" description="is duplicated by">204</link>
			<link type="Relate" description="relates to">181</link>
		</links>
	</bug>
	<bug id="222" opendate="2014-01-17 04:18:29" fixdate="2014-01-24 08:42:12" resolution="Fixed">
		<buginformation>
			<summary>Path.matches() should escape reference before trying to match it</summary>
			<description></description>
			<version>2.0 M1 (Codd)</version>
			<fixedVersion>2.0 RC1 (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.core.Path.java</file>
			<file type="M">org.springframework.data.rest.core.PathUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="50" opendate="2012-09-26 17:49:17" fixdate="2014-02-12 07:13:07" resolution="Fixed">
		<buginformation>
			<summary>Properties with null values are always omitted from the JSON</summary>
			<description>When I export a repository using RepositoryRestMvcConfiguration the JSON representation I get back from the exported resources omits any property whose value is null.
What I want:






{




  "links": ...snip...,




  "content": [




    {




      "links": ...snip...,




      "content": [




        "someProperty": "non null value",




        "someOtherProperty": null




      ]




    }




  ]




}






What I actually get:






{




  "links": ...snip...,




  "content": [




    {




      "links": ...snip...,




      "content": [




        "someProperty": "non null value",




      ]




    }




  ]




}






I think this is because properties with null values are always omitted when converting from an object to a resource. See EntityToResourceConverter&amp;amp;apos;s convert method, which contains this snippet:






if(null != (val = attrMeta.getValue().get(source))) {




  entityDto.put(name, val);




}






This behavior may sometimes be desirable but it seems incorrect for the framework to assume that it is always desirable.
It would be great if there was a way to specify the desired handling of null property values. A configuration option (somewhere) seems ideal; a hook method to override would also work.
I could replace the entire EntityToResourceConverter with a custom converter but this is a lot of framework code to branch just to remove one if statement.</description>
			<version>1.0.0.RC3</version>
			<fixedVersion>2.0 GA (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.jpa.JpaWebTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="246" opendate="2014-02-12 06:57:44" fixdate="2014-02-12 07:43:28" resolution="Fixed">
		<buginformation>
			<summary>ValidatingRepositoryEventListener should use Repositories more lenient</summary>
			<description>ValidatingRepositoryEventListener uses field injection to access a Repositories instance and does a by-type lookup of components in afterPropertiesSet() which can cause a circular reference on initialization.
We should rather use an ObjectFactory&amp;lt;Repositories&amp;gt; from within the listener so that the container can give us a proxy that will eventually return the Repositories instance but doesn&amp;amp;apos;t have to instantiate Repositories eagerly.</description>
			<version>2.0 RC1 (Codd)</version>
			<fixedVersion>2.0 GA (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.core.event.AbstractRepositoryEventListener.java</file>
			<file type="M">org.springframework.data.rest.core.context.ValidatorIntegrationTests.java</file>
			<file type="M">org.springframework.data.rest.core.event.ValidatingRepositoryEventListener.java</file>
			<file type="M">org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">432</link>
		</links>
	</bug>
	<bug id="216" opendate="2014-01-12 22:22:58" fixdate="2014-02-13 01:31:35" resolution="Fixed">
		<buginformation>
			<summary>AOP proxying does not work for findOne(ID) method</summary>
			<description>When attempting to apply AOP proxying to an overriden findOne(ID) method, the proxied method is not called.
Example:






@Override




@PreAuthorize("hasAuthority(&amp;amp;apos;ROLE_ADMIN&amp;amp;apos;)")




PurchaseOrder findOne(PurchaseOrderPK pk);






The problem is due to the base class &amp;amp;apos;findOne(Serializable id)&amp;amp;apos; method being called instead of the more specific, covariant version.
Although the obvious solution is to simply override the &amp;amp;apos;findOne(Serializable id)&amp;amp;apos; method and place an annotation on in it instead, this does not completely solve the issue. There are cases where it is desirable to overload the more specific version such as when one is using a spEL expression in an annotation and referring to a composite key, for example:






@Override




@PreAuthorize("#pk.getUserId() == authentication.id")




PurchaseOrder findOne(@Param("pk") PurchaseOrderPK pk);






The issue is specific to CrudRepository and PagingAndSortingRepository derived repositories.</description>
			<version>2.0 M1 (Codd)</version>
			<fixedVersion>2.0 GA (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.core.invoke.CrudRepositoryInvoker.java</file>
			<file type="M">org.springframework.data.rest.core.invoke.ReflectionRepositoryInvoker.java</file>
			<file type="M">org.springframework.data.rest.core.domain.jpa.OrderRepository.java</file>
			<file type="M">org.springframework.data.rest.core.domain.jpa.Order.java</file>
			<file type="M">org.springframework.data.rest.core.invoke.RepositoryInvoker.java</file>
		</fixedFiles>
	</bug>
	<bug id="238" opendate="2014-01-30 06:00:51" fixdate="2014-02-13 03:24:19" resolution="Fixed">
		<buginformation>
			<summary>PUT on entity with self links causes changes to be overwritten with old values</summary>
			<description>When PUTting the following JSON (a "Workload" entity):






{




  "version" : 1,




  "weight" : 123,




  "handlingMinutes" : 2,




  "articleCount" : 3,




  "address" : {




    "line1" : null,




    "line2" : null,




    "line3" : null,




    "postCode" : "53123",




    "city" : "Bonn          ",




    "countryCode" : null,




    "street" : "Bonner Bonnweg",




    "houseNumber" : "125"




  },




  "links" : [ {




    "rel" : "self",




    "href" : "http://127.0.0.1:8000/api/workloadDao/1060"




  }, {




    "rel" : "area",




    "href" : "http://127.0.0.1:8000/api/workloadDao/1060/area"




  }, {




    "rel" : "product",




    "href" : "http://127.0.0.1:8000/api/workloadDao/1060/product"




  } ]




}






.. the incoming JSON is converted all fine and well, until it runs into the links/rel/self/href thing, and hits this line: [1]
This causes the converted Workload entity from the PUT call to be overwritten with the old values. End-effect: A PUT looks like it is successful, but no changes are stored.
[1] https://github.com/spring-projects/spring-data-rest/blob/2.0.0.M1/spring-data-rest-webmvc/src/main/java/org/springframework/data/rest/webmvc/json/PersistentEntityJackson2Module.java#L135</description>
			<version>2.0 M1 (Codd)</version>
			<fixedVersion>2.0 GA (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryEntityController.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.JpaWebTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.AbstractWebIntegrationTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.RepositoryTestsConfig.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntitySerializationTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">143</link>
		</links>
	</bug>
	<bug id="217" opendate="2014-01-12 22:33:27" fixdate="2014-02-14 01:39:09" resolution="Fixed">
		<buginformation>
			<summary>Crud or PagingAndSorting based repository entites still listed when findAll method is &amp;apos;exported = false&amp;apos;</summary>
			<description>When a @RestResource(exported = false) annotation is placed against the appropriate (highest level of functionality) findAll() method, all entities are still shown in the REST JSON response.
Example:






@Override




@RestResource(exported = false)




Page&amp;lt;Person&amp;gt; findAll(Pageable pageable);





</description>
			<version>2.0 M1 (Codd)</version>
			<fixedVersion>2.0 GA (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryRestHandlerMappingUnitTests.java</file>
			<file type="M">org.springframework.data.rest.core.invoke.ReflectionRepositoryInvoker.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryEntityController.java</file>
			<file type="D">org.springframework.data.rest.webmvc.RepositoryRestRequestHandlerMethodArgumentResolver.java</file>
			<file type="M">org.springframework.data.rest.webmvc.AbstractControllerIntegrationTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositorySchemaController.java</file>
			<file type="D">org.springframework.data.rest.webmvc.RepositoryRestRequest.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositorySearchControllerIntegrationTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.PersistentEntityResourceHandlerMethodArgumentResolver.java</file>
			<file type="M">org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration.java</file>
			<file type="M">org.springframework.data.rest.webmvc.ResourceNotFoundException.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryPropertyReferenceController.java</file>
			<file type="D">org.springframework.data.rest.webmvc.RepositoryInvokerHandlerMethodArgumentResolver.java</file>
			<file type="M">org.springframework.data.rest.core.invoke.RepositoryInvocationInformation.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositorySearchController.java</file>
			<file type="M">org.springframework.data.rest.webmvc.AbstractRepositoryRestController.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.JpaWebTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="143" opendate="2013-08-27 01:33:12" fixdate="2014-02-14 04:26:34" resolution="Duplicate">
		<buginformation>
			<summary>PUT of entity with links fails..</summary>
			<description>Github Author: jhiemer
Github Last-Updated: 2013-03-22T20:05:51Z
This issue was automatically imported from github
Hi Jon,
when I am doing a put to the self link with embedded links I get an error. This means I need to remove all links before putting an element. I think this should not be the desired behaviour. Or?
Sample:






{




   "description":"adasdadsasdads",




   "name":"Customer Corp",




   "links":[




      {




         "rel":"self",




         "href":"http://localhost:8080/web/api/customer/1"




      },




      {




         "rel":"customer.customer.users",




         "href":"http://localhost:8080/web/api/customer/1/users"




      },




      {




         "rel":"customer.customer.credentials",




         "href":"http://localhost:8080/web/api/customer/1/credentials"




      },




      {




         "rel":"customer.customer.addresses",




         "href":"http://localhost:8080/web/api/customer/1/addresses"




      },




      {




         "rel":"customer.customer.sector",




         "href":"http://localhost:8080/web/api/customer/1/sector"




      }




   ]




}






The response is:






javascript




{




  "cause" : null,




  "message" : "Property &amp;amp;apos;links&amp;amp;apos; not found for entity de.model.customer.Customer"




}






Perhaps one additional note: the same happens, when using embedded entities like you described here: http://stackoverflow.com/questions/12879975/spring-data-rest-uri-vs-entity-id. Of course the POST fails, if I remove the links as the exporter is not able to find the customer in the database.</description>
			<version>2.0 M1 (Codd)</version>
			<fixedVersion>2.0 GA (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryEntityController.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.JpaWebTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.AbstractWebIntegrationTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.RepositoryTestsConfig.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntitySerializationTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">238</link>
		</links>
	</bug>
	<bug id="250" opendate="2014-02-20 04:26:16" fixdate="2014-02-24 00:12:26" resolution="Fixed">
		<buginformation>
			<summary>Embedded associations do not get rendered</summary>
			<description>





class Product {




  String name;




  String manufacturer;




  List&amp;lt;ProductAttribtue&amp;gt; attributes = new ArrayList&amp;lt;&amp;gt;();




}






if Product repository is present (managed) and there is no repository for ProductAttribute then the exported JSON content only shows product but no attributes:






{




"_links":{




"self":{




"href":"http://localhost:8080/products/1"




}




},




"name":"Test Product",




"manufacturer":"HP",




}





</description>
			<version>2.0 RC1 (Codd)</version>
			<fixedVersion>2.0 GA (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.jpa.Order.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntitySerializationTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.RepositoryTestsConfig.java</file>
			<file type="M">org.springframework.data.rest.webmvc.util.TestUtils.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module.java</file>
			<file type="M">org.springframework.data.rest.webmvc.AbstractWebIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="254" opendate="2014-02-24 18:29:53" fixdate="2014-02-24 23:34:38" resolution="Fixed">
		<buginformation>
			<summary>org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module does not properly handle JPA @Transient annotation during serialization yeilding a NPE</summary>
			<description>Create and Entity as per below:
@Entity
@Table(name = "category")
public class Category implements Serializable {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    protected Long id;
    @Column(name = "description")
    protected String description;
    @Column(name="last_change_dtm")
    private Date lastChangeDate;
    @Transient
    private Long key;
    ...
}
Method org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module.updateBuilder(SerializationConfig config, BeanDescription beanDesc, BeanSerializerBuilder builder) with throw a NullPointerException when trying to serialize the key property of Category bean.  Within the for loop, @Transient properties will result in a null persistentProperty and the subsequent if() statement will throw a NPE.  This did not occur in Spring Data Rest 2.0.0.RC1.
</description>
			<version>2.0 GA (Codd)</version>
			<fixedVersion>2.0.1 (Codd SR1), 2.1 M1 (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.AbstractRepositoryRestController.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.Order.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntitySerializationTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">253</link>
		</links>
	</bug>
	<bug id="253" opendate="2014-02-24 10:55:29" fixdate="2014-02-24 23:34:47" resolution="Fixed">
		<buginformation>
			<summary>AssociationOmittingSerializerModifier suffers from potential NullPointerException</summary>
			<description>AssociationOmittingSerializerModifier traverses the properties Jackson detected and checks whether they&amp;amp;apos;re associations. For properties not backed by a field at all (i.e. getters that represent a calculated business value) the PersistentProperty will be null and the subsequent if-clauses will cause a NullPointerException.</description>
			<version>2.0 GA (Codd)</version>
			<fixedVersion>2.0.1 (Codd SR1), 2.1 M1 (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.AbstractRepositoryRestController.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.Order.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntitySerializationTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">254</link>
		</links>
	</bug>
	<bug id="261" opendate="2014-02-27 05:15:11" fixdate="2014-02-27 05:55:27" resolution="Fixed">
		<buginformation>
			<summary>RepositoryRelProvider is not registered</summary>
			<description>Currently there&amp;amp;apos;s bean registered for the RepositoryRelProvider implementation that returns rels based on the mapping information.
This causes components using a RelProvider to calculate rels (in contrast to ones that directly use the ResourceMapping (such as the root controller). This causes different rels being rendered depending on which API a component uses.</description>
			<version>2.0 GA (Codd)</version>
			<fixedVersion>2.0.1 (Codd SR1), 2.1 M1 (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration.java</file>
			<file type="M">org.springframework.data.rest.webmvc.AbstractWebIntegrationTests.java</file>
			<file type="M">org.springframework.data.rest.core.support.RepositoryRelProvider.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.JpaWebTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="247" opendate="2014-02-17 03:29:12" fixdate="2014-03-11 11:37:11" resolution="Fixed">
		<buginformation>
			<summary>NPE when calling count Queries in SD MongoDB Repositories</summary>
			<description>I created the following query:






@Query(value = "{&amp;amp;apos;requestId&amp;amp;apos;: ?0}", count = true)




public Long countByRequestId(@Param("id") String id);






Trying to access this query via SD REST, results in a NPE. This NPE is thrown in the AbstractRepositoryRestController. The throwing method is:






@SuppressWarnings({ "unchecked" })




	protected Resources resultToResources(Object result) {









		if (result instanceof Page) {




			Page&amp;lt;Object&amp;gt; page = (Page&amp;lt;Object&amp;gt;) result;




			return entitiesToResources(page, assembler);




		} else if (result instanceof Iterable) {




			return entitiesToResources((Iterable&amp;lt;Object&amp;gt;) result);




		} else if (null == result) {




			return new Resources(EMPTY_RESOURCE_LIST);




		} else {




			Resource&amp;lt;Object&amp;gt; resource = perAssembler.toResource(result);




			return new Resources(Collections.singletonList(resource));




		}




	}






As the query returns Long the method steps into:






Resource&amp;lt;Object&amp;gt; resource = perAssembler.toResource(result);






which results in a Null instance for entity in:






PersistentEntity&amp;lt;?, ?&amp;gt; entity = repositories.getPersistentEntity(instance.getClass());






and then leads to the NPE.</description>
			<version>2.0 M1 (Codd)</version>
			<fixedVersion>2.0.1 (Codd SR1), 2.1 M1 (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.mongodb.ProfileRepository.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositorySearchControllerIntegrationTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.mongodb.MongoWebTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.AbstractWebIntegrationTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositorySearchController.java</file>
		</fixedFiles>
	</bug>
	<bug id="288" opendate="2014-04-10 00:23:11" fixdate="2014-04-10 03:29:24" resolution="Fixed">
		<buginformation>
			<summary>RepositorySchemaController must not depend on javax.validation</summary>
			<description></description>
			<version>2.0.1 (Codd SR1)</version>
			<fixedVersion>2.0.2 (Codd SR2), 2.1 RC1 (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityToJsonSchemaConverter.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositorySchemaController.java</file>
		</fixedFiles>
	</bug>
	<bug id="298" opendate="2014-04-29 03:27:54" fixdate="2014-04-29 03:34:43" resolution="Fixed">
		<buginformation>
			<summary>"rel" attribute of @RestResource should be optional</summary>
			<description>When a finder method does not have any @RestResource annotation, the name of the method is taken by default.
The following construct does not work, I would expect it to take the custom path as the rel value instead of the following exception:






@RestResource(path = "username")




UserAccount findByUsername(@Param("name") String username);












java.lang.IllegalArgumentException: Rel must not be null or empty!




	at org.springframework.util.Assert.hasText(Assert.java:162)




	at org.springframework.hateoas.Link.&amp;lt;init&amp;gt;(Link.java:88)




	at org.springframework.hateoas.Link.&amp;lt;init&amp;gt;(Link.java:76)




	at org.springframework.data.rest.webmvc.RepositorySearchController.getSearchLinks(RepositorySearchController.java:247)




	at org.springframework.data.rest.webmvc.RepositorySearchController.listSearches(RepositorySearchController.java:108)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:483)





</description>
			<version>2.0.2 (Codd SR2)</version>
			<fixedVersion>2.1 RC1 (Dijkstra), 2.0.3 (Codd SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.core.mapping.RepositoryMethodResourceMapping.java</file>
			<file type="M">org.springframework.data.rest.core.mapping.RepositoryMethodResourceMappingUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="276" opendate="2014-03-20 05:46:49" fixdate="2014-05-02 05:44:53" resolution="Fixed">
		<buginformation>
			<summary>500 returned if URL ends with /</summary>
			<description>So it all works fine if I try to access:
http://localhost:8111/rest/product
but if I try this:
http://localhost:8111/rest/product/
I get response 500 - no exception in the log or the response body.
I&amp;amp;apos;m testing against the 2.1 SNAPSHOT</description>
			<version>2.1 M1 (Dijkstra)</version>
			<fixedVersion>2.1 RC1 (Dijkstra), 2.0.3 (Codd SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.BaseUri.java</file>
			<file type="M">org.springframework.data.rest.webmvc.BaseUriUnitTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.config.ResourceMetadataHandlerMethodArgumentResolver.java</file>
			<file type="M">org.springframework.data.rest.webmvc.support.BackendIdHandlerMethodArgumentResolver.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryRestHandlerMapping.java</file>
			<file type="M">org.springframework.data.rest.webmvc.util.UriUtils.java</file>
			<file type="M">org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryRestHandlerMappingUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="301" opendate="2014-05-06 01:58:25" fixdate="2014-05-06 03:24:08" resolution="Fixed">
		<buginformation>
			<summary>Illegal character &amp;apos;{&amp;apos; in URL when using projection and PUT request</summary>
			<description>We are calling URL http://localhost:8080/rapnot/companies/4 with PUT method in order to update data.
In the logs, we see this error: 






2014-05-06 10:54:45,688 ERROR [org.springframework.data.rest.webmvc.AbstractRepositoryRestController] Illegal character in path at index 40: http://localhost:8080/rapnot/companies/4{?projection}






The {?projection} has been added to the URL and we get an invalid URL.
The issue seems to be located in this part of the code in org.springframework.data.rest.webmvc.RepositoryEntityController:






private ResponseEntity&amp;lt;ResourceSupport&amp;gt; mergeAndReturn(Object incoming, Object domainObject,




	RepositoryInvoker invoker, HttpMethod httpMethod, PersistentEntityResourceAssembler assembler) {









	









	if (PUT.equals(httpMethod)) {




		headers.setLocation(URI.create(assembler.getSelfLinkFor(obj).getHref()));




	}




	




}






At least, this is where the {?projection} is added to the URL.</description>
			<version>2.1 RC1 (Dijkstra)</version>
			<fixedVersion>2.0.3 (Codd SR3), 2.1 GA (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryEntityControllerIntegrationTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryEntityController.java</file>
		</fixedFiles>
	</bug>
	<bug id="307" opendate="2014-05-20 04:31:13" fixdate="2014-05-20 04:41:44" resolution="Fixed">
		<buginformation>
			<summary>Root mapping not discovered on Tomcat</summary>
			<description>In case the URI handling returns an empty String (e.g. on requests to the root mapping) the subsequent lookup of the handler method fails to discover the RepositoryController on Tomcat.</description>
			<version>2.1 RC1 (Dijkstra)</version>
			<fixedVersion>2.1 GA (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryRestHandlerMapping.java</file>
		</fixedFiles>
	</bug>
	<bug id="311" opendate="2014-05-30 05:40:22" fixdate="2014-06-02 03:07:33" resolution="Fixed">
		<buginformation>
			<summary>executeSearchCompact - Mismatch argument name and path variable name</summary>
			<description>In the RepositorySearchController class, the method executeSearchCompact does not take the right argument.
This case happens when the Accept values in the Request Header contains application/*+json
If you use the browser, no issue can be detected.</description>
			<version>2.0.2 (Codd SR2)</version>
			<fixedVersion>2.0.3 (Codd SR3), 2.1.1 (Dijkstra SR1), 2.2 M1 (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.jpa.JpaWebTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.AbstractWebIntegrationTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositorySearchController.java</file>
		</fixedFiles>
	</bug>
	<bug id="316" opendate="2014-06-10 07:47:27" fixdate="2014-06-12 03:46:55" resolution="Fixed">
		<buginformation>
			<summary>UriStringDeserializer should guard against URI templates submitted</summary>
			<description>Currently UriStringDeserializer uses the raw String provided for the value and tries to create a URI instance from it. In case the client accidentally submits a URI tempalte, this will fail.
The UriStringDeserializer should defensively expand the given value to make sure optional template variables are stripped.</description>
			<version>2.0.2 (Codd SR2)</version>
			<fixedVersion>2.0.3 (Codd SR3), 2.1.1 (Dijkstra SR1), 2.2 M1 (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryPropertyReferenceController.java</file>
		</fixedFiles>
	</bug>
	<bug id="325" opendate="2014-06-19 08:58:28" fixdate="2014-06-20 02:52:56" resolution="Fixed">
		<buginformation>
			<summary>ReflectionRepositoryInvoker fails to invoke non-public methods</summary>
			<description>Assume the following repository:






@RepositoryRestResource




interface AuthorRepository extends Repository&amp;lt;Author, Long&amp;gt; {









	List&amp;lt;Author&amp;gt; findByFirstnameContaining(String name);




}






This repo is package scope but still exported, due to its  @RepositoryRestResource annotation. Trying to invoke the finder will cause an exception in ReflectionRepositoryInvoker.invoke() as the method is not accessible.</description>
			<version>2.0.3 (Codd SR3)</version>
			<fixedVersion>2.1.1 (Dijkstra SR1), 2.2 M1 (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.core.invoke.ReflectionRepositoryInvokerIntegrationTests.java</file>
			<file type="M">org.springframework.data.rest.core.invoke.ReflectionRepositoryInvoker.java</file>
			<file type="M">org.springframework.data.rest.core.mapping.ResourceMappingsIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="327" opendate="2014-06-19 14:16:29" fixdate="2014-06-20 05:08:14" resolution="Fixed">
		<buginformation>
			<summary>Collection references are removed on PUT and PATCH if defaulted to empty collections</summary>
			<description>Whenever a PUT or PATCH is performed, the DomainObjectMerger erases the objects references/associations if not null on the "from" object. In our case of one-to-many, we initialize those variable to empty arrays so they are never null unless explicitly set so. I&amp;amp;apos;m curious as to why the DomainObjectMerger even would attempt to merge associations? Is it possible to send associations in the same payload as the aggregate root object? If so, then i could see why it would do so, but if not, then what is the point?
Work around for now is to not default association values to empty collections.</description>
			<version>2.1 GA (Dijkstra)</version>
			<fixedVersion>2.1.1 (Dijkstra SR1), 2.2 M1 (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.security.SecureJpaConfiguration.java</file>
			<file type="M">org.springframework.data.rest.webmvc.security.PreAuthorizedOrderRepository.java</file>
			<file type="M">org.springframework.data.rest.webmvc.solr.SolrWebTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.security.SecurityConfiguration.java</file>
			<file type="M">org.springframework.data.rest.webmvc.security.SecuredPersonRepository.java</file>
			<file type="M">org.springframework.data.rest.webmvc.support.ExceptionHandlingCustomizationIntegrationTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.security.SecurityIntegrationTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.security.Person.java</file>
			<file type="M">org.springframework.data.rest.core.support.DomainObjectMerger.java</file>
			<file type="M">org.springframework.data.rest.core.support.DomainObjectMergerTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="329" opendate="2014-06-24 05:29:48" fixdate="2014-06-24 06:41:02" resolution="Fixed">
		<buginformation>
			<summary>RepositoryRestMvcConfiguration causes eager initialization of beans</summary>
			<description>RepositoryRestMvcConfiguration declares a bean of type AnnotatedHandlerBeanPostProcessor which is a BeanPostProcessor and thus will get initialized very early in the container lifecycle. This however means that the configuration class will be populated and thus trigger the creation of all beans that need to be autowired into the container.
We should make the bean definition method static as it doesn&amp;amp;apos;t actually require any dependencies be present in the first place.</description>
			<version>2.1 GA (Dijkstra)</version>
			<fixedVersion>2.1.1 (Dijkstra SR1), 2.2 M1 (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration.java</file>
			<file type="M">org.springframework.data.rest.webmvc.neo4j.Neo4jWebTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="331" opendate="2014-06-24 10:16:07" fixdate="2014-06-24 10:44:05" resolution="Fixed">
		<buginformation>
			<summary>Improvements in ResourceProcessorHandlerMethodReturnValueHandler</summary>
			<description>ResourceProcessorHandlerMethodReturnValueHandler currently doesn&amp;amp;apos;t invoke ResourceProcessor instances that are typed to Resources if the value returned from the controller is a subtype of Resources (e.g. PagedResources).</description>
			<version>2.1 GA (Dijkstra)</version>
			<fixedVersion>2.1.1 (Dijkstra SR1), 2.2 M1 (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.ResourceProcessorHandlerMethodReturnValueHandlerUnitTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.ResourceProcessorHandlerMethodReturnValueHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="335" opendate="2014-06-25 20:59:21" fixdate="2014-06-27 08:10:17" resolution="Fixed">
		<buginformation>
			<summary>Overriding repositories delete method results in "argument type mismatch" exception</summary>
			<description>Hi,
I just tried to override the delete method in a repository and when I try to call the URL DELETE http://localhost:8080/webapp/xs/53ab96c930049cc029440d46 Spring throws an exception within AbstractRepositoryRestController line 177.
Stacktrace says:

2014-06-26 05:44:02,011 ERROR o.s.d.rest.webmvc.AbstractRepositoryRestController: 177 - argument type mismatch
java.lang.IllegalArgumentException: argument type mismatch
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_05]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_05]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_05]
	at java.lang.reflect.Method.invoke(Method.java:483) ~[na:1.8.0_05]
	at org.springframework.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:196) ~[ReflectionUtils.class:4.0.5.RELEASE]
	at org.springframework.data.rest.core.invoke.ReflectionRepositoryInvoker.invoke(ReflectionRepositoryInvoker.java:277) ~[ReflectionRepositoryInvoker.class:na]
	at org.springframework.data.rest.core.invoke.ReflectionRepositoryInvoker.invokeDelete(ReflectionRepositoryInvoker.java:210) ~[ReflectionRepositoryInvoker.class:na]
...
My code ist fairly simple:






@Document(collection="x")




public class X implements Identifiable&amp;lt;ObjectId&amp;gt; {




	@Id ObjectId id;




	public ObjectId getId() { return id; };




	




	String x;




	public String getX() { return x; }




	public void setX(String x) { this.x = x; }




}









@RepositoryRestResource(




		path="xs",




		collectionResourceDescription=@Description("Xs"),




		collectionResourceRel="xs",




		itemResourceDescription=@Description("X"),




		itemResourceRel="x"




		)




public interface XRepo extends MongoRepository&amp;lt;X, ObjectId&amp;gt;, XRepoCustom {}









public interface XRepoCustom {




	void delete(ObjectId id);




}









public class XRepoImpl implements XRepoCustom {




	@Override




	public void delete(ObjectId id) {




		System.out.println("WORKS");




	}	




}






I tried to find the underlying reason using the debugger, but after a few steps the code only consists of reflection method calling and I couldn&amp;amp;apos;t figure out what really happens underneath.
EDIT:
I now tried the same thing with the Page&amp;lt;X&amp;gt; findAll(Pageable pageable) method. And it works. So it must have something to do with the delete method, I think.</description>
			<version>2.1 GA (Dijkstra)</version>
			<fixedVersion>2.1.1 (Dijkstra SR1), 2.2 M1 (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.core.invoke.ReflectionRepositoryInvokerIntegrationTests.java</file>
			<file type="M">org.springframework.data.rest.core.invoke.ReflectionRepositoryInvoker.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">346</link>
		</links>
	</bug>
	<bug id="328" opendate="2014-06-19 20:00:01" fixdate="2014-06-27 09:51:13" resolution="Fixed">
		<buginformation>
			<summary>Serialization errors if type contains only renamed properties</summary>
			<description>Adding @EnableMongoAuditing to an application configuration causes a few different problems related to (but probably not caused by) Jackson serialization.  These issues can be reproduced by (1) starting an application with @EnableMongoAuditing, (2) POSTing certain types of entities to a RepositoryRestResource, and (3) attempting to GET from the same repository.  
Please refer to the referenced URL for a working example based on the mongodb-data-rest getting-started sample.  Also note the comment with sample command-line input at: https://github.com/ncantelmo/gs-accessing-mongodb-data-rest/commit/988626629a1ef708b5a3d44c4bd8b2874662747f#commitcomment-6740135
Additional notes:

This issue was initially identified in an application that implemented AuditorAware.  The inclusion of an AuditorAware bean appears to make no difference on the described behavior.
The following sequence of events will NOT reveal the issue: (1) POST a new document to some repository X, (2) Restart the application, (3), GET from repository X, (4) POST another document with the same fields to repository X, (5) GET from repository X.
In other words, if you GET from a populated repository before you POST, the serialization routines will work properly.
In the referenced example, removing the @JsonProperty("brand_name") annotation in PetFood.java will prevent serialization from causing a crash.
In root-level entities or immediate nested children, custom @JsonProperty annotations will cause the annotated properties to not be fetched during a GET after an initial POST, but won&amp;amp;apos;t cause a crash.

</description>
			<version>2.1 GA (Dijkstra)</version>
			<fixedVersion>2.1.1 (Dijkstra SR1), 2.2 M1 (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">320</link>
		</links>
	</bug>
	<bug id="320" opendate="2014-06-13 05:04:09" fixdate="2014-06-27 09:53:37" resolution="Fixed">
		<buginformation>
			<summary>Fields with @JsonProperty are ignored on serialization</summary>
			<description>Field annotated with @JsonProperty are left out from the serialization. This also means that it is not possible to alter the json property name. 
The problem seems to be caused by 





PersistentEntityJackson2Module.updateBuilder(..)





 on line #219, where the property is attempted looked up by the name from the @JsonProperty, instead of the "real" property name. One way I think this can be solved is to add an inner loop to find the internal name from beanDesc.findProperties().
Example:






@Entity




public class Description {    




    private String heading;




    @JsonProperty("body")




    private String content;




    ...




}






On serialization, everything looks fine from Jackson&amp;amp;apos;s perspective, but when the updateBuilder() hook on PersistentEntityJackson2Module is called the content property is omitted because the name of the field is different from the @JsonProperty.
I haven&amp;amp;apos;t sent a pull request, since I haven&amp;amp;apos;t enlisted in the contributor program, but hopefully you can cherry pick or look at the commit on my fork.
This problem was also described in DATAREST-117 and the corresponding pull request that was never merged: https://github.com/spring-projects/spring-data-rest/pull/136.</description>
			<version>2.1 GA (Dijkstra)</version>
			<fixedVersion>2.1.1 (Dijkstra SR1), 2.2 M1 (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">328</link>
		</links>
	</bug>
	<bug id="340" opendate="2014-06-30 04:14:34" fixdate="2014-06-30 04:32:19" resolution="Fixed">
		<buginformation>
			<summary>Non-persistent properties not rendered</summary>
			<description>See the Boot issue for reference.</description>
			<version>2.1 GA (Dijkstra)</version>
			<fixedVersion>2.1.1 (Dijkstra SR1), 2.2 M1 (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityJackson2ModuleUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="346" opendate="2014-07-02 04:17:43" fixdate="2014-07-08 05:06:09" resolution="Fixed">
		<buginformation>
			<summary>ReflectionRepositoryInvoker doesn&amp;apos;t apply conversion on invocation of an overridden delete() method</summary>
			<description>If a repository redeclares a delete() method using the concrete identifier type the ReflectionRepositoryInvoker fails to invoke this method as it will get the raw id value handed into the invokeDelete() method.
This is a side effect of the fix for DATAREST-335 which added explicit handling for the overridden method with the concrete identifier type but assumed the parameter would be handed in the correct type already.</description>
			<version>2.1.1 (Dijkstra SR1)</version>
			<fixedVersion>2.2 M1 (Evans), 2.1.2 (Dijkstra SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.core.invoke.ReflectionRepositoryInvokerIntegrationTests.java</file>
			<file type="M">org.springframework.data.rest.core.invoke.ReflectionRepositoryInvoker.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">335</link>
		</links>
	</bug>
	<bug id="319" opendate="2014-06-12 07:36:42" fixdate="2014-07-15 01:42:32" resolution="Fixed">
		<buginformation>
			<summary>Add means to prefer deleting by object instead of deleting by id</summary>
			<description>From the REST interface to the Repository you cannot force preference for using the void delete(T t) method over void delete(ID id) method. As a result we cannot do @PreAuthorize filters on delete based of object values. A use case for this would be to set security constraints.</description>
			<version>2.1 GA (Dijkstra)</version>
			<fixedVersion>2.2 RC1 (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.core.invoke.ReflectionRepositoryInvokerIntegrationTests.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="depends on">539</link>
		</links>
	</bug>
	<bug id="353" opendate="2014-07-11 03:15:09" fixdate="2014-07-16 08:49:09" resolution="Fixed">
		<buginformation>
			<summary>Deleting a non-existing resource leads to NullPointerException in RepositoryEntityController</summary>
			<description>When trying to access resources from Spring MVC (named custom DELETEs/PUTs above) like this:
DELETE 
http://172.16.56.1:8080/service/entity/removeBySubInstanceId?subInstanceId=ec81d9fc48f328052fc59e1c6a34ea2f
A NPE in AbstractRepositoryRestController is thrown.






OGBACK:12:02:59.986 [tomcat-http--5] ERROR o.s.d.r.w.AbstractRepositoryRestController - null source




java.lang.IllegalArgumentException: null source




	at java.util.EventObject.&amp;lt;init&amp;gt;(EventObject.java:56) ~[na:1.7.0_45]




	at org.springframework.context.ApplicationEvent.&amp;lt;init&amp;gt;(ApplicationEvent.java:42) ~[spring-context-4.0.2.RELEASE.jar:4.0.2.RELEASE]




	at org.springframework.data.rest.core.event.RepositoryEvent.&amp;lt;init&amp;gt;(RepositoryEvent.java:15) ~[spring-data-rest-core-2.2.0.BUILD-SNAPSHOT.jar:na]




	at org.springframework.data.rest.core.event.BeforeDeleteEvent.&amp;lt;init&amp;gt;(BeforeDeleteEvent.java:13) ~[spring-data-rest-core-2.2.0.BUILD-SNAPSHOT.jar:na]




	at org.springframework.data.rest.webmvc.RepositoryEntityController.deleteItemResource(RepositoryEntityController.java:356) ~[spring-data-rest-webmvc-2.2.0.BUILD-SNAPSHOT.jar:na]




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.7.0_45]




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) ~[na:1.7.0_45]




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.7.0_45]




	at java.lang.reflect.Method.invoke(Method.java:606) ~[na:1.7.0_45]




	at org.springframework.web.method.support.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:215) ~[spring-web-4.0.2.RELEASE.jar:4.0.2.RELEASE]




	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:132) ~[spring-web-4.0.2.RELEASE.jar:4.0.2.RELEASE]




	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:104) ~[spring-webmvc-4.0.2.RELEASE.jar:4.0.2.RELEASE]




	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandleMethod(RequestMappingHandlerAdapter.java:749) ~[spring-webmvc-4.0.2.RELEASE.jar:4.0.2.RELEASE]




	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:690) ~[spring-webmvc-4.0.2.RELEASE.jar:4.0.2.RELEASE]




	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:83) ~[spring-webmvc-4.0.2.RELEASE.jar:4.0.2.RELEASE]




	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:945) ~[spring-webmvc-4.0.2.RELEASE.jar:4.0.2.RELEASE]




	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:876) ~[spring-webmvc-4.0.2.RELEASE.jar:4.0.2.RELEASE]




	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:961) [spring-webmvc-4.0.2.RELEASE.jar:4.0.2.RELEASE]




	at org.springframework.web.servlet.FrameworkServlet.doDelete(FrameworkServlet.java:885) [spring-webmvc-4.0.2.RELEASE.jar:4.0.2.RELEASE]




	at javax.servlet.http.HttpServlet.service(HttpServlet.java:653) [servlet-api.jar:na]




	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:837) [spring-webmvc-4.0.2.RELEASE.jar:4.0.2.RELEASE]




	at javax.servlet.http.HttpServlet.service(HttpServlet.java:728) [servlet-api.jar:na]




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:305) [catalina.jar:7.0.42.A]




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210) [catalina.jar:7.0.42.A]




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) [spring-security-web-3.2.0.RELEASE.jar:3.2.0.RELEASE]




	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:118) [spring-security-web-3.2.0.RELEASE.jar:3.2.0.RELEASE]




	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:84) [spring-security-web-3.2.0.RELEASE.jar:3.2.0.RELEASE]




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) [spring-security-web-3.2.0.RELEASE.jar:3.2.0.RELEASE]




	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:113) [spring-security-web-3.2.0.RELEASE.jar:3.2.0.RELEASE]




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) [spring-security-web-3.2.0.RELEASE.jar:3.2.0.RELEASE]




	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:113) [spring-security-web-3.2.0.RELEASE.jar:3.2.0.RELEASE]




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) [spring-security-web-3.2.0.RELEASE.jar:3.2.0.RELEASE]




	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:154) [spring-security-web-3.2.0.RELEASE.jar:3.2.0.RELEASE]






Same behaviour applies for custom PUT operations afaik.</description>
			<version>2.2 M1 (Evans)</version>
			<fixedVersion>2.1.2 (Dijkstra SR2), 2.2 RC1 (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryEntityController.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.JpaWebTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="381" opendate="2014-09-04 05:27:11" fixdate="2014-09-04 05:36:55" resolution="Fixed">
		<buginformation>
			<summary>Controllers for Alps and repository listing get listed under the root even if a base URI is configured</summary>
			<description></description>
			<version>2.2 RC1 (Evans)</version>
			<fixedVersion>2.2.1 (Evans SR1), 2.3 M1 (Fowler)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryEntityController.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryRestHandlerAdapter.java</file>
			<file type="M">org.springframework.data.rest.webmvc.alps.AlpsController.java</file>
			<file type="M">org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryRestHandlerMapping.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryController.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryRestController.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">411</link>
		</links>
	</bug>
	<bug id="384" opendate="2014-09-10 07:32:44" fixdate="2014-10-15 04:36:03" resolution="Fixed">
		<buginformation>
			<summary>Query method do not consider Sort parameters</summary>
			<description>Assume you have a repository interface like this:






public interface CustomerRepository extends Repository&amp;lt;Customer, Long&amp;gt; {









  List&amp;lt;Customer&amp;gt; findByLastname(@Param("lastname") String lastname, Sort sort);




}






then the Sort paramter is neither advertised






{ "_links" : {




    "findByLastname" : {




      "href" : "http://localhost:8080/customers/search/findByLastname{?lastname}",




      "templated" : true




    }




  }




}






nor is it considered if you trigger a request to the URI:






http://localhost:8080/customers/search/findByLastname?sort=firstname,asc





</description>
			<version>2.1.4 (Dijkstra SR4)</version>
			<fixedVersion>2.2.1 (Evans SR1), 2.3 M1 (Fowler)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.jpa.TestDataPopulator.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.JpaWebTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.BookRepository.java</file>
			<file type="M">org.springframework.data.rest.webmvc.support.DefaultedPageable.java</file>
			<file type="M">org.springframework.data.rest.core.mapping.RepositoryMethodResourceMapping.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositorySearchControllerIntegrationTests.java</file>
			<file type="M">org.springframework.data.rest.core.mapping.MethodResourceMapping.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositorySearchController.java</file>
			<file type="M">org.springframework.data.rest.core.mapping.RepositoryMethodResourceMappingUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="411" opendate="2014-11-16 12:25:13" fixdate="2014-11-16 23:28:17" resolution="Duplicate">
		<buginformation>
			<summary>BaseUrl mapping not workig</summary>
			<description>Not sure if the issue is with Data-Rest or Spring Boot but extending RepositoryRestConfiguration and setting a BaseUri (to say /rest) using 1.1.9.RELEASE move the list repository controller from / to /rest allowing / to get to the index.html page in src/main/resource/public/ amending to version
&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;1.2.0.M2&amp;lt;/version&amp;gt;
Make the list repository controller work on BOTH / and /rest</description>
			<version>2.2 GA (Evans)</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryEntityController.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryRestHandlerAdapter.java</file>
			<file type="M">org.springframework.data.rest.webmvc.alps.AlpsController.java</file>
			<file type="M">org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryRestHandlerMapping.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryController.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryRestController.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">381</link>
		</links>
	</bug>
	<bug id="394" opendate="2014-09-26 12:26:22" fixdate="2014-12-01 10:18:38" resolution="Fixed">
		<buginformation>
			<summary>Projections are not applied to collection attributes</summary>
			<description>When a projection has an attribute which is a collection of another projection, Spring Data REST is not populating the collection with projections but with entities. This patch allows Spring Data REST to apply projections to collection attributes as well.</description>
			<version>2.1.4 (Dijkstra SR4)</version>
			<fixedVersion>2.3 M1 (Fowler), 2.1.5 (Dijkstra SR5), 2.2.2 (Evans SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.core.projection.ProjectingMethodInterceptor.java</file>
			<file type="M">org.springframework.data.rest.core.projection.ProjectingMethodInterceptorUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">408</link>
		</links>
	</bug>
	<bug id="408" opendate="2014-11-11 00:04:37" fixdate="2014-12-01 10:18:42" resolution="Fixed">
		<buginformation>
			<summary>Nested projections not loading nested lists</summary>
			<description>When nesting projections, Lists/Maps are not included in the processing. Sample:
The following snippet represents the nested projection, which contains a list of limitations.






"name" : "Light",




    "description" : "Light",




    "enabled" : true,




    "limitations" : [ {




      "name" : "Request",




      "description" : "Number of requests per billing period",




      "type" : null,




      "value" : 20.0




    } ],




    "links" : [ ],




    "content" : [ ],




    "links" : [ {




      "rel" : "self",




      "href" : "http://localhost:8080/web/specifications/1310{?projection}"




    }, {




      "rel" : "limitations",




      "href" : "http://localhost:8080/web/specifications/1310/limitations"




    }, {




      "rel" : "product",




      "href" : "http://localhost:8080/web/specifications/1310/product"




    }






Using the parent projection, which contains the nested projection






"name" : "Light",




    "description" : "Light",




    "prices" : [ {




      "value" : -1.0,




      "currency" : "USD",




      "unit" : "Request",




      "period" : "Month",




      "interval" : 1,




      "approximation" : false,




      "component" : null




    } ],




    "productCategory" : {




      "name" : "Price comparison",




      "description" : "Blablablaba"




    },




    "specifications" : [ {




      "name" : "Light",




      "description" : "Light",




      "enabled" : true




    } ],




    "trialPeriod" : null,




    "trialInterval" : 0,




    "links" : [ ],




    "content" : [ ],




    "links" : [ {




      "rel" : "self",




      "href" : "http://localhost:8080/web/products/1300{?projection}"




    }, {




      "rel" : "specifications",




      "href" : "http://localhost:8080/web/products/1300/specifications"




    }, {




      "rel" : "product",




      "href" : "http://localhost:8080/web/products/1300/product"




    }, {




      "rel" : "productCategory",




      "href" : "http://localhost:8080/web/products/1300/productCategory"




    }, {




      "rel" : "accounts",




      "href" : "http://localhost:8080/web/products/1300/accounts"




    } ]






one can see, that all types (int, string) etc. are rendered, but the list not. </description>
			<version>2.1.4 (Dijkstra SR4)</version>
			<fixedVersion>2.3 M1 (Fowler), 2.1.5 (Dijkstra SR5), 2.2.2 (Evans SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.core.projection.ProjectingMethodInterceptor.java</file>
			<file type="M">org.springframework.data.rest.core.projection.ProjectingMethodInterceptorUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">394</link>
			<link type="Duplicate" description="is duplicated by">477</link>
		</links>
	</bug>
	<bug id="388" opendate="2014-09-26 06:05:58" fixdate="2014-12-04 10:21:32" resolution="Fixed">
		<buginformation>
			<summary>Can&amp;apos;t use controller advices if annotation based event handling is used</summary>
			<description>Spring Data REST is capturing any exceptions thrown by event handler methods and re-throwing them as IllegalStateException. By doing this, Spring Data REST makes it very hard to adopt any exception handling mechanism offered by Spring MVC (controller advices, for example) because we cannot pinpoint which exception we would like to handle in each exception handler of the controller advice (the only exception that we can handle is IllegalStateException).
The patch in the pull request corrects this behavior. If a event handler throws a unchecked exception, than it makes sure that this very exception is thrown. Otherwise (if it is a checked exception), it resorts to the old behavior, encapsulating the checked exception in a IllegalStateException. Without this patch, the controller advice shown below does not work.






@ControllerAdvice




public class ExceptionHandlingControllerAdvice {




  @ExceptionHandler(UnauthorizedException.class)




  public ResponseEntity handleUnauthorizedException(UnauthorizedException exception) {




    String stackTrace = ExceptionUtils.getStackTrace(exception);




    return new ResponseEntity(stackTrace, HttpStatus.FORBIDDEN); 




  }




}






By applying this patch, I believe Spring Data REST better fits the Spring MVC world.</description>
			<version>2.2 GA (Evans)</version>
			<fixedVersion>2.1.5 (Dijkstra SR5), 2.2.2 (Evans SR2), 2.3 RC1 (Fowler)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.core.event.AfterLinkDeleteEvent.java</file>
			<file type="M">org.springframework.data.rest.core.event.AfterLinkSaveEvent.java</file>
			<file type="D">org.springframework.data.rest.core.support.Methods.java</file>
			<file type="D">org.springframework.data.rest.core.event.LinkSaveEvent.java</file>
			<file type="M">org.springframework.data.rest.core.domain.jpa.PersonBeforeSaveHandler.java</file>
			<file type="M">org.springframework.data.rest.core.annotation.RepositoryEventHandler.java</file>
			<file type="M">org.springframework.data.rest.core.annotation.HandleBeforeLinkDelete.java</file>
			<file type="M">org.springframework.data.rest.core.context.RepositoryEventIntegrationTests.java</file>
			<file type="M">org.springframework.data.rest.core.annotation.HandleAfterLinkDelete.java</file>
			<file type="M">org.springframework.data.rest.core.annotation.HandleBeforeDelete.java</file>
			<file type="M">org.springframework.data.rest.core.annotation.HandleBeforeLinkSave.java</file>
			<file type="M">org.springframework.data.rest.core.event.BeforeLinkSaveEvent.java</file>
			<file type="M">org.springframework.data.rest.core.annotation.HandleBeforeCreate.java</file>
			<file type="D">org.springframework.data.rest.core.event.AnnotatedHandlerBeanPostProcessor.java</file>
			<file type="M">org.springframework.data.rest.core.annotation.HandleAfterCreate.java</file>
			<file type="D">org.springframework.data.rest.core.util.UUIDConverter.java</file>
			<file type="M">org.springframework.data.rest.core.annotation.HandleBeforeSave.java</file>
			<file type="M">org.springframework.data.rest.core.event.BeforeLinkDeleteEvent.java</file>
			<file type="M">org.springframework.data.rest.core.annotation.HandleAfterDelete.java</file>
			<file type="M">org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration.java</file>
			<file type="M">org.springframework.data.rest.core.annotation.HandleAfterLinkSave.java</file>
			<file type="M">org.springframework.data.rest.core.domain.jpa.AnnotatedPersonEventHandler.java</file>
			<file type="M">org.springframework.data.rest.core.annotation.HandleAfterSave.java</file>
		</fixedFiles>
	</bug>
	<bug id="423" opendate="2014-12-07 03:58:17" fixdate="2014-12-09 04:18:23" resolution="Fixed">
		<buginformation>
			<summary>Spring Data REST registered ConversionService not used when overriding individual resources</summary>
			<description>I have a business object User and in my application I have to set property active to false when deleting User.
I don&amp;amp;apos;t want to expose my business logic on REST model so I wanted to override DELETE /user/{id} behavior to patch user to set active to false.
In order to achieve that I write my own controller with following piece of code:






@RepositoryRestController




@ResponseBody




@RequestMapping("/users")




public class UserController {









    @Inject




    private UserService userService;









    @ResponseStatus(value = HttpStatus.NO_CONTENT)




    @RequestMapping(method = RequestMethod.DELETE, value = "/{user}")




    public void delete(@PathVariable("user") User user) {




        user.setActive(false);




        userService.save(user);




    }




}






Method is correctly called but I get an org.springframework.beans.ConversionNotSupportedException...
So I tried to add a custom converter (String -&amp;gt; User) like describe here: http://docs.spring.io/spring-data/rest/docs/1.1.0.M1/reference/htmlsingle/#d4e110
But the converter is never called.
When debugging I saw that https://github.com/spring-projects/spring-framework/blob/master/spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java#L169 is NULL that why my converter is not called.
I will try to find more and create PR if possible but atm I don&amp;amp;apos;t have more information.</description>
			<version>2.3 M1 (Fowler)</version>
			<fixedVersion>2.2.2 (Evans SR2), 2.3 RC1 (Fowler)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.JpaWebTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="424" opendate="2014-12-10 10:34:57" fixdate="2015-01-02 03:36:29" resolution="Fixed">
		<buginformation>
			<summary>Make sure HAL HttpMessageConverter is ordered before the standard one</summary>
			<description>RepositoryRestMvcConfiguration registers two HttpMessageConverter beans handling ResourceSupport types. One is handling the HAL media type, the other all Spring Data REST specific media types. We have to make sure that depending on the settings of config().useHalAsDefaultJsonMediaType() one is registered before the other.</description>
			<version>2.2.1 (Evans SR1)</version>
			<fixedVersion>2.2.2 (Evans SR2), 2.3 RC1 (Fowler)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration.java</file>
			<file type="M">org.springframework.data.rest.webmvc.config.RepositoryRestMvConfigurationIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="427" opendate="2014-12-25 07:58:23" fixdate="2015-01-05 07:15:47" resolution="Fixed">
		<buginformation>
			<summary>NullPointerException when POST/PUT entities with rels in DomainClassConverter</summary>
			<description>My setup is completely based on Java Configuration files. I configured my my application as follows:






@Override




	protected Class&amp;lt;?&amp;gt;[] getRootConfigClasses() {




		return new Class&amp;lt;?&amp;gt;[] { CustomMongoDBRepositoryConfig.class, CustomJPARepositoryConfig.class, CustomSecurityConfiguration.class };




	}




..









@Override




	public void onStartup(ServletContext servletContext) throws ServletException {		




        AnnotationConfigWebApplicationContext webCtx = new AnnotationConfigWebApplicationContext();




        webCtx.register(CustomRepositoryRestMvcConfiguration.class);




     




        DispatcherServlet dispatcherServlet = new DispatcherServlet(webCtx);




        ServletRegistration.Dynamic appServlet = servletContext.addServlet("exporter", dispatcherServlet);




        appServlet.setAsyncSupported(true);




        appServlet.setLoadOnStartup(1);




        appServlet.addMapping("/*");




        




        FilterRegistration.Dynamic corsFilter = servletContext.addFilter("corsFilter", CORSFilter.class);




        corsFilter.addMappingForUrlPatterns(null, false, "/*");




        




        FilterRegistration.Dynamic filter = servletContext.addFilter("openSessionInViewFilter", OpenEntityManagerInViewFilter.class);




        filter.setInitParameter("singleSession", "true");




        filter.addMappingForServletNames(null, true, "exporter");




        




        FilterRegistration.Dynamic securityFilter = servletContext.addFilter("springSecurityFilterChain", 




        		new DelegatingFilterProxy("springSecurityFilterChain"));




        securityFilter.addMappingForUrlPatterns(null, false, "/*");




        




        




	    super.onStartup(servletContext);




	}






The interesting thing is, everything is working fine. MVC URLs are mapped, controllers are working, Spring Security is working, SD REST URLs are mapped and working, but one thing is not working:
POST/PUT of entities with rels. Having the following payload posted to /roles 






{




  "name": "Developer",




  "description": "Standard role for a agent developer in the system",




  "rights": [




    "http://localhost:8080/web/rights/186",




    "http://localhost:8080/web/rights/189",




    "http://localhost:8080/web/rights/185",




    "http://localhost:8080/web/rights/46"




  ]




}






leads to the following exception:






LOGBACK:16:54:09.765 [tomcat-http--2] ERROR o.s.d.r.w.RepositoryRestExceptionHandler - Could not read JSON: (was java.lang.NullPointerException) (through reference chain: de.cloudscale.model.user.Role["rights"]); nested exception is com.fasterxml.jackson.databind.JsonMappingException: (was java.lang.NullPointerException) (through reference chain: de.cloudscale.model.user.Role["rights"])




org.springframework.http.converter.HttpMessageNotReadableException: Could not read JSON: (was java.lang.NullPointerException) (through reference chain: de.cloudscale.model.user.Role["rights"]); nested exception is com.fasterxml.jackson.databind.JsonMappingException: (was java.lang.NullPointerException) (through reference chain: de.cloudscale.model.user.Role["rights"])




	at org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter.readJavaType(AbstractJackson2HttpMessageConverter.java:208) ~[AbstractJackson2HttpMessageConverter.class:4.1.1.RELEASE]




	at org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter.readInternal(AbstractJackson2HttpMessageConverter.java:192) ~[AbstractJackson2HttpMessageConverter.class:4.1.1.RELEASE]




	at org.springframework.http.converter.AbstractHttpMessageConverter.read(AbstractHttpMessageConverter.java:159) ~[AbstractHttpMessageConverter.class:4.1.1.RELEASE]




	at org.springframework.data.rest.webmvc.config.PersistentEntityResourceHandlerMethodArgumentResolver.read(PersistentEntityResourceHandlerMethodArgumentResolver.java:185) ~[PersistentEntityResourceHandlerMethodArgumentResolver.class:na]




	at org.springframework.data.rest.webmvc.config.PersistentEntityResourceHandlerMethodArgumentResolver.read(PersistentEntityResourceHandlerMethodArgumentResolver.java:168) ~[PersistentEntityResourceHandlerMethodArgumentResolver.class:na]




	at org.springframework.data.rest.webmvc.config.PersistentEntityResourceHandlerMethodArgumentResolver.resolveArgument(PersistentEntityResourceHandlerMethodArgumentResolver.java:123) ~[PersistentEntityResourceHandlerMethodArgumentResolver.class:na]




	at org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:77) ~[HandlerMethodArgumentResolverComposite.class:4.1.1.RELEASE]






Which in turn is a result of fact that in DomainClassConverter the variable repositories is empty during the POST/PUT call. Following that the RepositoryInformations are empty and the NPE is thrown. 
I guess this is happening due to some context splitup during startup time. The interesting thing is, that POST/PUT a plain object without any rels works properly, I am not able to see any stuff in the debug logs showing me the second context</description>
			<version>2.2.1 (Evans SR1)</version>
			<fixedVersion>2.2.2 (Evans SR2), 2.3 RC1 (Fowler)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration.java</file>
			<file type="M">org.springframework.data.rest.core.UriToEntityConverter.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.RepositoryTestsConfig.java</file>
			<file type="M">org.springframework.data.rest.core.RepositoryTestsConfig.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryRestExceptionHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="434" opendate="2015-01-08 01:52:12" fixdate="2015-01-11 11:05:22" resolution="Fixed">
		<buginformation>
			<summary>PersistentEntityResourceHandlerMethodArgumentResolver&amp;apos;s read() methods swallow exceptions</summary>
			<description></description>
			<version>2.2.1 (Evans SR1)</version>
			<fixedVersion>2.2.2 (Evans SR2), 2.3 RC1 (Fowler)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.config.PersistentEntityResourceHandlerMethodArgumentResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="445" opendate="2015-01-16 03:13:42" fixdate="2015-01-16 04:10:30" resolution="Fixed">
		<buginformation>
			<summary>RepositoryCollectionResourceMapping does not obtain domain type from RepositoryMetadata</summary>
			<description>RepositoryCollectionResourceMapping is manually looking up generic types to determine the domain type handled but actually it can just use the RepositoryMetadata handed into the constructor.</description>
			<version>2.1.4 (Dijkstra SR4)</version>
			<fixedVersion>2.1.5 (Dijkstra SR5), 2.2.2 (Evans SR2), 2.3 RC1 (Fowler)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.core.mapping.RepositoryCollectionResourceMapping.java</file>
			<file type="M">org.springframework.data.rest.core.mapping.RepositoryCollectionResourceMappingUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="448" opendate="2015-01-16 05:31:07" fixdate="2015-01-16 07:38:22" resolution="Fixed">
		<buginformation>
			<summary>RepositoryRestHandlerMapping is handling non-repository requests</summary>
			<description>The fix for DATAREST-429 has introduced a regression of RepositoryRestHandlerMapping not verifying the repositoryLookupPath actually pointing to a repository in the first place.</description>
			<version>2.3 M1 (Fowler)</version>
			<fixedVersion>2.3 RC1 (Fowler)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryRestHandlerMappingUnitTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryRestHandlerMapping.java</file>
			<file type="M">org.springframework.data.rest.webmvc.CommonWebTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="446" opendate="2015-01-16 04:13:07" fixdate="2015-01-20 03:58:26" resolution="Fixed">
		<buginformation>
			<summary>Remove usage of RepositoriesUtils as it potentially breaks customizations of ResourceMetadata</summary>
			<description>Using RepositoriesUtils to determine the managed domain type from a repository interface potentially subverts customizations made for RepositoryMetadata. We should remove its usage entirely.</description>
			<version>2.1.4 (Dijkstra SR4)</version>
			<fixedVersion>2.1.5 (Dijkstra SR5), 2.2.2 (Evans SR2), 2.3 RC1 (Fowler)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.core.mapping.RepositoryCollectionResourceMapping.java</file>
			<file type="M">org.springframework.data.rest.core.mapping.RepositoryAwareResourceInformation.java</file>
			<file type="D">org.springframework.data.rest.core.support.RepositoriesUtils.java</file>
			<file type="M">org.springframework.data.rest.core.mapping.RepositoryResourceMappings.java</file>
		</fixedFiles>
	</bug>
	<bug id="461" opendate="2015-01-21 04:57:40" fixdate="2015-01-21 05:54:32" resolution="Fixed">
		<buginformation>
			<summary>@JsonIgnored properties must not be updated in PUT requests</summary>
			<description>When issuing PUT requests for existing entities properties that are not mapped (e.g. using @JsonIgnore) must not be nulled out.</description>
			<version>2.2.1 (Evans SR1)</version>
			<fixedVersion>2.2.2 (Evans SR2), 2.3 RC1 (Fowler)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.config.PersistentEntityResourceHandlerMethodArgumentResolver.java</file>
			<file type="M">org.springframework.data.rest.webmvc.config.JsonPatchHandler.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.DomainObjectReader.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">491</link>
		</links>
	</bug>
	<bug id="460" opendate="2015-01-20 01:38:04" fixdate="2015-01-26 03:20:31" resolution="Fixed">
		<buginformation>
			<summary>Make sure @Bean methods of RepositoryRestMvcConfiguration are called from proxied methods</summary>
			<description>Some methods in RepositoryRestMvcConfiguration are private but call @Bean annotated methods in turn. These method calls will not get intercepted correctly as private methods are not intercepted by the CGLib generated subtype of the configuration class. That means that @Bean methods called from the private methods will not be routed through the interceptor and thus Spring&amp;amp;apos;s bean management (scopes, invocation of callbacks) will not be applied.</description>
			<version>2.1.4 (Dijkstra SR4)</version>
			<fixedVersion>2.1.5 (Dijkstra SR5), 2.2.2 (Evans SR2), 2.3 RC1 (Fowler)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="244" opendate="2014-02-07 15:57:41" fixdate="2015-02-06 00:22:42" resolution="Duplicate">
		<buginformation>
			<summary>SDR Schema follows json-schema?</summary>
			<description>The schema (/schema) output of SDR follows the specification (http://json-schema.org/documentation.html )? If so what version?</description>
			<version>2.1 RC1 (Dijkstra)</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.core.domain.jpa.Person.java</file>
			<file type="M">org.springframework.data.rest.webmvc.mongodb.Address.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.Book.java</file>
			<file type="M">org.springframework.data.rest.webmvc.mongodb.Profile.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.Author.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityToJsonSchemaConverterUnitTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositorySchemaController.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityToJsonSchemaConverter.java</file>
			<file type="M">org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration.java</file>
			<file type="M">org.springframework.data.rest.webmvc.mongodb.User.java</file>
			<file type="M">org.springframework.data.rest.core.config.MetadataConfiguration.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.JacksonMetadata.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.JsonSchema.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">354</link>
		</links>
	</bug>
	<bug id="477" opendate="2015-02-16 02:11:56" fixdate="2015-02-16 03:44:53" resolution="Duplicate">
		<buginformation>
			<summary>VenueProjection with List&lt;ContactProjection&gt; returns List&lt;Contact&gt; instead</summary>
			<description>I have 2 entities that are exposed by Spring Data REST: Venue and Contact. A Venue can have multiple Contacts.
I create this projections:






VenueDetails.java






@Projection(name="details", types = Venue.class)




public interface VenueDetails {




    int getId();




    String getName();




	//...




    List&amp;lt;ContactDetails&amp;gt; getContacts();




}












ContactDetails.java






@Projection(name="details", types = Contact.class)




public interface ContactDetails {




    int getId();




    String getContact();




    ContactType getContact_type();




}






When the client invokes http://localhost:8080/myrestservice/rest/venues/2?projection=details gets:






{




  "id" : 2,




  "name" : "A place in the desert",




  "contacts" : [ {




    "id" : 1,




    "contact" : "555 768547",




  }, {




    "id" : 2,




    "contact" : "contacts@example.org",




  }],




  "_links" : {




    "self" : {




      "href" : "http://localhost:8080/myrestservice/rest/venues/2{?projection}",




      "templated" : true




    },




    "contacts" : {




      "href" : "http://localhost:8080/myrestservice/rest/venues/2/contacts"




    }




  }




}






You see that every contact misses "contact_type".
But "contact_type" is shown when invoking http://localhost:8080/myrestservice/rest/contacts/1?projection=details:






{




  "id" : 1,




  "contact" : "555 768547",




  "contact_type" : {




    "code" : "T",




    "name" : "Telephone"




  },




  "_links" : {




    "self" : {




      "href" : "http://localhost:8080/myrestservice/rest/contacts/1{?projection}",




      "templated" : true




    },




    "contact_type" : {




      "href" : "http://localhost:8080/myrestservice/rest/contacts/1/contact_type"




    },




    "venue" : {




      "href" : "http://localhost:8080/myrestservice/rest/contacts/1/venue"




    }




  }




}






So it seems that expressing List&amp;lt;AProjectionOfALinkedObject&amp;gt; in a projection, ignores AProjectionOfALinkedObject and simply uses ALinkedObject.</description>
			<version>2.2.1 (Evans SR1)</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.core.projection.ProjectingMethodInterceptor.java</file>
			<file type="M">org.springframework.data.rest.core.projection.ProjectingMethodInterceptorUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">408</link>
		</links>
	</bug>
	<bug id="485" opendate="2015-03-03 00:30:02" fixdate="2015-03-03 00:53:11" resolution="Fixed">
		<buginformation>
			<summary>RepositoryPropertyReferenceController.createPropertyReference() does not work for empty content supplied on Spring 4.1</summary>
			<description>Spring 4.1&amp;amp;apos;s RequestResponseBodyMethodProcessor rejects a request with an empty payload if a parameter annotated with @RequestBody is not configured to required = true. Even in this case it forcibly returns null so that a HandlerMethodArgumentResolver that could even deal with an empty payload is not even invoked.
We need to switch to required = false to not run into the rejection and manually default the Resources&amp;lt;Object&amp;gt; in case it&amp;amp;apos;s null</description>
			<version>2.2.2 (Evans SR2)</version>
			<fixedVersion>2.3 RC1 (Fowler), 2.2.3 (Evans SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryPropertyReferenceController.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">499</link>
			<link type="Relate" description="relates to">12778</link>
		</links>
	</bug>
	<bug id="354" opendate="2014-07-15 00:16:34" fixdate="2015-03-05 01:14:29" resolution="Fixed">
		<buginformation>
			<summary>Revamp JSON Schema support to current draft of the spec</summary>
			<description>Similarly to the support for ALPS we added in Evans M1, we should expose API meta-data in JSON Schema and JSON Hyper-Schema format.
[0] http://json-schema.org</description>
			<version>2.1 RC1 (Dijkstra)</version>
			<fixedVersion>2.3 RC1 (Fowler)</fixedVersion>
			<type>New Feature</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.core.domain.jpa.Person.java</file>
			<file type="M">org.springframework.data.rest.webmvc.mongodb.Address.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.Book.java</file>
			<file type="M">org.springframework.data.rest.webmvc.mongodb.Profile.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.Author.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityToJsonSchemaConverterUnitTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositorySchemaController.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityToJsonSchemaConverter.java</file>
			<file type="M">org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration.java</file>
			<file type="M">org.springframework.data.rest.webmvc.mongodb.User.java</file>
			<file type="M">org.springframework.data.rest.core.config.MetadataConfiguration.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.JacksonMetadata.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.JsonSchema.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">244</link>
			<link type="Relate" description="relates to">486</link>
			<link type="Relate" description="is related to">399</link>
			<link type="Relate" description="is related to">194</link>
			<link type="Relate" description="is related to">208</link>
		</links>
	</bug>
	<bug id="490" opendate="2015-03-11 04:38:42" fixdate="2015-03-11 07:39:03" resolution="Fixed">
		<buginformation>
			<summary>Repository controllers not invoked if resource is handled manually in dedicated media type</summary>
			<description>I have a Spring Data REST project. For some URLs I want to create a @Controller that renders the resources as HTML. I am using a @RequestMapping with produces = MediaType.TEXT_HTML_VALUE. In fact this controller is called if the URL is requested. However, if I do a request for JSON I get a 406 - while in fact the Spring Data REST controller should be called. I noticed that the log output says that the Spring Data REST controller doesn&amp;amp;apos;t register with any value for produces.
I think a value for produces should be given. Maybe there is a way to do this but I didn&amp;amp;apos;t find it in the reference documentation. Maybe there are other ways to get different representations of the REST resources but that doesn&amp;amp;apos;t seem to be documented either. I guess different representations for the same resource are an important part of REST so I think there should be a way to do what I want to do.</description>
			<version>2.2.2 (Evans SR2)</version>
			<fixedVersion>2.3 GA (Fowler)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryRestHandlerMapping.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.JpaRepositoryConfig.java</file>
			<file type="M">org.springframework.data.rest.webmvc.BasePathAwareHandlerMapping.java</file>
			<file type="M">org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">522</link>
		</links>
	</bug>
	<bug id="491" opendate="2015-03-11 07:07:06" fixdate="2015-03-20 02:00:16" resolution="Fixed">
		<buginformation>
			<summary>PersistentEntityResourceHandlerMethodArgumentResolver dump in PUT requests with HashMap</summary>
			<description>When updating a existing resource with a JSON PUT with this sample code











@Document




public class Ticket {









	@Id




	private String id;









	@Version




	private Long version;









	private String type;









	private Map&amp;lt;String, String&amp;gt; texts;




}






and JSON






{




  "version" : 1,




  "type" : "HR",




  "texts" : {




    "description" : "Let&amp;amp;apos;s test1234"




  }




}






I get the following stack trace:






 




2015-03-11 14:34:08.049 ERROR 39988 --- [nio-8080-exec-2] s.d.r.w.AbstractRepositoryRestController : Could not read an object of type class demo.Ticket from the request!; nested exception is org.springframework.http.converter.HttpMessageNotReadableException: Could not read payload!; nested exception is java.lang.NullPointerException









org.springframework.http.converter.HttpMessageNotReadableException: Could not read an object of type class demo.Ticket from the request!; nested exception is org.springframework.http.converter.HttpMessageNotReadableException: Could not read payload!; nested exception is java.lang.NullPointerException




	at org.springframework.data.rest.webmvc.config.PersistentEntityResourceHandlerMethodArgumentResolver.readPutForUpdate(PersistentEntityResourceHandlerMethodArgumentResolver.java:197)




	at org.springframework.data.rest.webmvc.config.PersistentEntityResourceHandlerMethodArgumentResolver.read(PersistentEntityResourceHandlerMethodArgumentResolver.java:169)




	at org.springframework.data.rest.webmvc.config.PersistentEntityResourceHandlerMethodArgumentResolver.resolveArgument(PersistentEntityResourceHandlerMethodArgumentResolver.java:125)




	at org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:77)




	at org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:162)




	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:129)




	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:110)




	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandleMethod(RequestMappingHandlerAdapter.java:777)




	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:706)




	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85)




	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:943)




	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:877)




	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:966)




	at org.springframework.web.servlet.FrameworkServlet.doPut(FrameworkServlet.java:879)




	at javax.servlet.http.HttpServlet.service(HttpServlet.java:647)




	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:842)




	at javax.servlet.http.HttpServlet.service(HttpServlet.java:725)




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:291)




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)




	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)




	at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:77)




	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)




	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:88)




	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)




	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:219)




	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:106)




	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:501)




	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:142)




	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:79)




	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:88)




	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:516)




	at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1086)




	at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:659)




	at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.process(Http11NioProtocol.java:223)




	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1558)




	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1515)




	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)




	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)




	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)




	at java.lang.Thread.run(Thread.java:745)




Caused by: org.springframework.http.converter.HttpMessageNotReadableException: Could not read payload!; nested exception is java.lang.NullPointerException




	at org.springframework.data.rest.webmvc.json.DomainObjectReader.merge(DomainObjectReader.java:137)




	at org.springframework.data.rest.webmvc.json.DomainObjectReader.readPut(DomainObjectReader.java:129)




	at org.springframework.data.rest.webmvc.config.JsonPatchHandler.applyPut(JsonPatchHandler.java:133)




	at org.springframework.data.rest.webmvc.config.PersistentEntityResourceHandlerMethodArgumentResolver.readPutForUpdate(PersistentEntityResourceHandlerMethodArgumentResolver.java:194)




	... 45 common frames omitted




Caused by: java.lang.NullPointerException: null




	at org.springframework.data.rest.webmvc.json.DomainObjectReader.getJacksonProperties(DomainObjectReader.java:204)




	at org.springframework.data.rest.webmvc.json.DomainObjectReader.doMerge(DomainObjectReader.java:157)




	at org.springframework.data.rest.webmvc.json.DomainObjectReader.doMerge(DomainObjectReader.java:185)




	at org.springframework.data.rest.webmvc.json.DomainObjectReader.merge(DomainObjectReader.java:135)




	... 48 common frames omitted






The reason seems to be that in DomainObjectReader the PersistentEntity for a HashMap is null.






public class DomainObjectReader {




	public &amp;lt;T&amp;gt; T readPut(final ObjectNode source, T target, final ObjectMapper mapper) {









		Assert.notNull(source, "ObjectNode must not be null!");




		Assert.notNull(target, "Existing object instance must not be null!");




		Assert.notNull(mapper, "ObjectMapper must not be null!");









		final PersistentEntity&amp;lt;?, ?&amp;gt; entity = entities.getPersistentEntity(target.getClass());






This works before DATAREST-461 was included. 
You can find a example, to reproduce here https://github.com/sebastian-sch/mongo_data_rest</description>
			<version>2.2.2 (Evans SR2)</version>
			<fixedVersion>2.3 GA (Fowler), 2.2.3 (Evans SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.mongodb.Profile.java</file>
			<file type="M">org.springframework.data.rest.webmvc.mongodb.MongoWebTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.DomainObjectReader.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">461</link>
		</links>
	</bug>
	<bug id="492" opendate="2015-03-22 12:04:42" fixdate="2015-03-23 00:59:01" resolution="Fixed">
		<buginformation>
			<summary>JSON Schema reports primitive numbers as object</summary>
			<description>A type like this:

{class:java}
class Sample {

  double foo;
}{class}

yields a JSON Schema document of:






{




  "foo" : {




    "type" : "object"




  }




}





</description>
			<version>2.3 RC1 (Fowler)</version>
			<fixedVersion>2.3 GA (Fowler)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.json.JsonSchema.java</file>
		</fixedFiles>
	</bug>
	<bug id="498" opendate="2015-03-28 21:49:16" fixdate="2015-03-30 01:47:41" resolution="Fixed">
		<buginformation>
			<summary>JSON Patch request not recognized if Content-Type header contains media type parameters</summary>
			<description>A request isn&amp;amp;apos;t properly recognized as a JSON Patch one, resulting in exception (as detailed in StackOverflow URL).
Issue appears to be that PersistentEntityResourceHandlerMethodArgumentResolver builds an IncomingRequest, and that constructor sets its contentType to application/json-patch+json;charset=UTF-8. This then fails the IncomingRequest&amp;amp;apos;s isJsonPatchRequest() test because the inbound otherType now has a parameters map entry (charset -&amp;gt; UTF-8) and the  RestMediaTypes.JSON_PATCH_JSON does not. </description>
			<version>2.3 GA (Fowler)</version>
			<fixedVersion>2.4 M1 (Gosling), 2.3.1 (Fowler SR1), 2.2.3 (Evans SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.springframework.data.rest.webmvc.AugmentingHandlerMappingUnitTest.java</file>
			<file type="M">org.springframework.data.rest.webmvc.IncomingRequest.java</file>
		</fixedFiles>
	</bug>
	<bug id="500" opendate="2015-03-30 05:59:33" fixdate="2015-03-30 12:34:36" resolution="Fixed">
		<buginformation>
			<summary>Rendering of lazy-loading proxies fails</summary>
			<description>Problem is that the nested lazy loading proxy is not unpacked correctly, see the linked example project for further details.
The code in 





org.springframework.data.rest.webmvc.RepositoryPropertyReferenceController.doWithReferencedProperty(RootResourceInformation, Serializable, String, Function&amp;lt;ReferencedProperty, ResourceSupport&amp;gt;, HttpMethod)




PersistentEntity&amp;lt;?, ?&amp;gt; persistentEntity = repoRequest.getPersistentEntity();




PersistentProperty&amp;lt;?&amp;gt; prop = persistentEntity.getPersistentProperty(propertyPath);




...




PersistentPropertyAccessor accessor = persistentEntity.getPropertyAccessor(domainObj);




Object propVal = accessor.getProperty(prop);






traverses the product property of the Category which returns the proxied version of the product instance. This instance cannot be serialized. We have to find a way to unwrap that proxy (probably still in JPA) or make it somehow serializable (in a way that works for other proxy mechanisms too...)
The test case: shouldBeAbleToResolveLazyLoadingProxyForProductInCategory demonstrates the problem.</description>
			<version>2.3 GA (Fowler)</version>
			<fixedVersion>2.4 M1 (Gosling), 2.3.1 (Fowler SR1), 2.2.3 (Evans SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.json.Jackson2DatatypeHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="502" opendate="2015-04-02 05:44:30" fixdate="2015-04-07 08:04:35" resolution="Fixed">
		<buginformation>
			<summary>Not convenient to search a repository by a related entity using links</summary>
			<description>It doesn&amp;amp;apos;t seem to be very convenient to search a repository using an related entity as a query parameter. Consider the following repository:






@RepositoryRestResource




public interface TagRepository extends PagingAndSortingRepository&amp;lt;Tag, Long&amp;gt; {









    Page&amp;lt;Tag&amp;gt; findAllByNameContainingIgnoreCaseAndOrganisationOrderByNameAsc(@Param("name") String name,




                                                                             @Param("organisation") Organisation organisation,




                                                                             Pageable pageable);




}






Organisations have many tags, a tag has one organisation. The HATEOAS semantics return entity relationships as links, however we cannot pass one of these links as the "organisation" query parameter above.
As far as I can tell, the only way to pass an organisation parameter is by using the ID (primary key) of the entity directly. This is quite inconvenient as it means we need to resolve links on the client first in order to determine the ID we need and also means that we need to expose the IDs in our DTOs (which is not default and seems like a bad idea), or attempt to parse it from the URI link.
This is how I would expect it to be able to work:
http://localhost:8080/api/tags/search/findAllByNameContainingIgnoreCaseAndOrganisationOrderByNameAsc?name=tagName&amp;amp;organisation=http://localhost:8080/api/organisations/1
However we are currently required to use it like this:
http://localhost:8080/api/tags/search/findAllByNameContainingIgnoreCaseAndOrganisationOrderByNameAsc?name=tagName&amp;amp;organisation=1
Is this the only way to query using a related entity?</description>
			<version>2.2.2 (Evans SR2)</version>
			<fixedVersion>2.4 M1 (Gosling)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.alps.AlpsControllerIntegrationTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositorySearchController.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityToJsonSchemaConverterUnitTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositorySearchControllerIntegrationTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration.java</file>
			<file type="M">org.springframework.data.rest.core.UriToEntityConverter.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.BookRepository.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="depends on">678</link>
			<link type="Duplicate" description="is duplicated by">599</link>
		</links>
	</bug>
	<bug id="507" opendate="2015-04-08 08:02:14" fixdate="2015-04-08 09:02:11" resolution="Fixed">
		<buginformation>
			<summary>RepositoryRestExceptionHandler throws IllegalArgumentException</summary>
			<description>The RepositoryRestExceptionHandler throws an IllegalArgumentException if a DataIntegrityViolationException or OptimisticLockingFailureException occurs causing a wrong server response: 500 Internal ServerError.
Have a look at the handleConflict() Method. The errorResponse() method get&amp;amp;apos;s accidentally called with a null argument for the HttpHeaders.</description>
			<version>2.3 GA (Fowler)</version>
			<fixedVersion>2.4 M1 (Gosling), 2.3.1 (Fowler SR1)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryRestExceptionHandlerUnitTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryRestExceptionHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="519" opendate="2015-04-14 13:00:51" fixdate="2015-04-14 13:24:55" resolution="Fixed">
		<buginformation>
			<summary>RepositoryEntityLinks does not populate search resource URIs with Pageable and Sorts</summary>
			<description></description>
			<version>2.3 GA (Fowler)</version>
			<fixedVersion>2.4 M1 (Gosling), 2.3.1 (Fowler SR1)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.support.RepositoryEntityLinksIntegrationTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.support.RepositoryEntityLinks.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">668</link>
			<link type="Relate" description="is related to">467</link>
		</links>
	</bug>
	<bug id="522" opendate="2015-04-16 06:48:14" fixdate="2015-05-07 05:36:27" resolution="Fixed">
		<buginformation>
			<summary>GET on RestRepository not possible, if a RestController for the same path is available</summary>
			<description>We have a Spring Data REST project, with several @RepositoryRestResource annotated Spring Data Repositories.
Example: 






PersonRepository.java






@RepositoryRestResource(path = "person")




public interface PersonRepository extends PagingAndSortingRepository&amp;lt;Person, Integer&amp;gt; {}






We want to override the POST/PATCH method of one of these repositories. So we annotate a RestController with @RestController and the annotation @RequestMapping has the same path as the repository.
Example: 






PersonController.java






@RestController




@RequestMapping("person")




public class PersonController{









	@RequestMapping(method = RequestMethod.POST, produces = MediaType.APPLICATION_JSON_VALUE)




	public ResponseEntity&amp;lt;Boolean&amp;gt; savePerson(@RequestBody Person person) {




...




}






The POST/PATCH works fine. But now a GET to /person (to receive all Persons) throws an HttpRequestMethodNotSupportedException and says: Request method &amp;amp;apos;GET&amp;amp;apos; not supported.
A GET to /person/1 instead is working just fine. 
We had a look at https://jira.spring.io/browse/DATAREST-490 and the @BasePathAwareController, but this doesnt seem to change anything.</description>
			<version>2.3 GA (Fowler)</version>
			<fixedVersion>2.4 M1 (Gosling), 2.3.1 (Fowler SR1)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.support.DelegatingHandlerMappingUnitTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.support.DelegatingHandlerMapping.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">490</link>
		</links>
	</bug>
	<bug id="537" opendate="2015-05-08 17:26:36" fixdate="2015-05-09 08:00:51" resolution="Fixed">
		<buginformation>
			<summary>Cannot remove an element of an array using JSON Patch request</summary>
			<description>The ||JsonPatchHandler}} applies a customization to remove operations. Instead of removing the node, it replace it with a null object. It works well for objects, but it doesn&amp;amp;apos;t for elements of an array. The element won&amp;amp;apos;t be removed from the array, instead it will be replaced with a null object.
I think if the path of the remove operation defines an element of an array, the original remove operation should be used instead of the customized ReplaceOperation.</description>
			<version>2.2.2 (Evans SR2)</version>
			<fixedVersion>2.4 M1 (Gosling), 2.3.1 (Fowler SR1), 2.2.3 (Evans SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.config.JsonPatchHandlerUnitTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.config.JsonPatchHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="514" opendate="2015-04-09 23:43:29" fixdate="2015-05-19 07:30:07" resolution="Fixed">
		<buginformation>
			<summary>Custom @RestResource path shows up as link href, but doesn&amp;apos;t load data</summary>
			<description>SDR 2.3.0 Fowler.
I have Service and ServiceInstance entities. The relationship is many-one.
On the Service side I have the following:






    @OneToMany(mappedBy = "service", cascade = CascadeType.ALL, orphanRemoval = true)




    @RestResource(rel = "service-instances", path = "service-instances")




    private List&amp;lt;ServiceInstance&amp;gt; serviceInstances = new ArrayList&amp;lt;&amp;gt;();






On the ServiceInstance side I have






@ManyToOne




@JoinColumn(name = "service_id")




@RestResource(rel = "s:service", path = "service")




private Service service;






though I don&amp;amp;apos;t think that matters.
When I get a single Service resource, the links are what I expect:






    GET http://localhost:8080/api/services/17




    




    {




      "key" : "upp",




      "_links" : {




        "self" : {




          "href" : "http://localhost:8080/api/services/17{?projection}",




          "templated" : true




        },




        "s:service-instances" : {




          "href" : "http://localhost:8080/api/services/17/service-instances"




        },




        ...




    }






But when I try to load the s:service-instances resource at http://localhost:8080/api/services/17/service-instances, I get a 404.
If I go to http://localhost:8080/api/services/17/serviceInstances, I can see the data.
So @RestResource(path) appears to control the link href, but not the actual route to the data.</description>
			<version>2.3 GA (Fowler)</version>
			<fixedVersion>2.4 M1 (Gosling)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.support.RepositoryLinkBuildUnitTests.java</file>
			<file type="M">org.springframework.data.rest.core.mapping.ResourceMetadata.java</file>
			<file type="M">org.springframework.data.rest.core.mapping.ResourceMappings.java</file>
			<file type="D">org.springframework.data.rest.core.mapping.ResourceMappingsIntegrationTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.AbstractControllerIntegrationTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.support.RepositoryEntityLinks.java</file>
			<file type="M">org.springframework.data.rest.core.mapping.MappingResourceMetadata.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.JpaWebTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.mapping.AssociationLinks.java</file>
			<file type="D">org.springframework.data.rest.webmvc.mapping.PropertyMappings.java</file>
			<file type="M">org.springframework.data.rest.webmvc.alps.RootResourceInformationToAlpsDescriptorConverter.java</file>
			<file type="M">org.springframework.data.rest.webmvc.support.PersistentEntityProjector.java</file>
			<file type="M">org.springframework.data.rest.core.support.RepositoryRelProvider.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryController.java</file>
			<file type="M">org.springframework.data.rest.webmvc.config.ResourceMetadataHandlerMethodArgumentResolver.java</file>
			<file type="M">org.springframework.data.rest.webmvc.AssociationLinksUnitTests.java</file>
			<file type="D">org.springframework.data.rest.core.mapping.RepositoryAwareResourceInformation.java</file>
			<file type="M">org.springframework.data.rest.webmvc.alps.AlpsController.java</file>
			<file type="M">org.springframework.data.rest.webmvc.support.RepositoryLinkBuilder.java</file>
			<file type="M">org.springframework.data.rest.core.mapping.PersistentPropertyResourceMappingUnitTests.java</file>
			<file type="M">org.springframework.data.rest.core.mapping.RepositoryResourceMappings.java</file>
			<file type="M">org.springframework.data.rest.core.domain.jpa.Person.java</file>
			<file type="M">org.springframework.data.rest.webmvc.PersistentEntityResourceAssembler.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.Book.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityToJsonSchemaConverter.java</file>
			<file type="M">org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.RepositoryTestsConfig.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositorySearchController.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryPropertyReferenceController.java</file>
		</fixedFiles>
	</bug>
	<bug id="523" opendate="2015-04-20 01:08:19" fixdate="2015-05-19 07:34:57" resolution="Fixed">
		<buginformation>
			<summary>Unable to augment collection association using POST</summary>
			<description>It seems that POSTing an item to an associated collection does not work as documented.
According to the Spring Data REST documentation, POST method is supported for collections, so 






curl -i -X POST -H &amp;amp;apos;Content-type: text/uri-list&amp;amp;apos; -d &amp;amp;apos;http://localhost:8080/artifacts/1&amp;amp;apos; http://localhost:8080/collectors/1/artifacts






should add an artifact to the (yet empty) collection. Unfortunately, it does not:






    HTTP/1.1 405 Method Not Allowed




    Server: Apache-Coyote/1.1




    Allow: GET, DELETE, PATCH, PUT




    Content-Type: application/json;charset=UTF-8




    Transfer-Encoding: chunked




    Date: Fri, 17 Apr 2015 22:54:59 GMT




    




    {"timestamp":1429311299117,"status":405,"error":"Method Not Allowed","exception":"org.springframework.web.HttpRequestMethodNotSupportedException","message":"Request method &amp;amp;apos;POST&amp;amp;apos; not supported","path":"/collectors/1/artifacts"}






My entities:






    @Data




    @Entity




    public class Collector {




        @Id




        @GeneratedValue




        private Long id;




    




        private String name;




    




        @OneToMany(mappedBy = "owner")




        private List&amp;lt;Artifact&amp;gt; artifacts;




    }




    




    @Data




    @Entity




    @Accessors(chain = true, fluent = true)




    public class Artifact {




    




        @Id




        @GeneratedValue




        private Long id;




    




        private String title;




    




        @ManyToOne




        @JoinColumn(name = "collector_id")




        private Collector owner;




    }






The complete code is on Github.</description>
			<version>2.2.2 (Evans SR2)</version>
			<fixedVersion>2.4 M1 (Gosling), 2.3.1 (Fowler SR1)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.RestMediaTypes.java</file>
			<file type="M">org.springframework.data.rest.core.mapping.CrudMethodsSupportedHttpMethodsUnitTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RootResourceInformation.java</file>
			<file type="M">org.springframework.data.rest.core.mapping.CrudMethodsSupportedHttpMethods.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RootResourceInformationIntegrationTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryPropertyReferenceController.java</file>
			<file type="M">org.springframework.data.rest.core.mapping.SupportedHttpMethods.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.JpaWebTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="556" opendate="2015-05-26 07:33:21" fixdate="2015-05-26 09:57:45" resolution="Fixed">
		<buginformation>
			<summary>PUT/PATCH does not consider custom Jackson field naming strategy</summary>
			<description>1. git clone https://github.com/spring-guides/gs-accessing-data-rest.git
2. use spring.jackson.property-naming-strategy=PASCAL_CASE_TO_CAMEL_CASE
3. PUT/PATCH fails.
org.springframework.data.rest.webmvc.json.DomainObjectReader:170 will remove valid property names required by the objectMapper later on. 
If one posts camelCase properties instead, the objectMapper will ignore them.
Possible fix is to simply not remove properties so eagerly (Line 170) and let the objectMapper decide.
</description>
			<version>2.2.2 (Evans SR2)</version>
			<fixedVersion>2.4 M1 (Gosling), 2.3.1 (Fowler SR1), 2.2.3 (Evans SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.json.DomainObjectReaderUnitTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.DomainObjectReader.java</file>
		</fixedFiles>
	</bug>
	<bug id="582" opendate="2015-06-17 11:23:52" fixdate="2015-07-06 04:01:47" resolution="Fixed">
		<buginformation>
			<summary>Secured event handler method invoked twice</summary>
			<description>If I annotate my event handler methods with a Pre/Post annotation, it is added to the handlerMethods() twice, and as a consequence invoked twice.
I suppose this is not the intended behavior. 






@Slf4j




@RepositoryEventHandler(User.class)




public class UserEventHandler {









    @HandleBeforeCreate




    @PreAuthorize("hasRole(&amp;amp;apos;ROLE_ADMIN&amp;amp;apos;))




    public void handleNewUser(User newUser) {




        log.debug("Handle user {}", newUser);




       // processing here




    }




}






The two handlers in the map (package names removed) are






EventHandlerMethod{ 




    targetType=class User, 




    method=public final void  UserEventHandler$$EnhancerBySpringCGLIB$$a9872696.handleNewUser(User), 




    handler=UserEventHandler@77e9dca8 




}






and






EventHandlerMethod{ 




    targetType=class User, 




    method=public void UserEventHandler.handleNewUser(User), 




    handler=UserEventHandler@77e9dca8 




}






The EnhancerBySpringCGLIB version is not in the map when @PreAuthorize is removed.</description>
			<version>2.3 GA (Fowler)</version>
			<fixedVersion>2.3.1 (Fowler SR1), 2.4 RC1 (Gosling)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.core.util.Methods.java</file>
			<file type="M">org.springframework.data.rest.core.event.AnnotatedEventHandlerInvoker.java</file>
		</fixedFiles>
	</bug>
	<bug id="597" opendate="2015-06-25 06:43:32" fixdate="2015-07-09 09:01:24" resolution="Fixed">
		<buginformation>
			<summary>AlpsController not working on Spring 4.2</summary>
			<description></description>
			<version>2.2.2 (Evans SR2)</version>
			<fixedVersion>2.4 RC1 (Gosling)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration.java</file>
			<file type="M">org.springframework.data.rest.webmvc.alps.AlpsJsonHttpMessageConverter.java</file>
			<file type="M">org.springframework.data.rest.webmvc.config.RepositoryRestMvConfigurationIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="377" opendate="2014-08-26 03:39:27" fixdate="2015-07-12 23:37:15" resolution="Fixed">
		<buginformation>
			<summary>UriStringDeserializer fails with "Could not read JSON: Template must not be null or empty!"</summary>
			<description>I&amp;amp;apos;ve created integration tests to post an account to the spring-data-rest endpoint, this account contains a nested entity called accountType. When posting to the endpoint I get the error below. I&amp;amp;apos;ve attached the stackoverflow URL that describes my problem exactly.






 org.springframework.http.converter.HttpMessageNotReadableException: Could not read JSON: Template must not be null or empty! (through reference chain: com.wraith.repository.entity.Account["type"]); nested exception is com.fasterxml.jackson.databind.JsonMappingException: Template must not be null or empty! (through reference chain: com.wraith.repository.entity.Account["type"])




	at org.springframework.http.converter.json.MappingJackson2HttpMessageConverter.readJavaType(MappingJackson2HttpMessageConverter.java:228)




	at org.springframework.http.converter.json.MappingJackson2HttpMessageConverter.readInternal(MappingJackson2HttpMessageConverter.java:212)




	at org.springframework.http.converter.AbstractHttpMessageConverter.read(AbstractHttpMessageConverter.java:159)




	at org.springframework.data.rest.webmvc.config.PersistentEntityResourceHandlerMethodArgumentResolver.resolveArgument(PersistentEntityResourceHandlerMethodArgumentResolver.java:100)




	at org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:79)




	at org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:157)




	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:124)




	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:104)




	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandleMethod(RequestMappingHandlerAdapter.java:749)




	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:689)




	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:83)




	at com.wraith.repository.integrationTests.AbstractBaseIntegrationTests.performPostRequest(AbstractBaseIntegrationTests.java:105)




	at com.wraith.repository.integrationTests.AbstractBaseIntegrationTests.createNewEntity(AbstractBaseIntegrationTests.java:113)




	at com.wraith.repository.integrationTests.AccountRequestTest.createNewAccount(AccountRequestTest.java:43)




	at com.wraith.repository.integrationTests.AccountRequestTest.testCreateAccountRequest(AccountRequestTest.java:32)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)




	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)




	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)




	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)




	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)




	at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:74)




	at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:83)




	at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:72)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:233)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:87)




	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)




	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)




	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)




	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)




	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)




	at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)




	at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:71)




	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:176)




	at org.junit.runner.JUnitCore.run(JUnitCore.java:160)




	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:67)




Caused by: com.fasterxml.jackson.databind.JsonMappingException: Template must not be null or empty! (through reference chain: com.wraith.repository.entity.Account["type"])




	at com.fasterxml.jackson.databind.JsonMappingException.wrapWithPath(JsonMappingException.java:232)




	at com.fasterxml.jackson.databind.JsonMappingException.wrapWithPath(JsonMappingException.java:197)




	at com.fasterxml.jackson.databind.deser.BeanDeserializerBase.wrapAndThrow(BeanDeserializerBase.java:1420)




	at com.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:244)




	at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:118)




	at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:2993)




	at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2158)




	at org.springframework.http.converter.json.MappingJackson2HttpMessageConverter.readJavaType(MappingJackson2HttpMessageConverter.java:225)




	... 41 more




Caused by: java.lang.IllegalArgumentException: Template must not be null or empty!




	at org.springframework.util.Assert.hasText(Assert.java:162)




	at org.springframework.hateoas.UriTemplate.&amp;lt;init&amp;gt;(UriTemplate.java:56)




	at org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module$UriStringDeserializer.deserialize(PersistentEntityJackson2Module.java:380)




	at com.fasterxml.jackson.databind.deser.SettableBeanProperty.deserialize(SettableBeanProperty.java:525)




	at com.fasterxml.jackson.databind.deser.impl.MethodProperty.deserializeAndSet(MethodProperty.java:99)




	at com.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:242)




	... 45 more





</description>
			<version>2.1.2 (Dijkstra SR2)</version>
			<fixedVersion>2.3.2 (Fowler SR2), 2.4 RC1 (Gosling)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.json.UriStringDeserializerUnitTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module.java</file>
		</fixedFiles>
	</bug>
	<bug id="617" opendate="2015-07-16 03:35:17" fixdate="2015-07-16 06:27:58" resolution="Fixed">
		<buginformation>
			<summary>Requests with Accept header of application/*+json return the compact representation</summary>
			<description>As the controller methods handling the compact representation use an explicit produces clause in the request mapping, they get favored when the client sends Accept: application/*+json.
We should tweak the default mappings to implicitly match this situation.</description>
			<version>2.3.1 (Fowler SR1)</version>
			<fixedVersion>2.3.2 (Fowler SR2), 2.4 RC1 (Gosling)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryRestHandlerMapping.java</file>
			<file type="M">org.springframework.data.rest.webmvc.config.LegacyRepresentationConfigIntegrationTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.BasePathAwareHandlerMapping.java</file>
		</fixedFiles>
	</bug>
	<bug id="581" opendate="2015-06-17 09:50:36" fixdate="2015-07-16 10:57:08" resolution="Fixed">
		<buginformation>
			<summary>ETag getVersionInformation fails with proxied Entities for projections</summary>
			<description>See the reference GitHub project.
I&amp;amp;apos;ve got an @Entity with a @Version&amp;amp;apos;ed field, a @Projection, and a Repository. When I try to GET the projection of a single entry, I get a 500 Internal server error, because of a failed assertion in BasicPersistentEntity line 394, as called from Etag line 191:
&amp;gt; Assert.isTrue(getType().isInstance(bean), "Target bean is not of type of the persistent entity!");
The argument bean here is of type $Proxy90 / JdkDynamicAopProxy, not Book.
The projection only works again when the @Version annotation is removed. This is since Fowler, as I had no such issues with Evans.</description>
			<version>2.3 GA (Fowler)</version>
			<fixedVersion>2.3.1 (Fowler SR1), 2.4 RC1 (Gosling)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryEntityControllerIntegrationTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryEntityController.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.Address.java</file>
		</fixedFiles>
	</bug>
	<bug id="599" opendate="2015-06-27 04:33:55" fixdate="2015-07-17 13:40:39" resolution="Duplicate">
		<buginformation>
			<summary>findBy + @Param expects an Id, which is not visible via REST</summary>
			<description>Hi,
here is another issue I came across while trying out Spring Data REST: 
IDs are, if I&amp;amp;apos;m correct, intentionally not exposed in the resource body, as you&amp;amp;apos;re supposed to use the URL as primary identifier. 
This is a problem, because by exposing a repository finder Spring Data REST expects me to put the primary key as query param.
I put up a small example on github:
https://github.com/otrosien/spring-data-examples/tree/findQueryParamMismatch
This is the interesting part: How am I, as REST client, suppose to fill the query param for customer1?






public interface RelationshipRepository extends PagingAndSortingRepository&amp;lt;Relationship, Long&amp;gt; {




 Page&amp;lt;Relationship&amp;gt; findByCustomer1(@Param("customer1") Customer customer1, Pageable pageable);





</description>
			<version>2.2.2 (Evans SR2)</version>
			<fixedVersion>2.4 M1 (Gosling)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.alps.AlpsControllerIntegrationTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositorySearchController.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityToJsonSchemaConverterUnitTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositorySearchControllerIntegrationTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration.java</file>
			<file type="M">org.springframework.data.rest.core.UriToEntityConverter.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.BookRepository.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">502</link>
		</links>
	</bug>
	<bug id="606" opendate="2015-07-03 08:57:17" fixdate="2015-07-20 10:04:53" resolution="Fixed">
		<buginformation>
			<summary>Non-public @RepositoryEventHandler are not made accessible prior to reflective invocation</summary>
			<description>To reproduce:
1. Register a non-public @RepositoryEventHandler class with at least one @HandleBeforeCreate, @HandleBeforeSave, etc. method.
2. Try to create / save an entity through its repository.
3. Notice the following exception:






java.lang.IllegalStateException: Could not access method: Class org.springframework.util.ReflectionUtils can not access a member of class com.example.MyEventHandler with modifiers "public"




	at org.springframework.util.ReflectionUtils.handleReflectionException(ReflectionUtils.java:271)




	at org.springframework.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:214)




	at org.springframework.data.rest.core.event.AnnotatedEventHandlerInvoker.onApplicationEvent(AnnotatedEventHandlerInvoker.java:92)






The fix is to setAccessible(true) on the method prior to invoking it at AnnotatedEventHandler:92. </description>
			<version>2.3.1 (Fowler SR1)</version>
			<fixedVersion>2.3.2 (Fowler SR2), 2.4 RC1 (Gosling)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.core.event.AnnotatedEventHandlerInvokerUnitTests.java</file>
			<file type="M">org.springframework.data.rest.core.event.AnnotatedEventHandlerInvoker.java</file>
		</fixedFiles>
	</bug>
	<bug id="605" opendate="2015-07-02 23:41:07" fixdate="2015-07-22 12:06:21" resolution="Fixed">
		<buginformation>
			<summary>NullPointerExceptions when issuing PATCH requests on entities containing Map properties</summary>
			<description>The PATCH request when we have a Map in our entities doesn&amp;amp;apos;t work. I have a map containing the localizations values for an field.  The PUT/POST works correctly. Once I try to PATCH with application/json media type I get a NullPointerException.
Just send the following raw content as PATCH request body:






{




  "name": {




    "bg_BG": {




      "value": "123"




    },




    "en_GB": {




      "value": "Mens66"




    }




  }




}






The problem I guess is inside DomainObjectReader.doMerge(). Here once I hit the map property there is a check is nested != null and is it a property. Because property is true it invokes recursively the doMerge() method which at the beginning is trying to get entities.getPersistentEntity() but the argument passed is a PersistentMap and the result is null, so after that getJacksonProperties() of null throws an NPE. 
I am attaching a simple project containing a JUnit test that shows that (the test is called testPatchHttp).
Looking at the code I noticed that in JsonPatchHandler.apply() there is a check checking request.isJsonPatchRequest() which in case of application/json is false. (the case explained above) I tried to send content type of application/json-patch+json to go on the other route but there I also got an exception "Can not deserialize instance of java.util.ArrayList out of START_OBJECT token". I am attaching this test as well which is called "testPatchJsonPatchHttp".</description>
			<version>2.3 GA (Fowler)</version>
			<fixedVersion>2.3.2 (Fowler SR2), 2.4 RC1 (Gosling)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.config.JsonPatchHandlerUnitTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.DomainObjectReaderUnitTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.config.PersistentEntityResourceHandlerMethodArgumentResolver.java</file>
			<file type="M">org.springframework.data.rest.webmvc.config.JsonPatchHandler.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.DomainObjectReader.java</file>
		</fixedFiles>
	</bug>
	<bug id="594" opendate="2015-06-23 08:44:21" fixdate="2015-07-27 05:30:17" resolution="Duplicate">
		<buginformation>
			<summary>Extending SpringBootRepositoryRestMvcConfiguration removes jacksonObjectMapper bean</summary>
			<description>I have an application where I am auto-wiring ObjectMapper as 






@Autowired




@Qualifier("jacksonObjectMapper")




private ObjectMapper mapper;






If I create a class (with empty body even), which extends SpringBootRepositoryRestMvcConfiguration, this code breaks, because there is no jacksonObjectMapper bean. There are other ObjectMapper instances, but they behave differently. Extending a class should not change the applications behavior.</description>
			<version>2.3 GA (Fowler)</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration.java</file>
			<file type="M">org.springframework.data.rest.webmvc.config.LegacyRepresentationConfigIntegrationTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.config.RepositoryRestMvConfigurationIntegrationTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityToJsonSchemaConverterUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">621</link>
			<link type="Relate" description="relates to">621</link>
		</links>
	</bug>
	<bug id="655" opendate="2015-08-21 06:59:05" fixdate="2015-08-21 07:01:16" resolution="Fixed">
		<buginformation>
			<summary>Typo in exception message in parameter checks for ParameterMetadata</summary>
			<description></description>
			<version>2.3.2 (Fowler SR2)</version>
			<fixedVersion>2.4 GA (Gosling), 2.3.3 (Fowler SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.core.mapping.ParameterMetadata.java</file>
		</fixedFiles>
	</bug>
	<bug id="662" opendate="2015-08-29 08:55:18" fixdate="2015-08-29 13:46:25" resolution="Fixed">
		<buginformation>
			<summary>Unable to post entity with subclassed property (JPA)</summary>
			<description>Given these entities:






static class PetOwner {




    private Pet pet;




}









@JsonTypeInfo(include = JsonTypeInfo.As.PROPERTY, use = JsonTypeInfo.Id.MINIMAL_CLASS)




static class Pet {}




static class Cat extends Pet {}






Submitting a post like






curl -d &amp;amp;apos;{"pet" : "http://localhost:8080/pets/1"}&amp;amp;apos; -H &amp;amp;apos;Content-Type: application/json&amp;amp;apos; &amp;amp;apos;http://localhost:8080/petOwners/&amp;amp;apos;






fails, because Jackson will try and deserialize "with type".</description>
			<version>2.3.2 (Fowler SR2)</version>
			<fixedVersion>2.4 GA (Gosling), 2.3.3 (Fowler SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityJackson2ModuleUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="665" opendate="2015-09-02 06:42:16" fixdate="2015-09-02 13:23:34" resolution="Fixed">
		<buginformation>
			<summary>Use consistent scheme for property titles in JSON Schema</summary>
			<description></description>
			<version>2.4 GA (Gosling)</version>
			<fixedVersion>2.4.1 (Gosling SR1), 2.5 M1 (Hopper)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityToJsonSchemaConverter.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.JsonSchema.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityToJsonSchemaConverterUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="699" opendate="2015-11-06 15:28:31" fixdate="2015-11-06 15:40:18" resolution="Fixed">
		<buginformation>
			<summary>On Java 8, link templates to search resources using pagination contain pageable variable</summary>
			<description>When using Java 8 with parameter name discovery added, the links pointing to search methods using a Pageable contain a pageable URI template variable. This is caused by the RepositoryMethodResourceMapping only dropping parameters without names (assuming Pageable and Sort were never annotated with @Param).
We should explicitly exclude parameters of these types from being exposed as explicit search method parameters.</description>
			<version>2.3.2 (Fowler SR2)</version>
			<fixedVersion>2.4.1 (Gosling SR1), 2.5 M1 (Hopper), 2.3.3 (Fowler SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.core.mapping.RepositoryMethodResourceMapping.java</file>
			<file type="M">org.springframework.data.rest.core.mapping.RepositoryMethodResourceMappingUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="683" opendate="2015-09-23 13:49:39" fixdate="2015-11-06 15:41:00" resolution="Fixed">
		<buginformation>
			<summary>ALPS profile does not reflect jackson customization (e.g. enableEnumTranslation=true)</summary>
			<description>Found while trying to document the enums of my REST API with ALPS.
See example including failing test here: https://github.com/otrosien/spring-alps-bug
The alps profile starts like below, but seems like it uses a differently configured jackson mapper, as the main one is configured to "enableEnumTranslation" ("Payment expected" instead of "PAYMENT_EXPECTED").






{




  "version" : "1.0",




  "descriptors" : [ {




    "id" : "order-representation",




    "href" : "http://localhost/profile/orders",




    "descriptors" : [ {




      "name" : "status",




      "doc" : {




        "value" : "PAYMENT_EXPECTED, PAID",




        "format" : "TEXT"




      },




      "type" : "SEMANTIC"




    } ]






</description>
			<version>2.4 GA (Gosling)</version>
			<fixedVersion>2.4.1 (Gosling SR1), 2.5 M1 (Hopper)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.alps.RootResourceInformationToAlpsDescriptorConverter.java</file>
			<file type="M">org.springframework.data.rest.webmvc.alps.AlpsControllerIntegrationTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration.java</file>
			<file type="M">org.springframework.data.rest.webmvc.alps.AlpsJsonHttpMessageConverter.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.Person.java</file>
		</fixedFiles>
	</bug>
	<bug id="701" opendate="2015-11-09 16:01:52" fixdate="2015-11-10 13:09:40" resolution="Fixed">
		<buginformation>
			<summary>NPE when updating resource via PUT</summary>
			<description>I&amp;amp;apos;m not sure if this is a regression, but it is basically the same issue as DATAREST-491 and DATAREST-605. I&amp;amp;apos;m seeing this using spring-boot-starter-data-rest:1.3.0.M5.
Check out the demo project and do the following to reproduce:
Create a resource:






curl -v -X POST http://localhost:8080/tickets -H "Content-Type: application/json" -d &amp;amp;apos;{"properties" : {"a": "1", "b": {"c": "2"}}}&amp;amp;apos;






Try to update the properties of the resource via PUT:






curl -v -X PUT http://localhost:8080/tickets/5640c0b6b760828633d03cca -H "Content-Type: application/json" -d &amp;amp;apos;{"properties" : {"a": "3", "b": {"c": "4"}}}&amp;amp;apos;






The following NPE is observed:






org.springframework.http.converter.HttpMessageNotReadableException: Could not read an object of type class demo.Ticket from the request!; nested exception is org.springframework.http.converter.HttpMessageNotReadableException: Could not read payload!; nested exception is java.lang.NullPointerException




	at org.springframework.data.rest.webmvc.config.PersistentEntityResourceHandlerMethodArgumentResolver.readPutForUpdate(PersistentEntityResourceHandlerMethodArgumentResolver.java:206) ~[spring-data-rest-webmvc-2.4.0.RELEASE.jar:na]




	...




	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-8.0.28.jar:8.0.28]




	at java.lang.Thread.run(Thread.java:745) [na:1.8.0_25]




Caused by: org.springframework.http.converter.HttpMessageNotReadableException: Could not read payload!; nested exception is java.lang.NullPointerException




	at org.springframework.data.rest.webmvc.json.DomainObjectReader.merge(DomainObjectReader.java:138) ~[spring-data-rest-webmvc-2.4.0.RELEASE.jar:na]




	at org.springframework.data.rest.webmvc.json.DomainObjectReader.readPut(DomainObjectReader.java:130) ~[spring-data-rest-webmvc-2.4.0.RELEASE.jar:na]




	at org.springframework.data.rest.webmvc.config.JsonPatchHandler.applyPut(JsonPatchHandler.java:134) ~[spring-data-rest-webmvc-2.4.0.RELEASE.jar:na]




	at org.springframework.data.rest.webmvc.config.PersistentEntityResourceHandlerMethodArgumentResolver.readPutForUpdate(PersistentEntityResourceHandlerMethodArgumentResolver.java:203) ~[spring-data-rest-webmvc-2.4.0.RELEASE.jar:na]




	... 52 common frames omitted




Caused by: java.lang.NullPointerException: null




	at org.springframework.data.rest.webmvc.json.DomainObjectReader.getJacksonProperties(DomainObjectReader.java:254) ~[spring-data-rest-webmvc-2.4.0.RELEASE.jar:na]




	at org.springframework.data.rest.webmvc.json.DomainObjectReader.doMerge(DomainObjectReader.java:158) ~[spring-data-rest-webmvc-2.4.0.RELEASE.jar:na]




	at org.springframework.data.rest.webmvc.json.DomainObjectReader.doMergeNestedMap(DomainObjectReader.java:238) ~[spring-data-rest-webmvc-2.4.0.RELEASE.jar:na]




	at org.springframework.data.rest.webmvc.json.DomainObjectReader.doMerge(DomainObjectReader.java:196) ~[spring-data-rest-webmvc-2.4.0.RELEASE.jar:na]




	at org.springframework.data.rest.webmvc.json.DomainObjectReader.merge(DomainObjectReader.java:136) ~[spring-data-rest-webmvc-2.4.0.RELEASE.jar:na]




	... 55 common frames omitted






</description>
			<version>2.4 GA (Gosling)</version>
			<fixedVersion>2.4.1 (Gosling SR1), 2.5 M1 (Hopper), 2.3.3 (Fowler SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.json.DomainObjectReaderUnitTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.DomainObjectReader.java</file>
		</fixedFiles>
	</bug>
	<bug id="690" opendate="2015-09-30 08:52:24" fixdate="2015-11-13 14:33:47" resolution="Fixed">
		<buginformation>
			<summary>Invalid JSON Schema for properties pointing to association resources</summary>
			<description>I am using a Spring Data REST version of Spring Boot&amp;amp;apos;s PetClinic application for playing around with the JSON Schema support. I noticed the following:
A property which represents a one-to-many association is of type string and format uri. However, it also contains the properties uniqueItems and items, which, according to the JSON Schema validation docs, only exist for array types. Below is an excerpt of the JSON Schema for the Owner class:






{




  "title": "Owner",




  "properties": {




    "pets": {




      "title": "Pets",




      "readOnly": false,




      "type": "string",




      "format": "uri",




      "uniqueItems": true,




      "items": {




        "type": "object"




      }




    },




    ...




  }




}






I think the correct representation would be the following, do you agree?






{




  "title": "Owner",




  "properties": {




    "pets": {




      "title": "Pets",




      "readOnly": false,




      "type": "array",




      "uniqueItems": true,




      "items": {




        "type": "string",




        "format": "uri"




      }




    },




    ...




  }




}





</description>
			<version>2.4 GA (Gosling)</version>
			<fixedVersion>2.4.1 (Gosling SR1), 2.5 M1 (Hopper)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityToJsonSchemaConverter.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.JsonSchema.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityToJsonSchemaConverterUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="705" opendate="2015-11-13 12:10:23" fixdate="2015-11-20 15:58:00" resolution="Fixed">
		<buginformation>
			<summary>Cannot PUT versioned entity returned by spring-data-rest</summary>
			<description>I would expect it to be possible to execute PUT by simply supplying all fields returned by GET. However, this is currently broken as a consequence of DATAREST-160. 
Now when an entity is exposed via REST API (either as part of a list, or directly), it&amp;amp;apos;s returned without version property. However, when PUT operation is performed, version property can be required, since the whole entity is persisted (as opposed to PATCH logic where only changed fields need to be supplied). This is true, for example, for JPA, which will check version and refuse updating if version is missing.
This means that REST API client is expected to send a property that it never received. In fact, the client might not even be aware that such property exists, how it&amp;amp;apos;s called, and what value it should contain.</description>
			<version>2.4 GA (Gosling)</version>
			<fixedVersion>2.4.2 (Gosling SR2), 2.5 M1 (Hopper), 2.3.3 (Fowler SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.json.DomainObjectReaderUnitTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.DomainObjectReader.java</file>
		</fixedFiles>
	</bug>
	<bug id="712" opendate="2015-11-24 10:19:46" fixdate="2015-11-24 14:38:25" resolution="Fixed">
		<buginformation>
			<summary>Search a repository that implements QueryDslPredicateExecutor by a related Entity doesn&amp;apos;t work anymore</summary>
			<description>If you define a repository this way:






@RepositoryRestResource(collectionResourceRel = "people", path = "people")




public interface PersonRepository extends PagingAndSortingRepository&amp;lt;Person, Long&amp;gt; {




  Page&amp;lt;Person&amp;gt; findByAddress(@Param("address") Address address, Pageable p);




}






where Address in another Entity, you can invoke the search method like this:
http://localhost:8080/people/search/findByAddress?address=/addresses/1
and everything works like a charm.
Now suppose you want to use QueryDSL predicates on the repository, so the repository must implement QueryDslPredicateExecutor interface:






@RepositoryRestResource(collectionResourceRel = "people", path = "people")




public interface PersonRepository extends PagingAndSortingRepository&amp;lt;Person, Long&amp;gt;, QueryDslPredicateExecutor&amp;lt;Person&amp;gt;




{




  Page&amp;lt;Person&amp;gt; findByAddress(@Param("address") Address address, Pageable p);




}






By implementing this interface something changes in the REST behaviour of the repository and if you try to invoke the same search method:
http://localhost:8080/people/search/findByAddress?address=/addresses/1
you get this exception:






org.springframework.core.convert.ConversionFailedException: Failed to convert from type java.lang.String to type java.lang.Long for value &amp;amp;apos;/addresses/1&amp;amp;apos;; nested exception is java.lang.NumberFormatException: For input string: "/addresses/1"




	at org.springframework.core.convert.support.ConversionUtils.invokeConverter(ConversionUtils.java:41) ~[spring-core-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.core.convert.support.GenericConversionService.convert(GenericConversionService.java:192) ~[spring-core-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.core.convert.support.GenericConversionService.convert(GenericConversionService.java:176) ~[spring-core-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.data.repository.support.DomainClassConverter$ToEntityConverter.convert(DomainClassConverter.java:159) ~[spring-data-commons-1.11.1.RELEASE.jar:na]




	at org.springframework.core.convert.support.ConversionUtils.invokeConverter(ConversionUtils.java:35) ~[spring-core-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.core.convert.support.GenericConversionService.convert(GenericConversionService.java:192) ~[spring-core-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.data.querydsl.binding.QuerydslPredicateBuilder.convertToPropertyPathSpecificType(QuerydslPredicateBuilder.java:217) ~[spring-data-commons-1.11.1.RELEASE.jar:na]




	at org.springframework.data.querydsl.binding.QuerydslPredicateBuilder.getPredicate(QuerydslPredicateBuilder.java:109) ~[spring-data-commons-1.11.1.RELEASE.jar:na]




	at org.springframework.data.rest.webmvc.config.QuerydslAwareRootResourceInformationHandlerMethodArgumentResolver.postProcess(QuerydslAwareRootResourceInformationHandlerMethodArgumentResolver.java:88) ~[spring-data-rest-webmvc-2.4.1.RELEASE.jar:na]




	at org.springframework.data.rest.webmvc.config.RootResourceInformationHandlerMethodArgumentResolver.resolveArgument(RootResourceInformationHandlerMethodArgumentResolver.java:92) ~[spring-data-rest-webmvc-2.4.1.RELEASE.jar:na]




	at org.springframework.data.rest.webmvc.config.RootResourceInformationHandlerMethodArgumentResolver.resolveArgument(RootResourceInformationHandlerMethodArgumentResolver.java:40) ~[spring-data-rest-webmvc-2.4.1.RELEASE.jar:na]




	at org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:78) ~[spring-web-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	[...]




Caused by: java.lang.NumberFormatException: For input string: "/addresses/1"




	at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) ~[na:1.8.0_66]




	at java.lang.Long.parseLong(Long.java:578) ~[na:1.8.0_66]




	at java.lang.Long.valueOf(Long.java:803) ~[na:1.8.0_66]




	at org.springframework.util.NumberUtils.parseNumber(NumberUtils.java:197) ~[spring-core-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.core.convert.support.StringToNumberConverterFactory$StringToNumber.convert(StringToNumberConverterFactory.java:61) ~[spring-core-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.core.convert.support.StringToNumberConverterFactory$StringToNumber.convert(StringToNumberConverterFactory.java:48) ~[spring-core-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.core.convert.support.GenericConversionService$ConverterFactoryAdapter.convert(GenericConversionService.java:425) ~[spring-core-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.core.convert.support.ConversionUtils.invokeConverter(ConversionUtils.java:35) ~[spring-core-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	... 60 common frames omitted






Trying to use the "previous" format (by passing the id of the related entity)
http://localhost:8080/people/search/findByAddress?address=1
doesn&amp;amp;apos;t work either (this used to work with 2.2.3.RELEASE):






java.lang.IllegalArgumentException: Cannot resolve URI 1. Is it local or remote? Only local URIs are resolvable.




	at org.springframework.data.rest.core.UriToEntityConverter.convert(UriToEntityConverter.java:114) ~[spring-data-rest-core-2.4.1.RELEASE.jar:na]




	at org.springframework.core.convert.support.ConversionUtils.invokeConverter(ConversionUtils.java:35) ~[spring-core-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.core.convert.support.GenericConversionService.convert(GenericConversionService.java:192) ~[spring-core-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.data.repository.support.ReflectionRepositoryInvoker.convert(ReflectionRepositoryInvoker.java:248) ~[spring-data-commons-1.11.1.RELEASE.jar:na]




	at org.springframework.data.repository.support.ReflectionRepositoryInvoker.prepareParameters(ReflectionRepositoryInvoker.java:238) ~[spring-data-commons-1.11.1.RELEASE.jar:na]




	at org.springframework.data.repository.support.ReflectionRepositoryInvoker.invokeQueryMethod(ReflectionRepositoryInvoker.java:203) ~[spring-data-commons-1.11.1.RELEASE.jar:na]




	at org.springframework.data.rest.core.support.UnwrappingRepositoryInvokerFactory$UnwrappingRepositoryInvoker.invokeQueryMethod(UnwrappingRepositoryInvokerFactory.java:153) ~[spring-data-rest-core-2.4.1.RELEASE.jar:na]




	at org.springframework.data.querydsl.QuerydslRepositoryInvokerAdapter.invokeQueryMethod(QuerydslRepositoryInvokerAdapter.java:149) ~[spring-data-commons-1.11.1.RELEASE.jar:na]




	at org.springframework.data.rest.webmvc.RepositorySearchController.executeQueryMethod(RepositorySearchController.java:313) ~[spring-data-rest-webmvc-2.4.1.RELEASE.jar:na]




	at org.springframework.data.rest.webmvc.RepositorySearchController.executeSearch(RepositorySearchController.java:177) ~[spring-data-rest-webmvc-2.4.1.RELEASE.jar:na]





</description>
			<version>2.4.1 (Gosling SR1)</version>
			<fixedVersion>2.4.2 (Gosling SR2), 2.5 M1 (Hopper)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.config.QuerydslAwareRootResourceInformationHandlerMethodArgumentResolverUnitTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.config.RootResourceInformationHandlerMethodArgumentResolver.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryEntityController.java</file>
			<file type="M">org.springframework.data.rest.webmvc.config.QuerydslAwareRootResourceInformationHandlerMethodArgumentResolver.java</file>
			<file type="M">org.springframework.data.rest.webmvc.mongodb.MongoWebTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.mongodb.UserRepository.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositorySearchController.java</file>
		</fixedFiles>
	</bug>
	<bug id="697" opendate="2015-10-26 19:40:30" fixdate="2015-12-10 14:07:20" resolution="Fixed">
		<buginformation>
			<summary>ProjectionSerializer doesn&amp;apos;t react to unwrapping mode correctly</summary>
			<description>Previously, it was possible to have a controller method that returned a Resource-wrapped @Projection interface of a domain type. Somewhere between 2.3.2 and 2.4, this functionality was broken. 
The below code sample works fine in SDR 2.3.2, but in 2.4 and current SNAPSHOTs it results in the following error: 






Failed to write HTTP message: org.springframework.http.converter.HttpMessageNotWritableException: Could not write content: Can not start an object, expecting field name; nested exception is com.fasterxml.jackson.core.JsonGenerationException: Can not start an object, expecting field name






Testing this out, serializing a Resource-wrapped POJO works fine, a Resource-wrapped domain type works fine, a non-wrapped Projection works fine, but a Resource-wrapped projection fails with the above error. Using the SDR repository controller to return the projection works fine, too.
This feels like a bug? 
Below is sample code for reproducing this. Tested with Spring Boot 1.2.7 and SDR 2.3.2 (working) and Spring Boot 1.3.1.RC1 and SDR 2.4.0.RELEASE (not working).






@SpringBootApplication




public class Sandbox {









    public static void main(String[] args) {




        SpringApplicationBuilder builder = new SpringApplicationBuilder(Sandbox.class);




        builder.run(args);









    }




}












public interface PersonRepository extends CrudRepository&amp;lt;Person,Long&amp;gt; {




}












@Projection(types=Person.class,name="test")




public interface PersonProjection {









    String getName();




}












@Entity




@Getter




@Setter




public class Person {









    @Id




    @GeneratedValue(strategy = GenerationType.IDENTITY)




    private Long id;









    private String name;









    private String phone;









}












@BasePathAwareController




public class TestController {









    private final ProjectionFactory projectionFactory = new SpelAwareProxyProjectionFactory();









    @Autowired




    private PersonRepository personRepository;









    @RequestMapping(value = "/test/{id}", produces = "application/hal+json")




    public ResponseEntity&amp;lt;Resource&amp;lt;PersonProjection&amp;gt;&amp;gt; getProjection(@PathVariable Long id){




        Person one = personRepository.findOne(id);




        PersonProjection projection = projectionFactory.createProjection(PersonProjection.class, one);




        return ResponseEntity.ok(new Resource&amp;lt;&amp;gt;(projection));




    }









    @RequestMapping(value = "/test", produces = "application/hal+json")




    public ResponseEntity&amp;lt;Resources&amp;lt;Resource&amp;lt;PersonProjection&amp;gt;&amp;gt;&amp;gt; getProjections(){




        Set&amp;lt;Person&amp;gt; people = Sets.newHashSet(personRepository.findAll());




        Resources&amp;lt;Resource&amp;lt;PersonProjection&amp;gt;&amp;gt; wrap = Resources.wrap(people.stream().map(o -&amp;gt; projectionFactory.createProjection(PersonProjection.class, o)).collect(Collectors.toSet()));




        return ResponseEntity.ok(wrap);




    }












@WebAppConfiguration




@SpringApplicationConfiguration(classes = Sandbox.class)




@RunWith(SpringJUnit4ClassRunner.class)




public class TestProjection {









    private MockMvc mockMvc;









    @Autowired




    private WebApplicationContext webApplicationContext;




    




    @Autowired




    private PersonRepository personRepository;









    @Before




    public void before(){




        mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build();




        Person person = new Person();




        person.setName("Adam");




        person.setPhone("123456");




        personRepository.save(person);




        




    }









    @Test 




    public void testProjection() throws Exception {




        mockMvc.perform(get("/test")).andDo(print()).andExpect(status().is2xxSuccessful()).andExpect(jsonPath("$._embedded.persons[0].name").value("Adam")).andExpect(jsonPath("$._embedded.persons[0].phone").doesNotExist());




    }









    @Test




    public void testProjectionSingleResource() throws Exception {




        mockMvc.perform(get("/test/1")).andDo(print()).andExpect(status().is2xxSuccessful()).andExpect(jsonPath("$.name").value("Adam")).andExpect(jsonPath("$.phone").doesNotExist());




    }









    @Test




    public void testProjectionViaSDR() throws Exception {




        mockMvc.perform(get("/persons?projection=test")).andDo(print()).andExpect(status().is2xxSuccessful()).andExpect(jsonPath("$._embedded.persons[0].name").value("Adam")).andExpect(jsonPath("$._embedded.persons[0].phone").doesNotExist());




    }









    @Test




    public void testProjectionViaSDRSingleResource() throws Exception {




        mockMvc.perform(get("/persons/1?projection=test")).andDo(print()).andExpect(status().is2xxSuccessful()).andExpect(jsonPath("$.name").value("Adam")).andExpect(jsonPath("$.phone").doesNotExist());




    }














}





</description>
			<version>2.4 GA (Gosling)</version>
			<fixedVersion>2.4.2 (Gosling SR2), 2.5 M1 (Hopper)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntitySerializationTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">716</link>
		</links>
	</bug>
	<bug id="723" opendate="2015-12-07 16:02:47" fixdate="2015-12-16 17:01:22" resolution="Fixed">
		<buginformation>
			<summary>ConcurrentModificationException</summary>
			<description>From time to time I am getting the following ConcurrentModificationException. Hopefully the stack trace helps:






2015-12-03 14:54:42,255 ERROR    o.a.c.c.C.[.[localhost].[/].[dispatcherServlet]: 182 - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.util.ConcurrentModificationException] with root cause




java.util.ConcurrentModificationException: null




	at java.util.HashMap$HashIterator.nextNode(HashMap.java:1429) ~[na:1.8.0_45]




	at java.util.HashMap$ValueIterator.next(HashMap.java:1458) ~[na:1.8.0_45]




	at org.springframework.data.rest.core.mapping.MappingResourceMetadata$PropertyMappings.getMappingFor(MappingResourceMetadata.java:186) ~[spring-data-rest-core-2.4.1.RELEASE.jar:na]




	at org.springframework.data.rest.core.mapping.MappingResourceMetadata.getProperty(MappingResourceMetadata.java:118) ~[spring-data-rest-core-2.4.1.RELEASE.jar:na]




	at org.springframework.data.rest.core.mapping.RepositoryAwareResourceMetadata.getProperty(RepositoryAwareResourceMetadata.java:93) ~[spring-data-rest-core-2.4.1.RELEASE.jar:na]




	at org.springframework.data.rest.webmvc.RepositoryPropertyReferenceController.doWithReferencedProperty(RepositoryPropertyReferenceController.java:427) ~[spring-data-rest-webmvc-2.4.1.RELEASE.jar:na]




	at org.springframework.data.rest.webmvc.RepositoryPropertyReferenceController.followPropertyReference(RepositoryPropertyReferenceController.java:149) ~[spring-data-rest-webmvc-2.4.1.RELEASE.jar:na]




	at sun.reflect.GeneratedMethodAccessor427.invoke(Unknown Source) ~[na:na]




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_45]




	at java.lang.reflect.Method.invoke(Method.java:497) ~[na:1.8.0_45]




	at org.springsource.loaded.ri.ReflectiveInterceptor.jlrMethodInvoke(ReflectiveInterceptor.java:1432) ~[springloaded-1.2.4.RELEASE.jar:1.2.4.RELEASE]




	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:222) ~[spring-web-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:137) ~[spring-web-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:110) ~[spring-webmvc-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:814) ~[spring-webmvc-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:737) ~[spring-webmvc-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85) ~[spring-webmvc-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:959) ~[spring-webmvc-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:893) ~[spring-webmvc-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970) ~[spring-webmvc-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:861) ~[spring-webmvc-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at javax.servlet.http.HttpServlet.service(HttpServlet.java:622) ~[tomcat-embed-core-8.0.28.jar:8.0.28]




	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846) ~[spring-webmvc-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at javax.servlet.http.HttpServlet.service(HttpServlet.java:729) ~[tomcat-embed-core-8.0.28.jar:8.0.28]




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:291) ~[tomcat-embed-core-8.0.28.jar:8.0.28]




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) ~[tomcat-embed-core-8.0.28.jar:8.0.28]




	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) ~[tomcat-embed-websocket-8.0.28.jar:8.0.28]




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239) ~[tomcat-embed-core-8.0.28.jar:8.0.28]




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) ~[tomcat-embed-core-8.0.28.jar:8.0.28]




	at org.springframework.boot.actuate.autoconfigure.EndpointWebMvcAutoConfiguration$ApplicationContextHeaderFilter.doFilterInternal(EndpointWebMvcAutoConfiguration.java:242) ~[spring-boot-actuator-1.3.0.RELEASE.jar:1.3.0.RELEASE]




	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239) ~[tomcat-embed-core-8.0.28.jar:8.0.28]




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) ~[tomcat-embed-core-8.0.28.jar:8.0.28]




	at org.springframework.boot.actuate.trace.WebRequestTraceFilter.doFilterInternal(WebRequestTraceFilter.java:111) ~[spring-boot-actuator-1.3.0.RELEASE.jar:1.3.0.RELEASE]




	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239) ~[tomcat-embed-core-8.0.28.jar:8.0.28]




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) ~[tomcat-embed-core-8.0.28.jar:8.0.28]




	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:207) ~[spring-security-web-4.0.3.RELEASE.jar:4.0.3.RELEASE]




	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:176) ~[spring-security-web-4.0.3.RELEASE.jar:4.0.3.RELEASE]




	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:346) ~[spring-web-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:262) ~[spring-web-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239) ~[tomcat-embed-core-8.0.28.jar:8.0.28]




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) ~[tomcat-embed-core-8.0.28.jar:8.0.28]




	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) ~[spring-web-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239) ~[tomcat-embed-core-8.0.28.jar:8.0.28]




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) ~[tomcat-embed-core-8.0.28.jar:8.0.28]




	at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:87) ~[spring-web-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239) ~[tomcat-embed-core-8.0.28.jar:8.0.28]




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) ~[tomcat-embed-core-8.0.28.jar:8.0.28]




	at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:77) ~[spring-web-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239) ~[tomcat-embed-core-8.0.28.jar:8.0.28]




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) ~[tomcat-embed-core-8.0.28.jar:8.0.28]




	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:121) ~[spring-web-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239) ~[tomcat-embed-core-8.0.28.jar:8.0.28]




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) ~[tomcat-embed-core-8.0.28.jar:8.0.28]




	at org.springframework.boot.actuate.autoconfigure.MetricsFilter.doFilterInternal(MetricsFilter.java:103) ~[spring-boot-actuator-1.3.0.RELEASE.jar:1.3.0.RELEASE]




	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239) ~[tomcat-embed-core-8.0.28.jar:8.0.28]




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) ~[tomcat-embed-core-8.0.28.jar:8.0.28]




	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:217) ~[tomcat-embed-core-8.0.28.jar:8.0.28]




	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:106) [tomcat-embed-core-8.0.28.jar:8.0.28]




	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:502) [tomcat-embed-core-8.0.28.jar:8.0.28]




	at org.apache.catalina.valves.RemoteIpValve.invoke(RemoteIpValve.java:676) [tomcat-embed-core-8.0.28.jar:8.0.28]




	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:142) [tomcat-embed-core-8.0.28.jar:8.0.28]




	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:79) [tomcat-embed-core-8.0.28.jar:8.0.28]




	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:88) [tomcat-embed-core-8.0.28.jar:8.0.28]




	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:518) [tomcat-embed-core-8.0.28.jar:8.0.28]




	at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1091) [tomcat-embed-core-8.0.28.jar:8.0.28]




	at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:673) [tomcat-embed-core-8.0.28.jar:8.0.28]




	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1500) [tomcat-embed-core-8.0.28.jar:8.0.28]




	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1456) [tomcat-embed-core-8.0.28.jar:8.0.28]




	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_45]




	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_45]




	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-8.0.28.jar:8.0.28]




	at java.lang.Thread.run(Thread.java:745) [na:1.8.0_45]





</description>
			<version>2.4.1 (Gosling SR1)</version>
			<fixedVersion>2.4.2 (Gosling SR2), 2.5 M1 (Hopper)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.core.mapping.MappingResourceMetadataUnitTests.java</file>
			<file type="M">org.springframework.data.rest.core.mapping.PersistentEntitiesResourceMappings.java</file>
			<file type="M">org.springframework.data.rest.core.mapping.MappingResourceMetadata.java</file>
		</fixedFiles>
	</bug>
	<bug id="716" opendate="2015-11-27 09:01:39" fixdate="2016-01-07 14:23:20" resolution="Fixed">
		<buginformation>
			<summary>Rest Endpoints produce HttpMessageNotWritableException sometimes after restarts</summary>
			<description>In some cases after application start some rest repositories fail to handle the http request and throw a HttpMessageNotWritableException (see StackOverflow reference)






2015-11-27 09:56:19.015  WARN 1207 --- [nio-9000-exec-9] .w.s.m.s.DefaultHandlerExceptionResolver : Failed to write HTTP message: org.springframework.http.converter.HttpMessageNotWritableException: Could not write content: org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module$ProjectionResourceContentSerializer cannot be cast to com.fasterxml.jackson.databind.ser.impl.UnwrappingBeanSerializer (through reference chain: org.springframework.hateoas.PagedResources["_embedded"]-&amp;gt;java.util.UnmodifiableMap["permissions"]-&amp;gt;java.util.ArrayList[0]-&amp;gt;org.springframework.data.rest.webmvc.json.ProjectionResource["content"]); nested exception is com.fasterxml.jackson.databind.JsonMappingException: org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module$ProjectionResourceContentSerializer cannot be cast to com.fasterxml.jackson.databind.ser.impl.UnwrappingBeanSerializer (through reference chain: org.springframework.hateoas.PagedResources["_embedded"]-&amp;gt;java.util.UnmodifiableMap["permissions"]-&amp;gt;java.util.ArrayList[0]-&amp;gt;org.springframework.data.rest.webmvc.json.ProjectionResource["content"])




2015-11-27 09:56:19.024  WARN 1207 --- [nio-9000-exec-2] .w.s.m.s.DefaultHandlerExceptionResolver : Failed to write HTTP message: org.springframework.http.converter.HttpMessageNotWritableException: Could not write content: org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module$ProjectionResourceContentSerializer cannot be cast to com.fasterxml.jackson.databind.ser.impl.UnwrappingBeanSerializer (through reference chain: org.springframework.hateoas.PagedResources["_embedded"]-&amp;gt;java.util.UnmodifiableMap["userroles"]-&amp;gt;java.util.ArrayList[0]-&amp;gt;org.springframework.data.rest.webmvc.json.ProjectionResource["content"]); nested exception is com.fasterxml.jackson.databind.JsonMappingException: org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module$ProjectionResourceContentSerializer cannot be cast to com.fasterxml.jackson.databind.ser.impl.UnwrappingBeanSerializer (through reference chain: org.springframework.hateoas.PagedResources["_embedded"]-&amp;gt;java.util.UnmodifiableMap["userroles"]-&amp;gt;java.util.ArrayList[0]-&amp;gt;org.springframework.data.rest.webmvc.json.ProjectionResource["content"])





</description>
			<version>2.4.1 (Gosling SR1)</version>
			<fixedVersion>2.4.2 (Gosling SR2), 2.5 M1 (Hopper)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntitySerializationTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">697</link>
			<link type="Relate" description="relates to">743</link>
		</links>
	</bug>
	<bug id="743" opendate="2016-01-07 17:40:32" fixdate="2016-01-07 20:56:05" resolution="Fixed">
		<buginformation>
			<summary>Rest Endpoints produce HttpMessageNotWritableException sometimes after restarts</summary>
			<description>Occasionally, the application throws a HttpMessageNotWritableException on start up.  See #DATAREST-716.  It appears this is still happening in Gosling SR2 (Spring Boot 1.3.1).






2016-01-06 19:27:54.639  INFO 1783 --- [ost-startStop-1] o.a.catalina.util.SessionIdGenerator     : Creation of SecureRandom instance for session ID generation using [SHA1PRNG] took [9,898] milliseconds.




Jan 06, 2016 7:27:54 PM org.apache.coyote.AbstractProtocol start




INFO: Starting ProtocolHandler ["http-bio-8080"]




Jan 06, 2016 7:27:54 PM org.apache.coyote.AbstractProtocol start




INFO: Starting ProtocolHandler ["ajp-bio-8009"]




Jan 06, 2016 7:27:54 PM org.apache.catalina.startup.Catalina start




INFO: Server startup in 59514 ms




Jan 06, 2016 7:27:54 PM org.apache.catalina.core.ApplicationContext log




INFO: Initializing Spring FrameworkServlet &amp;amp;apos;dispatcherServlet&amp;amp;apos;




2016-01-06 19:27:54.817  INFO 1783 --- [bio-8080-exec-2] o.s.web.servlet.DispatcherServlet        : FrameworkServlet &amp;amp;apos;dispatcherServlet&amp;amp;apos;: initialization started




2016-01-06 19:27:54.854  INFO 1783 --- [bio-8080-exec-2] o.s.web.servlet.DispatcherServlet        : FrameworkServlet &amp;amp;apos;dispatcherServlet&amp;amp;apos;: initialization completed in 28 ms




2016-01-06 19:27:58.029  WARN 1783 --- [io-8080-exec-11] .w.s.m.s.DefaultHandlerExceptionResolver : Failed to write HTTP message: org.springframework.http.converter.HttpMessageNotWritableException: Could not write content: org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module$ProjectionResourceContentSerializer cannot be cast to com.fasterxml.jackson.databind.ser.impl.UnwrappingBeanSerializer (through reference chain: org.springframework.hateoas.PagedResources["_embedded"]-&amp;gt;java.util.UnmodifiableMap["activities"]-&amp;gt;java.util.ArrayList[0]-&amp;gt;org.springframework.data.rest.webmvc.json.ProjectionResource["content"]); nested exception is com.fasterxml.jackson.databind.JsonMappingException: org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module$ProjectionResourceContentSerializer cannot be cast to com.fasterxml.jackson.databind.ser.impl.UnwrappingBeanSerializer (through reference chain: org.springframework.hateoas.PagedResources["_embedded"]-&amp;gt;java.util.UnmodifiableMap["activities"]-&amp;gt;java.util.ArrayList[0]-&amp;gt;org.springframework.data.rest.webmvc.json.ProjectionResource["content"])





</description>
			<version>2.4.2 (Gosling SR2)</version>
			<fixedVersion>2.5 M1 (Hopper), 2.4.4 (Gosling SR4)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">716</link>
		</links>
	</bug>
	<bug id="747" opendate="2016-01-11 18:14:44" fixdate="2016-01-11 19:03:52" resolution="Fixed">
		<buginformation>
			<summary>ProjectionDefinitionConfiguration does not select projection for most concrete type</summary>
			<description>If two projections of the same name are registered for an inheritance hierarchy, the current projection selection algorithm doesn&amp;amp;apos;t necessarily prefer the projection defined for the most concrete type.</description>
			<version>2.4.2 (Gosling SR2)</version>
			<fixedVersion>2.5 M1 (Hopper), 2.4.4 (Gosling SR4)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.core.config.ProjectionDefinitionConfiguration.java</file>
			<file type="M">org.springframework.data.rest.core.config.ProjectionDefinitionConfigurationUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="is depended on by">739</link>
		</links>
	</bug>
	<bug id="754" opendate="2016-01-22 14:41:01" fixdate="2016-01-25 16:53:10" resolution="Fixed">
		<buginformation>
			<summary>Spring Data REST throws NPE when exposing JSON Schema for a Groovy domai object</summary>
			<description>While looking up the JSON Schema for a Groovy domain object-based repository, Spring Data REST threw an NPE. It was trying to parse Groovy&amp;amp;apos;s "metaClass" attribute, which doesn&amp;amp;apos;t exist in a pure Java-based domain object definition.
Need to add groovy-all as a test dependency and then craft some Groovy-based test cases so we can then patch whatever is needed inside PersistentEntityToJsonSchemaConverter to make this work.</description>
			<version>2.2.4 (Evans SR4)</version>
			<fixedVersion>2.5 M1 (Hopper), 2.4.4 (Gosling SR4)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.alps.AlpsControllerIntegrationTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.groovy.SimulatedGroovyDomainClassRepository.java</file>
			<file type="M">org.springframework.data.rest.webmvc.mongodb.groovy.SimulatedGroovyDomainClass.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityToJsonSchemaConverter.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.groovy.SimulatedGroovyDomainClass.java</file>
			<file type="M">org.springframework.data.rest.webmvc.mongodb.groovy.SimulatedGroovyDomainClassRepository.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityToJsonSchemaConverterUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="791" opendate="2016-03-31 08:19:00" fixdate="2016-04-01 08:42:45" resolution="Fixed">
		<buginformation>
			<summary>Repository with EntityLookup not resolving for POST on an Association-Ressource</summary>
			<description>POST /user/olivergierke/friends
content-type: text/uri-list
content: /person/
{username}
(username=asterix, user_Id=12345)
Generate SQL with "user_ID" in where-Clause, but the "username" as param.
select person.user_id as user_id,  ... , person.username as username
from persontable person
where person.user_id=&amp;amp;apos;asterix&amp;amp;apos;
URI for User-Resource "asterix" is /person/asterix
Using the person/12345 instead of person/asterix as paylod works fine, but  thats not as intended.
(see config.withEntityLookup().forRepository(PersonRepository.class, Person::getUsername, PersonRepository::findByUsername)
Otherwise, following example works fine:
PATCH /user/olivergierke/
{"friends": [ "/person/asterix" ]}


(see https://jira.spring.io/browse/DATAREST-724)</description>
			<version>2.5 RC1 (Hopper)</version>
			<fixedVersion>2.5 GA (Hopper)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.AbstractRepositoryRestController.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositorySearchController.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryEntityController.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryPropertyReferenceController.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryController.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">724</link>
		</links>
	</bug>
	<bug id="565" opendate="2015-06-05 14:09:05" fixdate="2016-04-01 10:37:28" resolution="Fixed">
		<buginformation>
			<summary>Hal Browser does not seem to work with spring boot with a non-default context-path</summary>
			<description>if i have server.contextpath=foo in my application.properties 
and i go to localhost:8080/foo/ i am redirected to localhost:8080/browser/index.html which is 404. It if i navigate to: localhost:8080/foo/browser/index.html it also redirects me to that same place. 
Hal Browser needs to take context path into account.</description>
			<version>2.4 M1 (Gosling)</version>
			<fixedVersion>2.4 RC1 (Gosling)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.halbrowser.HalBrowser.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">720</link>
		</links>
	</bug>
	<bug id="720" opendate="2015-12-03 14:01:39" fixdate="2016-04-01 11:00:36" resolution="Fixed">
		<buginformation>
			<summary>HAL Browser default URI doesn&amp;apos;t respect context path</summary>
			<description>If a Spring Data REST application is deployed into a servlet container the HAL browser points to the server root, not the context path under which the the API is deployed.
We should switch to an absolute URI in the Explorer field.</description>
			<version>2.3.2 (Fowler SR2)</version>
			<fixedVersion>2.5 GA (Hopper), 2.4.5 (Gosling SR5)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.halbrowser.HalBrowser.java</file>
			<file type="M">org.springframework.data.rest.webmvc.halbrowser.HalBrowserUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">565</link>
		</links>
	</bug>
	<bug id="792" opendate="2016-03-31 08:40:11" fixdate="2016-04-02 17:00:13" resolution="Fixed">
		<buginformation>
			<summary>PUT request for item resource with customized entity lookup fails</summary>
			<description>PUT /user/olivergierke
content-type: application/jason
content: indenpendent e.g.: 
{"alias" : ["OG","Ollie"]}

(Repos-Customization: config.withEntityLookup().forRepository(UserRepository.class, Person::getUsername, UserRepository::findByUsername , see https://jira.spring.io/browse/DATAREST-724)
results in a NumberFormatException:
 ERROR o.s.d.r.w.RepositoryRestExceptionHandler - Failed to convert from type [java.lang.String] to type [java.lang.Long] for value &amp;amp;apos;olivergierke&amp;amp;apos;; nested exception is java.lang.NumberFormatException: For input string: "olivergierke"
&amp;gt; org.springframework.core.convert.ConversionFailedException: Failed to convert from type [java.lang.String] to type [java.lang.Long] for value &amp;amp;apos;olivergierke&amp;amp;apos;; nested exception is java.lang.NumberFormatException: For input string: "olivergierke"
&amp;gt; at org.springframework.core.convert.support.ConversionUtils.invokeConverter(ConversionUtils.java:41) ~[spring-core-4.2.4.RELEASE.jar:4.2.4.RELEASE]
...</description>
			<version>2.5 RC1 (Hopper)</version>
			<fixedVersion>2.5 GA (Hopper)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.config.PersistentEntityResourceHandlerMethodArgumentResolver.java</file>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryEntityController.java</file>
		</fixedFiles>
	</bug>
	<bug id="798" opendate="2016-04-04 13:07:33" fixdate="2016-04-06 15:13:01" resolution="Fixed">
		<buginformation>
			<summary>Nested validation errors reported as top level ones </summary>
			<description>ValidationErrors doesn&amp;amp;apos;t consider the nested path of fields correctly.</description>
			<version>2.4.4 (Gosling SR4)</version>
			<fixedVersion>2.5 GA (Hopper)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.support.RepositoryConstraintViolationExceptionMessage.java</file>
			<file type="M">org.springframework.data.rest.core.context.ValidatorIntegrationTests.java</file>
			<file type="M">org.springframework.data.rest.core.event.ValidatingRepositoryEventListener.java</file>
			<file type="M">org.springframework.data.rest.core.ValidationErrors.java</file>
		</fixedFiles>
		<links>
			<link type="Supersede" description="is superseded by">801</link>
		</links>
	</bug>
	<bug id="805" opendate="2016-04-09 00:08:16" fixdate="2016-04-14 18:12:47" resolution="Fixed">
		<buginformation>
			<summary>RepositoryConstraintViolationExceptionMessage produces inaccurate output</summary>
			<description>The invalidValue field of RepositoryConstraintViolationExceptionMessage.ValidationError is a string even if the failed member is of another type because it is being string formatted. By maintaining the original type we allow better debugging by expressing more closely the true type input and not just its toString()  and also allow the original marshaller/unmarshaller to express the object as is more appropriate. 
Example input:






{




    "givenName" : "null",




    "familyName" : "Bongiorno",




    "dob" : "2007-12-03",




    "nationalId" : "12345687",




    "photo" : null




    




}






or






{




    "givenName" : null,




    "familyName" : "Bongiorno",




    "dob" : "2007-12-03",




    "nationalId" : "12345687",




    "photo" : null




    




}






example output






{




    "errors": [




        {




            "entity": "Worker",




            "message": "may not be null",




            "invalidValue": "null",




            "property": "givenName"




        }




    ]




}






Entity:






@Entity




public class Worker {









    @Id




    private Long id;









    @NotNull




    @Pattern(regexp = "[^null]", message = "may not be null")




    private String givenName;









    @NotNull




    private String familyName;









    private LocalDate dob;









    private String nationalId;









    private byte[] photo;




}






I intentionally added a silly validation constraint to demonstrate</description>
			<version>2.4.4 (Gosling SR4)</version>
			<fixedVersion>2.5.2 (Hopper SR2), 2.6 M1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.support.RepositoryConstraintViolationExceptionMessage.java</file>
		</fixedFiles>
	</bug>
	<bug id="815" opendate="2016-04-25 15:40:13" fixdate="2016-04-27 13:44:59" resolution="Fixed">
		<buginformation>
			<summary>HAL browser redirect fails when proxied through Zuul</summary>
			<description>I have an app called viewer with little more than @SpringBootApplication &amp;amp; @EnableEurekaClient that has spring-data-rest-hal-browser:2.5.1.RELEASE on it&amp;amp;apos;s classpath, along with spring cloud Brixton.RC2 dependencies. application.yml only holds the spring.application.name, no context-path. This app connects to a eureka instance and is routed through a Zuul proxy, both also running Brixton.RC2. The Zuul proxy automatically routes /viewer to the backend service.
When I open the root URL from whatever port the viewer app is running on, I&amp;amp;apos;m correctly redirected to /browser/index.html#.
When I open the root URL through my separate Zuul proxy, I&amp;amp;apos;m again redirected to /browser/index.html#, but that fails because the /viewer x-forwarded-prefix header is ignored. Here&amp;amp;apos;s a sample response from the actuator /trace page:






{




  "timestamp": 1461596698378,




  "info": {




    "method": "GET",




    "path": "/",




    "headers": {




      "request": {




        "accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",




        "upgrade-insecure-requests": "1",




        "user-agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.87 Safari/537.36",




        "dnt": "1",




        "accept-language": "en-US,en;q=0.8,nl;q=0.6",




        "cookie": "JSESSIONID=",




        "x-forwarded-host": "canary.company.nl",




        "x-forwarded-proto": "https",




        "x-forwarded-prefix": "/viewer",




        "x-forwarded-port": "443",




        "connection": "Keep-Alive",




        "accept-encoding": "gzip",




        "transfer-encoding": "chunked",




        "host": "canary.company.nl:56260"




      },




      "response": {




        "X-Application-Context": "viewer:0",




        "Location": "https://canary.company.nl/browser/index.html#",




        "status": "302"




      }




    }




  }




}






As you can see the Location header does not include the /viewer prefix. Opening /viewer/browser/index.html#/ directly works as expected.</description>
			<version>2.5.1 (Hopper SR1)</version>
			<fixedVersion>2.5.2 (Hopper SR2), 2.6 M1 (Ingalls), 2.4.5 (Gosling SR5)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.halbrowser.HalBrowser.java</file>
			<file type="M">org.springframework.data.rest.webmvc.halbrowser.HalBrowserUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="847" opendate="2016-06-30 13:34:34" fixdate="2016-07-01 12:46:04" resolution="Fixed">
		<buginformation>
			<summary>RepositoryEntityController.saveAndReturn calls AfterSaveEvent with wrong domain object</summary>
			<description>The saveAndReturn method has the following code to handle the Repository Event logic.






publisher.publishEvent(new BeforeSaveEvent(domainObject));




Object obj = invoker.invokeSave(domainObject);




publisher.publishEvent(new AfterSaveEvent(domainObject));






but I think this is wrong. It is using the provided domainObject for the AfterSaveEvent, instead of the obj returned by the invoker. From what I can tell, the expectation is that the After events should be supplied the object with its current state (i.e. after the change has been applied). This is further born out by the behavior of the createAndReturn method, which uses:






publisher.publishEvent(new BeforeCreateEvent(domainObject));




Object savedObject = invoker.invokeSave(domainObject);




publisher.publishEvent(new AfterCreateEvent(savedObject));






Here it is using the returned object (savedObject in this case). This gets even more confusing in the case of a REST PUT call, since that method first determines if the request should create a new item or update an existing item. Granted, since the contract of PUT is to always supply a complete object, the impact is less then a PATCH case, if one is using Generated fields or has EntityListeners that affect the object, those changes would be hidden to the AfterSaveEvent.</description>
			<version>2.3.2 (Fowler SR2)</version>
			<fixedVersion>2.6 M1 (Ingalls), 2.4.5 (Gosling SR5), 2.5.3 (Hopper SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.RepositoryEntityController.java</file>
		</fixedFiles>
	</bug>
	<bug id="863" opendate="2016-07-30 07:55:49" fixdate="2016-08-05 04:22:00" resolution="Fixed">
		<buginformation>
			<summary>REST calls to /api always redirect to HAL Browser if no accept header is specified</summary>
			<description>After updating 2 projects to Spring Boot 1.4 (and Spring Data Rest 2.5.2) all REST calls to /api  that don&amp;amp;apos;t specify a header like "accept: application/json" redirect to /api/browser/index.html#/api/. In previous versions this was only the case when the accept header was text/html, but now the redirect happens with empty accept header.
This may have nothing to do with Spring Data Rest directly, I just put it here because HAL Browser is involved.
But as a result, the default HAL browser itself cannot get the /api and shows its own index.html.</description>
			<version>2.4.4 (Gosling SR4)</version>
			<fixedVersion>2.4.5 (Gosling SR5), 2.5.3 (Hopper SR3), 2.6 RC1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.BasePathAwareHandlerMapping.java</file>
			<file type="M">org.springframework.data.rest.webmvc.halbrowser.HalBrowserIntegrationTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">870</link>
		</links>
	</bug>
	<bug id="870" opendate="2016-08-08 12:45:44" fixdate="2016-08-08 13:00:11" resolution="Duplicate">
		<buginformation>
			<summary>CustomAcceptHeaderHttpServletRequest doesn&amp;apos;t work as intended with Spring Framework 4.3.2</summary>
			<description>CustomAcceptHeaderHttpServletRequest tries to provide a custom view of the request&amp;amp;apos;s Accept header by overriding getHeader(String). It works with Spring Framework 4.2.x but doesn&amp;amp;apos;t work with Spring Framework 4.3.2. As a result of SPR-14506, Spring Framework 4.3.2 now calls getHeaderValues(String) rather than getHeader(String) and the original Accept header is returned.</description>
			<version>2.4.4 (Gosling SR4)</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.BasePathAwareHandlerMapping.java</file>
			<file type="M">org.springframework.data.rest.webmvc.halbrowser.HalBrowserIntegrationTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">863</link>
		</links>
	</bug>
	<bug id="880" opendate="2016-08-29 08:33:33" fixdate="2016-08-29 17:36:23" resolution="Fixed">
		<buginformation>
			<summary>@JsonUnwrapped annotation ignored</summary>
			<description>Using Spring Boot 1.4.0, Spring Data REST no longer seems to take the @JsonUnwrapped annotation into account to unwrap entities in the JSON responses. The previous Spring Boot versions (i.c. 1.3.7) does not have this problem.
It can be easily reproduced on the master branch of the RestBucks project. When you PUT a payment for an order, the credit card number should be unwrapped, since it is annotated with @JsonUnwrapped, but it is not:






{




  "amount": "EUR4.20",




  "creditCard": {




    "number": {




      "number": "1234123412341234"




    },




    "cardHolderName": "Oliver Gierke",




    "expirationDate": "2099-12-01"




  },




  "_links": {




    "restbucks:order": {




      "href": "http://localhost:8080/orders/1{?projection}",




      "templated": true,




      "title": "An order"




    },




    "curies": [




      {




        "href": "http://localhost:8080/docs/{rel}.html",




        "name": "restbucks",




        "templated": true




      }




    ]




  }




}






The expected output would be (if the @JsonUnwrapped annotation was parsed correctly):






{




  "amount": "EUR4.20",




  "creditCard": {




    "number": "1234123412341234",




    "cardHolderName": "Oliver Gierke",




    "expirationDate": "2099-12-01"




  },




  "_links": {




    "restbucks:order": {




      "href": "http://localhost:8080/orders/1{?projection}",




      "templated": true,




      "title": "An order"




    },




    "curies": [




      {




        "href": "http://localhost:8080/docs/{rel}.html",




        "name": "restbucks",




        "templated": true




      }




    ]




  }




}






This looks like a Spring Data REST bug. Spring Boot 1.3.x uses Spring Data Gosling and @JsonUnwrapped works as expected. However if spring-data-releasetrain.version is overriden to use Spring Data Hopper @JsonUnwrapped no longer works. You can see this behaviour if you check out and run this commit in RestBucks.</description>
			<version>2.5.2 (Hopper SR2)</version>
			<fixedVersion>2.5.3 (Hopper SR3), 2.6 RC1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.jpa.CreditCard.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntitySerializationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="866" opendate="2016-08-04 02:18:14" fixdate="2016-09-01 17:28:29" resolution="Fixed">
		<buginformation>
			<summary>NullPointerException from RepositoryRestConfiguration if you inject mvcValidator into RepositoryRestConfigurer</summary>
			<description>Hopper release throws a null-pointer exception when you inject "mvcValidator" in your RepositoryRestConfigurer.</description>
			<version>2.5.2 (Hopper SR2)</version>
			<fixedVersion>2.5.3 (Hopper SR3), 2.6 RC1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="887" opendate="2016-09-06 13:37:00" fixdate="2016-09-12 08:55:09" resolution="Fixed">
		<buginformation>
			<summary>JsonLateObjectEvaluator uses hard-coded ObjectMapper</summary>
			<description>JsonLateObjectEvaluator uses a hard-coded jackson ObjectMapper to deserialize json patch payload. As a result all custom modules to deserialize e.g. LocalDateTime, Money,... will not be available.</description>
			<version>2.5.2 (Hopper SR2)</version>
			<fixedVersion>2.5.3 (Hopper SR3), 2.6 RC1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.json.patch.JsonLateObjectEvaluator.java</file>
			<file type="M">org.springframework.data.rest.webmvc.config.JsonPatchHandler.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.patch.JsonPatchPatchConverter.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.patch.JsonPatchTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="885" opendate="2016-09-06 13:14:13" fixdate="2016-09-12 09:25:40" resolution="Fixed">
		<buginformation>
			<summary>Patch with object value omitted</summary>
			<description>After migrating to spring data rest 2.5.2 the PATCH operation with application/json-patch+json for object values is broken.
Consider the following entity:






@Entity




public class Product implements Identifiable&amp;lt;Long&amp;gt; {









    @Id




    @GeneratedValue(strategy = IDENTITY)




    private Long id;









    private String name;









    @Embedded




    private Gtin gtin;




}









@Embeddable




@Getter




@Setter




public class Gtin {









    private String type;




    private String value;




}






I try to patch with the following payload.






[




  {




    "op":"replace",




    "path":"/gtin",




    "value":{"type":"EAN","value":"some"}




  }




]






As a result of this operation the property to update (gtin) is null. 
org.springframework.data.rest.webmvc.json.patch.JsonLateObjectEvaluator#evaluate returns null because it receives a JsonMappingException as it tries to serialize the value json into the entity type.
Please see this product to reproduce the issue https://github.com/mduesterhoeft/spring-data-rest-json-patch-issue</description>
			<version>2.5.2 (Hopper SR2)</version>
			<fixedVersion>2.5.3 (Hopper SR3), 2.6 RC1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.json.patch.JsonPatchTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.patch.JsonPatchPatchConverter.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.patch.Todo.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.patch.FromOperation.java</file>
			<file type="D">org.springframework.data.rest.webmvc.json.patch.CopyOperationTest.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.patch.AddOperation.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.patch.RemoveOperation.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.patch.TodoList.java</file>
			<file type="D">org.springframework.data.rest.webmvc.json.patch.TestOperationTest.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.patch.PatchException.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.patch.JsonLateObjectEvaluator.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.patch.PatchOperation.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.patch.PathToSpEL.java</file>
			<file type="D">org.springframework.data.rest.webmvc.json.patch.AddOperationTest.java</file>
			<file type="D">org.springframework.data.rest.webmvc.json.patch.MoveOperationTest.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.patch.Patch.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.patch.PatchConverter.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.patch.ReplaceOperation.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.patch.MoveOperation.java</file>
			<file type="D">org.springframework.data.rest.webmvc.json.patch.ReplaceOperationTest.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.patch.TestOperation.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.patch.CopyOperation.java</file>
			<file type="D">org.springframework.data.rest.webmvc.json.patch.PathToSpelTest.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.patch.LateObjectEvaluator.java</file>
			<file type="D">org.springframework.data.rest.webmvc.json.patch.JsonPatchTest.java</file>
			<file type="D">org.springframework.data.rest.webmvc.json.patch.RemoveOperationTest.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.patch.TodoType.java</file>
		</fixedFiles>
	</bug>
	<bug id="889" opendate="2016-09-07 15:51:25" fixdate="2016-09-14 08:17:49" resolution="Fixed">
		<buginformation>
			<summary>JSON Patch silently nullifies property values</summary>
			<description>The current JSON patch implementation internally catches exceptions (JsonLateObjectEvaluator line 41) and misses certain cases in if-else-statements (JsonPatchPatchConverter line 127), resulting in SDR setting the property value to null. This is quite bad, as already noticed in DATAREST-886. Instead some exception, like the PatchException should be thrown to avoid applying wrong changes.</description>
			<version>2.5.2 (Hopper SR2)</version>
			<fixedVersion>2.5.3 (Hopper SR3), 2.6 RC1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.json.patch.JsonLateObjectEvaluator.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.patch.JsonPatchPatchConverter.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.patch.JsonPatchTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.patch.Todo.java</file>
		</fixedFiles>
	</bug>
	<bug id="872" opendate="2016-08-15 12:10:48" fixdate="2016-09-19 08:40:17" resolution="Fixed">
		<buginformation>
			<summary>Jackson&amp;apos;s @JsonTypeInfo is not supported</summary>
			<description>I am trying to use spring data rest in a scenario with spring-data-jpa and entity inheritance.
Spring data rest seems to be able to serialize entities with inheritance. But as soon as I add @JsonTypeInfo annotations (to be able to deserialize) I get the following error when serializing such entities:






Failed to write HTTP message: org.springframework.http.converter.HttpMessageNotWritableException:




    Could not write content: Type id handling not implemented for type java.lang.Object (by serializer of type org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module$NestedEntitySerializer)




    (through reference chain: org.springframework.hateoas.PagedResources["_embedded"]-&amp;gt;java.util.UnmodifiableMap["parents"]-&amp;gt;java.util.ArrayList[0]-&amp;gt;org.springframework.data.rest.webmvc.json.["content"]-&amp;gt;com.example.Parent["valueHolder"]);






The problem seems to be that the custom serializer used here (PersistentEntityJackson2Module$NestedEntitySerializer) does not implement com.fasterxml.jackson.databind.JsonSerializer#serializeWithType - which throw an Exception by default.
Please see this repo to reproduce the issue:
https://github.com/mduesterhoeft/spring-data-rest-entity-inheritance</description>
			<version>2.5.2 (Hopper SR2)</version>
			<fixedVersion>2.5.3 (Hopper SR3), 2.6 RC1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.jpa.Room.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.Suite.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.Meal.java</file>
			<file type="D">org.springframework.data.rest.webmvc.jpa.GuestRepository.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntitySerializationTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.Guest.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.Dinner.java</file>
		</fixedFiles>
	</bug>
	<bug id="883" opendate="2016-09-01 13:50:43" fixdate="2016-09-19 12:16:15" resolution="Fixed">
		<buginformation>
			<summary>Sort mapping does not consider Jackson customizations in field names</summary>
			<description>Currently the Sort instance derived from an HTTP request gets the fields forwarded to the repository without any Jackson customizations (e.g. field name customizations) applied.
That means that although you might have customized the field name in the representation, the request parameter for the sort would still expose the underlying property names.</description>
			<version>2.4.4 (Gosling SR4)</version>
			<fixedVersion>2.4.5 (Gosling SR5), 2.5.3 (Hopper SR3), 2.6 RC1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.json.MappingAwareDefaultedPageableArgumentResolver.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.SortTranslatorUnitTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.MappingAwareSortArgumentResolver.java</file>
			<file type="M">org.springframework.data.rest.webmvc.support.DomainClassResolver.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.JpaWebTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.TestDataPopulator.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.MappingAwarePageableArgumentResolver.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.JacksonMappingAwareSortTranslator.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.MappedProperties.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.Book.java</file>
			<file type="M">org.springframework.data.rest.webmvc.jpa.BookRepository.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.DomainObjectReader.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">909</link>
		</links>
	</bug>
	<bug id="864" opendate="2016-08-01 04:48:43" fixdate="2016-09-19 12:51:49" resolution="Fixed">
		<buginformation>
			<summary>NestedEntitySerializer does not support Maps</summary>
			<description>With the latest Hopper-SR2 I get the following error:






2016-07-30 15:50:16,189 [main] WARN : Failed to write HTTP message: org.springframework.http.converter.HttpMessageNotWritableException: Could not write content: PersistentEntity must not be null! (through reference chain: org.springframework.data.rest.webmvc.json.["content"]-&amp;gt;com.nemesis.platform.module.cms.core.entity.ListerPageEntity["title"]); nested exception is com.fasterxml.jackson.databind.JsonMappingException: PersistentEntity must not be null! (through reference chain: org.springframework.data.rest.webmvc.json.["content"]-&amp;gt;com.nemesis.platform.module.cms.core.entity.ListerPageEntity["title"])






My entity has a Map&amp;lt;Locale, LocalizedValue&amp;gt; where LocalizedValue is @Embedable and in my case entity is null because in PersistentEntityJackson2Module you look it up like this 






PersistentEntity&amp;lt;?, ?&amp;gt; entity = entities.getPersistentEntity(value.getClass());






but value is a Map so value.getClass() returns PersistentMap.
Sounds like you need a dedicated clause for Maps in NestedEntitySerializer.serialize().
</description>
			<version>2.5.2 (Hopper SR2)</version>
			<fixedVersion>2.5.3 (Hopper SR3), 2.6 RC1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntitySerializationTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module.java</file>
			<file type="M">org.springframework.data.rest.tests.mongodb.User.java</file>
		</fixedFiles>
	</bug>
	<bug id="898" opendate="2016-09-19 13:38:50" fixdate="2016-09-19 13:45:28" resolution="Fixed">
		<buginformation>
			<summary>Typo in EntityLookupConfiguration assertion message</summary>
			<description></description>
			<version>2.5.2 (Hopper SR2)</version>
			<fixedVersion>2.5.3 (Hopper SR3), 2.6 RC1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.core.config.EntityLookupConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="906" opendate="2016-09-21 11:56:51" fixdate="2016-09-23 13:33:31" resolution="Fixed">
		<buginformation>
			<summary>MappingAwarePageableArgumentResolver accidentally drops default Pageable returned from delegate PageableHandlerMethodArgumentResolver</summary>
			<description>After upgrading to spring-boot 1.4.1 which includes Hopper-SR3 I get a NPE in the following code section when Pageable is not set explicitly:
public Page&amp;lt;Translation&amp;gt; findTranslationsBy(String isoCode, Pageable pageable) 
{
    log.info("" + pageable.getPageSize());
    ....
}

Setting HOPPER-SR2 in pom.xml fixes the problem as a default page-size is taken into account.</description>
			<version>2.4.5 (Gosling SR5)</version>
			<fixedVersion>2.6 RC1 (Ingalls), 2.5.4 (Hopper SR4), 2.4.6 (Gosling SR6)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.jpa.JpaDefaultPageableWebTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.MappingAwarePageableArgumentResolver.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">909</link>
		</links>
	</bug>
	<bug id="575" opendate="2015-06-12 05:57:02" fixdate="2016-10-23 18:54:24" resolution="Fixed">
		<buginformation>
			<summary>Insufficient check for the presence of a PersistentProperty in MappedProperties</summary>
			<description>Hello,
I just issued a PUT request towards my /rest/variant/564477030778624 and I got the following exception:






2015-06-12 15:53:28,025 org.springframework.data.rest.webmvc.RepositoryRestExceptionHandler [http-nio-8112-exec-2] ERROR: Could not read an object of type class com.samplestore.core.model.catalog.ProjectVariantProductModel from the request!; nested exception is org.springframework.http.converter.HttpMessageNotReadableException: Could not read payload!; nested exception is java.lang.NullPointerException




org.springframework.http.converter.HttpMessageNotReadableException: Could not read an object of type class com.samplestore.core.model.catalog.ProjectVariantProductModel from the request!; nested exception is org.springframework.http.converter.HttpMessageNotReadableException: Could not read payload!; nested exception is java.lang.NullPointerException




	at org.springframework.data.rest.webmvc.config.PersistentEntityResourceHandlerMethodArgumentResolver.readPutForUpdate(PersistentEntityResourceHandlerMethodArgumentResolver.java:197)




	at org.springframework.data.rest.webmvc.config.PersistentEntityResourceHandlerMethodArgumentResolver.read(PersistentEntityResourceHandlerMethodArgumentResolver.java:169)




	at org.springframework.data.rest.webmvc.config.PersistentEntityResourceHandlerMethodArgumentResolver.resolveArgument(PersistentEntityResourceHandlerMethodArgumentResolver.java:125)




	at org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:77)




	at org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:162)




	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:129)




	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:110)




	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandleMethod(RequestMappingHandlerAdapter.java:776)




	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:705)




	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85)




	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:959)




	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:893)




	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:966)




	at org.springframework.web.servlet.FrameworkServlet.doPut(FrameworkServlet.java:879)




	at javax.servlet.http.HttpServlet.service(HttpServlet.java:691)




	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:842)




	at javax.servlet.http.HttpServlet.service(HttpServlet.java:770)




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:303)




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)




	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:85)




	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)




	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)




	at org.springframework.boot.actuate.autoconfigure.EndpointWebMvcAutoConfiguration$ApplicationContextHeaderFilter.doFilterInternal(EndpointWebMvcAutoConfiguration.java:291)




	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)




	at com.nemesis.platform.core.filter.CorsFilter.doFilterInternal(CorsFilter.java:41)




	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)




	at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:77)




	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)




	at org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilter.doFilter(RememberMeAuthenticationFilter.java:146)




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)




	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:107)




	at org.springframework.session.web.http.SessionRepositoryFilter.doFilterInternal(SessionRepositoryFilter.java:111)




	at org.springframework.session.web.http.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:65)




	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:112)




	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:73)




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)




	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99)




	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)




	at com.samplestore.storefront.filter.RequestLoggerFilter.doFilterInternal(RequestLoggerFilter.java:80)




	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)




	at org.springframework.boot.actuate.trace.WebRequestTraceFilter.doFilterInternal(WebRequestTraceFilter.java:102)




	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330)




	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:118)




	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:84)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:113)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:103)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:113)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilter.doFilter(RememberMeAuthenticationFilter.java:139)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:154)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:45)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:199)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:110)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:87)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:50)




	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.access.channel.ChannelProcessingFilter.doFilter(ChannelProcessingFilter.java:144)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:192)




	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:160)




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)




	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:85)




	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)




	at org.springframework.boot.actuate.autoconfigure.MetricFilterAutoConfiguration$MetricsFilter.doFilterInternal(MetricFilterAutoConfiguration.java:90)




	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)




	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:220)




	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:122)




	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:504)




	at org.apache.catalina.valves.RemoteIpValve.invoke(RemoteIpValve.java:683)




	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:170)




	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:103)




	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:116)




	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:421)




	at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1074)




	at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:611)




	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1739)




	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1698)




	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)




	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)




	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)




	at java.lang.Thread.run(Thread.java:745)




Caused by: org.springframework.http.converter.HttpMessageNotReadableException: Could not read payload!; nested exception is java.lang.NullPointerException




	at org.springframework.data.rest.webmvc.json.DomainObjectReader.merge(DomainObjectReader.java:138)




	at org.springframework.data.rest.webmvc.json.DomainObjectReader.readPut(DomainObjectReader.java:130)




	at org.springframework.data.rest.webmvc.config.JsonPatchHandler.applyPut(JsonPatchHandler.java:134)




	at org.springframework.data.rest.webmvc.config.PersistentEntityResourceHandlerMethodArgumentResolver.readPutForUpdate(PersistentEntityResourceHandlerMethodArgumentResolver.java:194)




	... 114 more




Caused by: java.lang.NullPointerException




	at org.springframework.data.rest.webmvc.json.DomainObjectReader.getJacksonProperties(DomainObjectReader.java:207)




	at org.springframework.data.rest.webmvc.json.DomainObjectReader.doMerge(DomainObjectReader.java:158)




	at org.springframework.data.rest.webmvc.json.DomainObjectReader.doMerge(DomainObjectReader.java:188)




	at org.springframework.data.rest.webmvc.json.DomainObjectReader.merge(DomainObjectReader.java:136)




	... 117 more





</description>
			<version>2.4 M1 (Gosling)</version>
			<fixedVersion>2.6 RC1 (Ingalls), 2.4.7 (Gosling SR7), 2.5.5 (Hopper SR5)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.json.MappedProperties.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">574</link>
		</links>
	</bug>
	<bug id="931" opendate="2016-11-02 08:56:34" fixdate="2016-11-03 08:44:04" resolution="Fixed">
		<buginformation>
			<summary>PATCH for non-resource associations doesn&amp;apos;t work as expected</summary>
			<description>User has a repository and Phone has not. [id and some other fields are pruned in below examples for brevity, see full entities in example code]






@Entity




public class User {









        private String name;









	@Column(nullable = false)




	@Temporal(value = TemporalType.TIMESTAMP)




	private Calendar creationDate;









	@OneToMany(mappedBy = "user", cascade = CascadeType.ALL)




	private List&amp;lt;Phone&amp;gt; phones;




}









@Entity




public class Phone extends BaseEntity {









	@Column(nullable = false)




	@Temporal(value = TemporalType.TIMESTAMP)




	private Calendar creationDate;









	@ManyToOne(fetch = FetchType.EAGER)




	private User user;




}






In this case patch for /users/1 with following data works:






{




   "name":"John Doe X",




   "phones":[




      {




         "id":1,




         "creationDate":"2016-11-02T07:34:02.806+0000",




         "label":"work",




         "number":"00000000"




      }




   ]




}






but following data fails with not-null-constraint error for creationDate:






{




   "name":"John Doe X",




   "phones":[




      {




         "id":1,




         "label":"work",




         "number":"00000000"




      }




   ]




}






PATCH works selectively on resources however doesn&amp;amp;apos;t work as expected for inline data which is not a resource (in this case "phone")</description>
			<version>2.5.4 (Hopper SR4)</version>
			<fixedVersion>2.6 M1 (Ingalls), 2.4.7 (Gosling SR7), 2.5.5 (Hopper SR5)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.json.DomainObjectReaderUnitTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.config.JsonPatchHandler.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.DomainObjectReader.java</file>
		</fixedFiles>
	</bug>
	<bug id="919" opendate="2016-10-11 21:57:53" fixdate="2016-11-03 19:23:52" resolution="Fixed">
		<buginformation>
			<summary>PUT/PATCH of Entity object that is a Map silently dropping elements of Map</summary>
			<description>When one has an Entity that has an attribute that is a Map, performing a PUT/PATCH to apply an update the Map will silently throw away any first-level sub-elements of the Map that are themselves a JSON object. 
For example, if I have an entity like:






@Entity




public class Person




{




    @Id




    private Long id;









     private String name;









     private HashMap&amp;lt;String, Object&amp;gt; attributes;




}






And I create the initial record with the following JSON using POST /api/persons:






{




    "name" : "person1",




    "attributes" : {




          "sub1" : "ok",




          "sub2" : [ "ok1", "ok2" ],




          "sub3" : [ { "childOk1" : "ok" }],




          "sub4" : {




               "c1" : "v1"




          }




     }




}






Everything works fine. If I then try to update using PATCH or PUT /api/persons/1:






{




    "attributes" : {




          "sub1" : "ok",




          "sub2" : [ "ok1", "ok2" ],




          "sub3" : [ { "childOk1" : "ok" }],




          "sub4" : {




               "c1" : "v1",




               "c2" : "new"




          }




     }




}






Not only will the attributes.sub4.c2 value not be saved, the entire attributes.sub4 element will disappear. The rest of the items, including attributes.sub3 will remain, since its value is an array of objects instead of just an object. 
If I then submit the exact same REST call, everything will return. In fact, if you just keep doing PUT or PATCH over and over, it will keep flipping back and forth from the two states.
It appears the issue is somewhere in DomainObjectReader.java, but I haven&amp;amp;apos;t been able to fully track it down as of yet. I wanted to get this logged since I suspect this could be a major bug for people, and given that it only appears during the PATCH/PUT phase, its possible this could be missed for awhile.</description>
			<version>2.5.4 (Hopper SR4)</version>
			<fixedVersion>2.6 RC1 (Ingalls), 2.4.7 (Gosling SR7), 2.5.5 (Hopper SR5)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.json.DomainObjectReaderUnitTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.DomainObjectReader.java</file>
		</fixedFiles>
	</bug>
	<bug id="925" opendate="2016-10-19 13:52:17" fixdate="2016-12-02 19:19:01" resolution="Fixed">
		<buginformation>
			<summary>ResourceProcessor not used for nested Projection</summary>
			<description>There seems to be an issue with how ResourceProcessors are being applied to a Projection in certain case. I&amp;amp;apos;ve linked to a repo that demonstrates the issue.
There are two entities, Person and Address. The Person is the parent in a @ManyToOne relationship to the Address. There is also a PersonProjection that shows a subset of the Person, most importantly it does not include the Set&amp;lt;Address&amp;gt; of the child Address entities. There is also a AddressProjection that includes the{{PersonProjection}} of the parent. The goal is to be able to retrieve the list of Address objects and their associated key Person information in a single call. 
Now, I also have ResourceProcessor implementations that add some links to each of the entities. That includes ResourceProcessor implementations on the projections. Everything works as described and expected when using the normal SDR endpoints to get the Person and Address collections. The custom links are correctly added to each entity. Also, when I query for the Person collection with the projection, that too adds the appropriate link to the Person representation. However, when I query the Address collection with the projection, the embedded PersonProjection has the normal SDR-generated links for self and the object itself person in this case, it does not have the custom links. 
The listing of the Person collection. Notice the google link, which is the custom link for this demonstration:






curl http://localhost:8080/persons; echo




{




  "_embedded" : {




    "persons" : [ {




      "firstName" : "Bob",




      "lastName" : "Bobby",




      "quote" : "Likes to Bob",




      "_links" : {




        "self" : {




          "href" : "http://localhost:8080/persons/1"




        },




        "person" : {




          "href" : "http://localhost:8080/persons/1{?projection}",




          "templated" : true




        },




        "google" : {




          "href" : "http://www.google.com"




        },




        "addresses" : {




          "href" : "http://localhost:8080/persons/1/addresses"




        }




      }




    } ]




  },




  "_links" : {




    "self" : {




      "href" : "http://localhost:8080/persons"




    },




    "profile" : {




      "href" : "http://localhost:8080/profile/persons"




    }




  },




  "page" : {




    "size" : 20,




    "totalElements" : 1,




    "totalPages" : 1,




    "number" : 0




  }




}






Now the listing of the Person collection with the projection enabled. Notice that the quote field is not returned, but the google link is still there.






curl http://localhost:8080/persons?projection=simple; echo




{




  "_embedded" : {




    "persons" : [ {




      "firstName" : "Bob",




      "lastName" : "Bobby",




      "_links" : {




        "self" : {




          "href" : "http://localhost:8080/persons/1"




        },




        "person" : {




          "href" : "http://localhost:8080/persons/1{?projection}",




          "templated" : true




        },




        "google" : {




          "href" : "http://www.google.com"




        },




        "addresses" : {




          "href" : "http://localhost:8080/persons/1/addresses"




        }




      }




    } ]




  },




  "_links" : {




    "self" : {




      "href" : "http://localhost:8080/persons"




    },




    "profile" : {




      "href" : "http://localhost:8080/profile/persons"




    }




  },




  "page" : {




    "size" : 20,




    "totalElements" : 1,




    "totalPages" : 1,




    "number" : 0




  }




}




{






The listing of the Address collection. Notice the microsoft link which is the custom link for this demonstration:






curl http://localhost:8080/addresses; echo




{




  "_embedded" : {




    "addresses" : [ {




      "line1" : "1234 Line 1 Street",




      "line2" : "Apt Line 2",




      "city" : "Somewhere",




      "state" : "NY",




      "country" : "USA",




      "zipcode" : "12345",




      "_links" : {




        "self" : {




          "href" : "http://localhost:8080/addresses/1"




        },




        "address" : {




          "href" : "http://localhost:8080/addresses/1{?projection}",




          "templated" : true




        },




        "microsoft" : {




          "href" : "http://www.microsoft.com"




        },




        "person" : {




          "href" : "http://localhost:8080/addresses/1/person"




        }




      }




    } ]




  },




  "_links" : {




    "self" : {




      "href" : "http://localhost:8080/addresses"




    },




    "profile" : {




      "href" : "http://localhost:8080/profile/addresses"




    }




  },




  "page" : {




    "size" : 20,




    "totalElements" : 1,




    "totalPages" : 1,




    "number" : 0




  }




}






And finally the listing of the Address projection, without the expected google link for the embedded Person. However, the Person is missing the quote field, so it is processing the rest of the projection.






curl http://localhost:8080/addresses?projection=simple; echo




{




  "_embedded" : {




    "addresses" : [ {




      "state" : "NY",




      "line" : "1234 Line 1 Street Apt Line 2",




      "city" : "Somewhere",




      "person" : {




        "firstName" : "Bob",




        "lastName" : "Bobby",




        "_links" : {




          "self" : {




            "href" : "http://localhost:8080/persons/1{?projection}",




            "templated" : true




          },




          "addresses" : {




            "href" : "http://localhost:8080/persons/1/addresses"




          }




        }




      },




      "zipcode" : "12345",




      "_links" : {




        "self" : {




          "href" : "http://localhost:8080/addresses/1"




        },




        "address" : {




          "href" : "http://localhost:8080/addresses/1{?projection}",




          "templated" : true




        },




        "microsoft" : {




          "href" : "http://www.microsoft.com"




        },




        "person" : {




          "href" : "http://localhost:8080/addresses/1/person"




        }




      }




    } ]




  },




  "_links" : {




    "self" : {




      "href" : "http://localhost:8080/addresses"




    },




    "profile" : {




      "href" : "http://localhost:8080/profile/addresses"




    }




  },




  "page" : {




    "size" : 20,




    "totalElements" : 1,




    "totalPages" : 1,




    "number" : 0




  }




}






It is not clear why the additional links are not being added. For all I can tell, it should be. There are no errors or warnings or any other indication of an issue that I can see.
</description>
			<version>2.5.4 (Hopper SR4)</version>
			<fixedVersion>2.6 RC1 (Ingalls), 3.0 M2 (Kay)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.tests.shop.ShopConfiguration.java</file>
			<file type="M">org.springframework.data.rest.tests.shop.LineItem.java</file>
			<file type="M">org.springframework.data.rest.tests.shop.Order.java</file>
			<file type="M">org.springframework.data.rest.tests.shop.Product.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module.java</file>
			<file type="M">org.springframework.data.rest.tests.shop.ShopIntegrationTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration.java</file>
			<file type="M">org.springframework.data.rest.tests.RepositoryTestsConfig.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.RepositoryTestsConfig.java</file>
		</fixedFiles>
	</bug>
	<bug id="937" opendate="2016-11-11 19:44:22" fixdate="2016-12-06 08:49:35" resolution="Fixed">
		<buginformation>
			<summary>Transient properties in JSON should be included in merge</summary>
			<description>When using the repository domain object update end point (via the PATCH method with JSON data), fields that are not persisted (marked as @Transient or simply not marked for persistence) are not updated.
For example, given this class:






@JsonAutoDetect(fieldVisibility = Visibility.ANY)




static class SampleWithTransient {









	String name;




	@org.springframework.data.annotation.Transient String temporary;




}






if an HTTP PATCH is done to update that object with this request body:






{




  "temporary": "new temp"




}






the result will be that the value of temporary was not changed to "new temp" as expected.</description>
			<version>2.4.6 (Gosling SR6)</version>
			<fixedVersion>2.6 RC1 (Ingalls), 2.4.7 (Gosling SR7), 2.5.6 (Hopper SR6), 3.0 M2 (Kay)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.json.DomainObjectReaderUnitTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.DomainObjectReader.java</file>
		</fixedFiles>
	</bug>
	<bug id="938" opendate="2016-11-11 21:33:16" fixdate="2016-12-07 17:57:17" resolution="Fixed">
		<buginformation>
			<summary>Nested entities are replaced with new instances instead of being updated when merging</summary>
			<description>When using the repository domain object update end point (via the PATCH method with JSON data), nested objects are replaced with new instances instead of updates being applied to the existing instance.
For example, given these classes:











@JsonAutoDetect(fieldVisibility = Visibility.ANY)




static class Outer {









	String name;




	String prop;




	Inner inner;




}









@JsonAutoDetect(fieldVisibility = Visibility.ANY)




static class Inner {









	String name;




	String prop;




}






Let there be an instance of Outer like this:






Inner inner = new Inner();




inner.name = "inner name";




inner.prop = "something";




Outer outer = new Outer();




outer.prop = "else";




outer.name = "outer name";




outer.inner = inner;






Then make an HTTP PATCH request to update that object with this request body:






{ "inner" : { "name" : "new inner name" } }






the resulting Outer object should have inner.prop="something" but inner.prop is actually null.</description>
			<version>2.5.4 (Hopper SR4)</version>
			<fixedVersion>2.6 RC1 (Ingalls), 2.5.6 (Hopper SR6), 3.0 M2 (Kay)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.json.DomainObjectReaderUnitTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.DomainObjectReader.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">953</link>
			<link type="Relate" description="is related to">944</link>
		</links>
	</bug>
	<bug id="953" opendate="2016-12-06 12:39:55" fixdate="2016-12-07 17:58:13" resolution="Fixed">
		<buginformation>
			<summary>PUT empties nested collection</summary>
			<description>In the following scenario Parent and Child are entities and Item is either a Embeddable or an Entity. Only Parent has a repository that is also exported.

Posting such a structure works fine but the PUT empties the Item collection in Child. 
Please see this project to reproduce the issue - https://github.com/mduesterhoeft/sdr-put-nested-list.
Such a scenario has been working in Hopper-SR4 and started to be broken since Hopper-SR5.

Here are the requests I am issuing:

Create parent






POST /parents -&amp;gt; 201




{




    "child": {




        "items": [




          {"some": "test"}]




    }




}






update parent






PUT /parents/id -&amp;gt; 204




{




    "child": {




        "items": [




          {"some": "test123"} ]




    }




}







After the PUT the items collection is empty.</description>
			<version>2.5.5 (Hopper SR5)</version>
			<fixedVersion>2.6 RC1 (Ingalls), 2.5.6 (Hopper SR6), 3.0 M2 (Kay)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.json.DomainObjectReaderUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">944</link>
			<link type="Relate" description="is related to">938</link>
			<link type="Relate" description="is related to">954</link>
		</links>
	</bug>
	<bug id="956" opendate="2016-12-07 21:15:45" fixdate="2016-12-08 09:13:14" resolution="Fixed">
		<buginformation>
			<summary>PUT does not apply new items in nested collection</summary>
			<description>In the following scenario Parent and Child are entities and Item is either a Embeddable or an Entity. Only Parent has a repository that is also exported.

PUT updates existing items but does not add new items.
Please see this project to reproduce the issue - https://github.com/mduesterhoeft/sdr-put-nested-list. See test ParentRestIntegrationTest#should_add_new_item

Here are the requests I am issuing:

Create parent






POST /parents -&amp;gt; 201




{




    "child": {




        "items": [




          {"some": "test"}]




    }




}






update parent






PUT /parents/id -&amp;gt; 204




{




    "child": {




        "items": [




          {"some": "test123"},




          {"some": "test1235"}]




    }




}







After the PUT the items collection still has size 1.</description>
			<version>2.5.5 (Hopper SR5)</version>
			<fixedVersion>2.6 RC1 (Ingalls), 2.5.6 (Hopper SR6), 3.0 M2 (Kay)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.json.DomainObjectReaderUnitTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.DomainObjectReader.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">958</link>
		</links>
	</bug>
	<bug id="958" opendate="2016-12-08 15:12:03" fixdate="2016-12-08 16:50:49" resolution="Duplicate">
		<buginformation>
			<summary>PUT of Document with List&lt;&gt; fails to add entries post Hopper-SR5+</summary>
			<description>As demonstrated in the following project:

https://github.com/timtebeek/mongo-datarest-put-nested
https://travis-ci.org/timtebeek/mongo-datarest-put-nested

I use Spring Data Mongo with Spring Data Rest.

POST object with a single element in an array
PUT to the resulting url an updated object with two elements in array
GET the resulting url and inspect the array
https://github.com/timtebeek/mongo-datarest-put-nested/blob/master/src/test/java/com/github/timtebeek/PetProjectTest.java#L23

Under Hopper-SR4 the array is updated to now contain two elements.
Under Hopper-SR5 the array only contains the original single element.
This seems like a regression and breaks our application, leaving us stuck on Hopper-SR4 for now. Can you confirm and fix this please? </description>
			<version>2.5.5 (Hopper SR5)</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.rest.webmvc.json.DomainObjectReaderUnitTests.java</file>
			<file type="M">org.springframework.data.rest.webmvc.json.DomainObjectReader.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">956</link>
		</links>
	</bug>
</bugrepository>