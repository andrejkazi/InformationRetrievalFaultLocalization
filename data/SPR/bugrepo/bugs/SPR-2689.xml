<!-- 
RSS generated by JIRA (6.4.11#64026-sha1:78f6ec473a3f058bd5d6c30e9319c7ab376bdb9c) at Thu Dec 22 19:43:17 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://jira.spring.io/si/jira.issueviews:issue-xml/SPR-2689/SPR-2689.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>Spring JIRA</title>
    <link>https://jira.spring.io</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.4.11</version>
        <build-number>64026</build-number>
        <build-date>25-08-2015</build-date>
    </build-info>

<item>
            <title>[SPR-2689] Null check missing in JtaTransactionManager.doRegisterAfterCompletionWithJtaTransaction()</title>
                <link>https://jira.spring.io/browse/SPR-2689</link>
                <project id="10000" key="SPR">Spring Framework</project>
                    <description>&lt;p&gt;Code lines related are :&lt;br/&gt;
		if (getTransactionManager() != null) {&lt;br/&gt;
			getTransactionManager().getTransaction()....&lt;/p&gt;

&lt;p&gt;We have hit a situation were getTransactionManager() does return not null, however getTransaction() returns null.&lt;/p&gt;

&lt;p&gt;Using WebLogicJtaTransactionManager, we have an environment were JTA transactions are created for us by a different software layer, which is meant to have full control over issuing commit() or rollback() on the transaction passed to us. To guarantee this, we use &quot;PROPAGATION_MANDATORY,+Throwable&quot;&lt;/p&gt;

&lt;p&gt;Investigating the possible misbehaving code that could possibly be written in our layer, we wrote code that performs a lookup to find the inflight JTA UserTransaction, and performs a commit(). According to the UserTransaction API, that would unattach the transaction to the thread.&lt;/p&gt;

&lt;p&gt;When the application shuts down, I believe the house keeping work around this transaction ends up calling the doRegisterAfterCompletionWithJtaTransaction(), which gives NullPointerException, since getTransactionManager().getTransaction() gives null.&lt;/p&gt;

&lt;p&gt;We have put in place an easy workaround by subclassing WebLogicJtaTransactionManager and overwriting doRegisterAfterCompletionWithJtaTransaction() so that it checks for that null and either calls super.doRegister.... to resume normal processing or throws an IllegalStateException, so as to hook with the existing handling foreseen in registerAfterCompletionWithExistingTransaction(). In that way, it returns a more graceful NoTransactionException.&lt;/p&gt;

&lt;p&gt;Are we missing some config settings that could catter better for our requirement (that is, no messing with the state of the incoming, borrowed JTA transaction) ?&lt;/p&gt;</description>
            <key id="15148">SPR-2689</key>
            <summary>Null check missing in JtaTransactionManager.doRegisterAfterCompletionWithJtaTransaction()</summary>
                <type id="1" iconUrl="https://jira.spring.io/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="4" iconUrl="https://jira.spring.io/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://jira.spring.io/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="juergen.hoeller">Juergen Hoeller</assignee>
                                    <reporter username="centipede">Bill Gates</reporter>
                        <labels>
                    </labels>
                <created>Fri, 6 Oct 2006 00:11:18 +0000</created>
                <updated>Tue, 19 Jun 2012 03:50:23 +0000</updated>
                            <resolved>Fri, 6 Oct 2006 03:07:07 +0000</resolved>
                                    <version>1.2.8</version>
                    <version>2.0 final</version>
                                    <fixVersion>2.0.1</fixVersion>
                    <fixVersion>1.2.9</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="20138" author="juergen.hoeller" created="Fri, 6 Oct 2006 03:07:07 +0000"  >&lt;p&gt;Thanks for pointing this out! I&apos;ve refined JtaTransactionManager&apos;s &quot;doRegisterAfterCompletionWithJtaTransaction&quot; to avoid this NPE if no current JTA transaction is active, logging a corresponding message instead.&lt;/p&gt;

&lt;p&gt;However, I&apos;m not quite sure that the entire scenario is really valid, since &quot;TransactionManager.getTransaction()&quot; should never return null within an active transaction scope. Do you by any chance commit your JTA UserTransaction &lt;b&gt;within&lt;/b&gt; the Spring-managed transaction scope? That would lead to such a scenario and cause a null value there, but that&apos;s a illegal combination... Spring-managed transactions can participate in an &lt;b&gt;outer&lt;/b&gt; JTA transaction, but there must not be any JTA UserTransaction transaction handling &lt;b&gt;within&lt;/b&gt; a Spring-managed transaction.&lt;/p&gt;

&lt;p&gt;BTW: Instead of the &quot;-Throwable&quot; part in your PROPAGATION_MANDATORY marker (which looks a bit odd), you can just as well specify &quot;globalRollbackOnParticipationFailure&quot;=&quot;false on your JtaTransactionManager. This means that whatever kind of exception you get that would normally lead to a rollback, the rollback decision is still left to the outer transaction manager. By default, in contrast, the Spring-managed inner transaction would mark the outer transaction as rollback-only if it encounters a situation that is supposed to lead to a rollback. Even then, the actual commit/rollback call is still up to the outer transaction - but it&apos;s always gonna lead to a rollback if the inner transaction said so.&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_10180" key="com.atlassian.jira.toolkit:dayslastcommented">
                        <customfieldname>Days since last comment</customfieldname>
                        <customfieldvalues>
                                        10 years, 12 weeks, 6 days ago
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10170" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>First Response Date</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 6 Oct 2006 03:07:07 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10181" key="com.atlassian.jira.toolkit:lastusercommented">
                        <customfieldname>Last commented by a User</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>false</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10182" key="com.atlassian.jira.toolkit:lastupdaterorcommenter">
                        <customfieldname>Last updater</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>tmarshall</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10880" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i00vlz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10380" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>5166</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_10171" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>