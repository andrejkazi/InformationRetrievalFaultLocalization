<!-- 
RSS generated by JIRA (6.4.11#64026-sha1:78f6ec473a3f058bd5d6c30e9319c7ab376bdb9c) at Thu Dec 22 18:05:56 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://jira.spring.io/si/jira.issueviews:issue-xml/SPR-445/SPR-445.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>Spring JIRA</title>
    <link>https://jira.spring.io</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.4.11</version>
        <build-number>64026</build-number>
        <build-date>25-08-2015</build-date>
    </build-info>

<item>
            <title>[SPR-445] Bean property binding multi dimentional array or collection error</title>
                <link>https://jira.spring.io/browse/SPR-445</link>
                <project id="10000" key="SPR">Spring Framework</project>
                    <description>&lt;p&gt;When I tried to bind properties for multi dimensional array or nested list, I get the following error.&lt;/p&gt;

&lt;p&gt;BeanWrapperImpl does not support multi dimensional array/collection.&lt;/p&gt;

&lt;p&gt;org.springframework.beans.NullValueInNestedPathException: Invalid property &apos;data&lt;span class=&quot;error&quot;&gt;&amp;#91;InvalidUserInfoException&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;4&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;newUser&amp;#93;&lt;/span&gt;&apos; of bean class &lt;span class=&quot;error&quot;&gt;&amp;#91;com.vonage.ebt.service.smbUserManagement.AddSmbUserTest&amp;#93;&lt;/span&gt;: Value of nested property &apos;data&lt;span class=&quot;error&quot;&gt;&amp;#91;InvalidUserInfoException&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;4&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;newUser&amp;#93;&lt;/span&gt;&apos; is null&lt;br/&gt;
	at org.springframework.beans.BeanWrapperImpl.getNestedBeanWrapper(BeanWrapperImpl.java:427)&lt;br/&gt;
	at org.springframework.beans.BeanWrapperImpl.getBeanWrapperForPropertyPath(BeanWrapperImpl.java:401)&lt;br/&gt;
	at org.springframework.beans.BeanWrapperImpl.setPropertyValue(BeanWrapperImpl.java:580)&lt;br/&gt;
	at org.springframework.beans.BeanWrapperImpl.setPropertyValue(BeanWrapperImpl.java:720)&lt;br/&gt;
	at org.springframework.beans.BeanWrapperImpl.setPropertyValues(BeanWrapperImpl.java:747)&lt;br/&gt;
	at org.springframework.validation.DataBinder.bind(DataBinder.java:240)&lt;/p&gt;</description>
            <key id="10710">SPR-445</key>
            <summary>Bean property binding multi dimentional array or collection error</summary>
                <type id="1" iconUrl="https://jira.spring.io/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://jira.spring.io/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://jira.spring.io/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="juergen.hoeller">Juergen Hoeller</assignee>
                                    <reporter username="janaki_srini">Srinivas Janakiraman</reporter>
                        <labels>
                    </labels>
                <created>Thu, 4 Nov 2004 04:09:51 +0000</created>
                <updated>Mon, 8 Nov 2004 07:24:03 +0000</updated>
                            <resolved>Mon, 8 Nov 2004 07:24:03 +0000</resolved>
                                    <version>1.1 final</version>
                                    <fixVersion>1.1.2</fixVersion>
                                    <component>Core</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="11430" author="janaki_srini" created="Thu, 4 Nov 2004 10:18:33 +0000"  >&lt;p&gt;I fixed it in my local and it works fine. Following is the changed code.&lt;/p&gt;


&lt;p&gt;/*&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Copyright 2002-2004 the original author or authors.&lt;br/&gt;
 *&lt;/li&gt;
	&lt;li&gt;Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);&lt;/li&gt;
	&lt;li&gt;you may not use this file except in compliance with the License.&lt;/li&gt;
	&lt;li&gt;You may obtain a copy of the License at&lt;br/&gt;
 *&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
 *&lt;/li&gt;
	&lt;li&gt;Unless required by applicable law or agreed to in writing, software&lt;/li&gt;
	&lt;li&gt;distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;/li&gt;
	&lt;li&gt;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;/li&gt;
	&lt;li&gt;See the License for the specific language governing permissions and&lt;/li&gt;
	&lt;li&gt;limitations under the License.&lt;br/&gt;
 */&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;package org.springframework.beans;&lt;/p&gt;

&lt;p&gt;import java.beans.PropertyChangeEvent;&lt;br/&gt;
import java.beans.PropertyDescriptor;&lt;br/&gt;
import java.beans.PropertyEditor;&lt;br/&gt;
import java.beans.PropertyEditorManager;&lt;br/&gt;
import java.io.File;&lt;br/&gt;
import java.io.InputStream;&lt;br/&gt;
import java.lang.reflect.Array;&lt;br/&gt;
import java.lang.reflect.InvocationTargetException;&lt;br/&gt;
import java.lang.reflect.Method;&lt;br/&gt;
import java.math.BigDecimal;&lt;br/&gt;
import java.math.BigInteger;&lt;br/&gt;
import java.net.URL;&lt;br/&gt;
import java.util.ArrayList;&lt;br/&gt;
import java.util.Collection;&lt;br/&gt;
import java.util.HashMap;&lt;br/&gt;
import java.util.Iterator;&lt;br/&gt;
import java.util.LinkedList;&lt;br/&gt;
import java.util.List;&lt;br/&gt;
import java.util.Locale;&lt;br/&gt;
import java.util.Map;&lt;br/&gt;
import java.util.Properties;&lt;br/&gt;
import java.util.Set;&lt;/p&gt;

&lt;p&gt;import org.apache.commons.logging.Log;&lt;br/&gt;
import org.apache.commons.logging.LogFactory;&lt;/p&gt;

&lt;p&gt;import org.springframework.beans.propertyeditors.ByteArrayPropertyEditor;&lt;br/&gt;
import org.springframework.beans.propertyeditors.ClassEditor;&lt;br/&gt;
import org.springframework.beans.propertyeditors.CustomBooleanEditor;&lt;br/&gt;
import org.springframework.beans.propertyeditors.CustomNumberEditor;&lt;br/&gt;
import org.springframework.beans.propertyeditors.FileEditor;&lt;br/&gt;
import org.springframework.beans.propertyeditors.InputStreamEditor;&lt;br/&gt;
import org.springframework.beans.propertyeditors.LocaleEditor;&lt;br/&gt;
import org.springframework.beans.propertyeditors.PropertiesEditor;&lt;br/&gt;
import org.springframework.beans.propertyeditors.StringArrayPropertyEditor;&lt;br/&gt;
import org.springframework.beans.propertyeditors.URLEditor;&lt;br/&gt;
import org.springframework.util.StringUtils;&lt;/p&gt;

&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Default implementation of the BeanWrapper interface that should be sufficient&lt;/li&gt;
	&lt;li&gt;for all normal uses. Caches introspection results for efficiency.&lt;br/&gt;
 *&lt;/li&gt;
	&lt;li&gt;&amp;lt;p&amp;gt;Note: This class never tries to load a class by name, as this can pose&lt;/li&gt;
	&lt;li&gt;class loading problems in J2EE applications with multiple deployment modules.&lt;/li&gt;
	&lt;li&gt;The caller is responsible for loading a target class.&lt;br/&gt;
 *&lt;/li&gt;
	&lt;li&gt;&amp;lt;p&amp;gt;Note: Auto-registers all default property editors (not the custom ones)&lt;/li&gt;
	&lt;li&gt;in the org.springframework.beans.propertyeditors package.&lt;/li&gt;
	&lt;li&gt;Applications can either use a standard PropertyEditorManager to register a&lt;/li&gt;
	&lt;li&gt;custom editor before using a BeanWrapperImpl instance, or call the instance&apos;s&lt;/li&gt;
	&lt;li&gt;registerCustomEditor method to register an editor for the particular instance.&lt;br/&gt;
 *&lt;/li&gt;
	&lt;li&gt;&amp;lt;p&amp;gt;BeanWrapperImpl will convert List and array values to the corresponding&lt;/li&gt;
	&lt;li&gt;target arrays, if necessary. Custom property editors that deal with Lists or&lt;/li&gt;
	&lt;li&gt;arrays can be written against a comma delimited String as String arrays are&lt;/li&gt;
	&lt;li&gt;converted in such a format if the array itself is not assignable.&lt;br/&gt;
 *&lt;/li&gt;
	&lt;li&gt;@author Rod Johnson&lt;/li&gt;
	&lt;li&gt;@author Juergen Hoeller&lt;/li&gt;
	&lt;li&gt;@author Jean-Pierre Pawlak&lt;/li&gt;
	&lt;li&gt;@since 15 April 2001&lt;/li&gt;
	&lt;li&gt;@see #registerCustomEditor&lt;/li&gt;
	&lt;li&gt;@see java.beans.PropertyEditorManager&lt;/li&gt;
	&lt;li&gt;@see org.springframework.beans.propertyeditors.ClassEditor&lt;/li&gt;
	&lt;li&gt;@see org.springframework.beans.propertyeditors.FileEditor&lt;/li&gt;
	&lt;li&gt;@see org.springframework.beans.propertyeditors.LocaleEditor&lt;/li&gt;
	&lt;li&gt;@see org.springframework.beans.propertyeditors.PropertiesEditor&lt;/li&gt;
	&lt;li&gt;@see org.springframework.beans.propertyeditors.StringArrayPropertyEditor&lt;/li&gt;
	&lt;li&gt;@see org.springframework.beans.propertyeditors.URLEditor&lt;br/&gt;
 */&lt;br/&gt;
public class BeanWrapperImpl implements BeanWrapper {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;	/** We&apos;ll create a lot of these objects, so we don&apos;t want a new logger every time */&lt;br/&gt;
	private static final Log logger = LogFactory.getLog(BeanWrapperImpl.class);&lt;/p&gt;


&lt;p&gt;	//---------------------------------------------------------------------&lt;br/&gt;
	// Instance data&lt;br/&gt;
	//---------------------------------------------------------------------&lt;/p&gt;

&lt;p&gt;	/** The wrapped object */&lt;br/&gt;
	private Object object;&lt;/p&gt;

&lt;p&gt;	/** The nested path of the object */&lt;br/&gt;
	private String nestedPath = &quot;&quot;;&lt;/p&gt;

&lt;p&gt;	/** Registry for default PropertyEditors */&lt;br/&gt;
	private final Map defaultEditors;&lt;/p&gt;

&lt;p&gt;	/** Map with custom PropertyEditor instances */&lt;br/&gt;
	private Map customEditors;&lt;/p&gt;

&lt;p&gt;	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Cached introspections results for this object, to prevent encountering the cost&lt;/li&gt;
	&lt;li&gt;of JavaBeans introspection every time.&lt;br/&gt;
	 */&lt;br/&gt;
	private CachedIntrospectionResults cachedIntrospectionResults;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;	/* Map with cached nested BeanWrappers */&lt;br/&gt;
	private Map nestedBeanWrappers;&lt;/p&gt;


&lt;p&gt;	//---------------------------------------------------------------------&lt;br/&gt;
	// Constructors&lt;br/&gt;
	//---------------------------------------------------------------------&lt;/p&gt;

&lt;p&gt;	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Create new empty BeanWrapperImpl. Wrapped instance needs to be set afterwards.&lt;/li&gt;
	&lt;li&gt;@see #setWrappedInstance&lt;br/&gt;
	 */&lt;br/&gt;
	public BeanWrapperImpl() 
{
		// Register default editors in this class, for restricted environments.
		// We&apos;re not using the JRE&apos;s PropertyEditorManager to avoid potential
		// SecurityExceptions when running in a SecurityManager.
		this.defaultEditors = new HashMap(16);

		// Simple editors, without parameterization capabilities.
		this.defaultEditors.put(byte[].class, new ByteArrayPropertyEditor());
		this.defaultEditors.put(Class.class, new ClassEditor());
		this.defaultEditors.put(File.class, new FileEditor());
		this.defaultEditors.put(InputStream.class, new InputStreamEditor());
		this.defaultEditors.put(Locale.class, new LocaleEditor());
		this.defaultEditors.put(Properties.class, new PropertiesEditor());
		this.defaultEditors.put(String[].class, new StringArrayPropertyEditor());
		this.defaultEditors.put(URL.class, new URLEditor());

		// Default instances of parameterizable editors.
		// Can be overridden by registering custom instances of those as custom editors.
		this.defaultEditors.put(Boolean.class, new CustomBooleanEditor(false));
		this.defaultEditors.put(Short.class, new CustomNumberEditor(Short.class, false));
		this.defaultEditors.put(Integer.class, new CustomNumberEditor(Integer.class, false));
		this.defaultEditors.put(Long.class, new CustomNumberEditor(Long.class, false));
		this.defaultEditors.put(BigInteger.class, new CustomNumberEditor(BigInteger.class, false));
		this.defaultEditors.put(Float.class, new CustomNumberEditor(Float.class, false));
		this.defaultEditors.put(Double.class, new CustomNumberEditor(Double.class, false));
		this.defaultEditors.put(BigDecimal.class, new CustomNumberEditor(BigDecimal.class, false));
	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Create new BeanWrapperImpl for the given object.&lt;/li&gt;
	&lt;li&gt;@param object object wrapped by this BeanWrapper&lt;br/&gt;
	 */&lt;br/&gt;
	public BeanWrapperImpl(Object object) 
{
		this();
		setWrappedInstance(object);
	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Create new BeanWrapperImpl, wrapping a new instance of the specified class.&lt;/li&gt;
	&lt;li&gt;@param clazz class to instantiate and wrap&lt;br/&gt;
	 */&lt;br/&gt;
	public BeanWrapperImpl(Class clazz) 
{
		this();
		setWrappedInstance(BeanUtils.instantiateClass(clazz));
	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Create new BeanWrapperImpl for the given object,&lt;/li&gt;
	&lt;li&gt;registering a nested path that the object is in.&lt;/li&gt;
	&lt;li&gt;@param object object wrapped by this BeanWrapper.&lt;/li&gt;
	&lt;li&gt;@param nestedPath the nested path of the object&lt;br/&gt;
	 */&lt;br/&gt;
	public BeanWrapperImpl(Object object, String nestedPath) 
{
		this();
		setWrappedInstance(object, nestedPath);
	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Create new BeanWrapperImpl for the given object,&lt;/li&gt;
	&lt;li&gt;registering a nested path that the object is in.&lt;/li&gt;
	&lt;li&gt;@param object object wrapped by this BeanWrapper.&lt;/li&gt;
	&lt;li&gt;@param nestedPath the nested path of the object&lt;/li&gt;
	&lt;li&gt;@param superBw the containing BeanWrapper (must not be null)&lt;br/&gt;
	 */&lt;br/&gt;
	private BeanWrapperImpl(Object object, String nestedPath, BeanWrapperImpl superBw) 
{
		this.defaultEditors = superBw.defaultEditors;
		setWrappedInstance(object, nestedPath);
	}&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;	//---------------------------------------------------------------------&lt;br/&gt;
	// Implementation of BeanWrapper&lt;br/&gt;
	//---------------------------------------------------------------------&lt;/p&gt;

&lt;p&gt;	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Switch the target object, replacing the cached introspection results only&lt;/li&gt;
	&lt;li&gt;if the class of the new object is different to that of the replaced object.&lt;/li&gt;
	&lt;li&gt;@param object new target&lt;br/&gt;
	 */&lt;br/&gt;
	public void setWrappedInstance(Object object) 
{
		setWrappedInstance(object, &quot;&quot;);
	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Switch the target object, replacing the cached introspection results only&lt;/li&gt;
	&lt;li&gt;if the class of the new object is different to that of the replaced object.&lt;/li&gt;
	&lt;li&gt;@param object new target&lt;/li&gt;
	&lt;li&gt;@param nestedPath the nested path of the object&lt;br/&gt;
	 */&lt;br/&gt;
	public void setWrappedInstance(Object object, String nestedPath) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {		if (object == null) {
			throw new IllegalArgumentException(&quot;Cannot set BeanWrapperImpl target to a null object&quot;);
		}		this.object = object;		this.nestedPath = nestedPath;		this.nestedBeanWrappers = null;		setIntrospectionClass(object.getClass());	}&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;	public Object getWrappedInstance() &lt;/p&gt;
{
		return this.object;
	}

&lt;p&gt;	public Class getWrappedClass() &lt;/p&gt;
{
		return this.object.getClass();
	}

&lt;p&gt;	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Set the class to introspect.&lt;/li&gt;
	&lt;li&gt;Needs to be called when the target object changes.&lt;/li&gt;
	&lt;li&gt;@param clazz the class to introspect&lt;br/&gt;
	 */&lt;br/&gt;
	protected void setIntrospectionClass(Class clazz) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {		if (this.cachedIntrospectionResults == null ||		    !this.cachedIntrospectionResults.getBeanClass().equals(clazz)) {
			this.cachedIntrospectionResults = CachedIntrospectionResults.forClass(clazz);
		}	}&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;	public void registerCustomEditor(Class requiredType, PropertyEditor propertyEditor) &lt;/p&gt;
{
		registerCustomEditor(requiredType, null, propertyEditor);
	}

&lt;p&gt;	public void registerCustomEditor(Class requiredType, String propertyPath, PropertyEditor propertyEditor) {&lt;br/&gt;
		if (requiredType == null &amp;amp;&amp;amp; propertyPath == null) &lt;/p&gt;
{
			throw new IllegalArgumentException(&quot;Either requiredType or propertyPath is required&quot;);
		}
&lt;p&gt;		if (this.customEditors == null) &lt;/p&gt;
{
			this.customEditors = new HashMap();
		}
&lt;p&gt;		if (propertyPath != null) &lt;/p&gt;
{
			this.customEditors.put(propertyPath, new CustomEditorHolder(propertyEditor, requiredType));
		}
&lt;p&gt;		else &lt;/p&gt;
{
			this.customEditors.put(requiredType, propertyEditor);
		}
&lt;p&gt;	}&lt;/p&gt;

&lt;p&gt;	public PropertyEditor findCustomEditor(Class requiredType, String propertyPath) {&lt;br/&gt;
		if (this.customEditors == null) &lt;/p&gt;
{
			return null;
		}
&lt;p&gt;		if (propertyPath != null) {&lt;br/&gt;
			// check property-specific editor first&lt;br/&gt;
			PropertyEditor editor = getCustomEditor(propertyPath, requiredType);&lt;br/&gt;
			if (editor == null) {&lt;br/&gt;
				List strippedPaths = new LinkedList();&lt;br/&gt;
				addStrippedPropertyPaths(strippedPaths, &quot;&quot;, propertyPath);&lt;br/&gt;
				for (Iterator it = strippedPaths.iterator(); it.hasNext() &amp;amp;&amp;amp; editor == null&lt;img class=&quot;emoticon&quot; src=&quot;https://jira.spring.io/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; &lt;/p&gt;
{
					String strippedPath = (String) it.next();
					editor = getCustomEditor(strippedPath, requiredType);
				}
&lt;p&gt;			}&lt;br/&gt;
			if (editor != null) &lt;/p&gt;
{
				return editor;
			}
&lt;p&gt;			else if (requiredType == null) &lt;/p&gt;
{
				requiredType = getPropertyType(propertyPath);
			}
&lt;p&gt;		}&lt;br/&gt;
		// no property-specific editor -&amp;gt; check type-specific editor&lt;br/&gt;
		return getCustomEditor(requiredType);&lt;br/&gt;
	}&lt;/p&gt;

&lt;p&gt;	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Get custom editor that has been registered for the given property.&lt;/li&gt;
	&lt;li&gt;@return the custom editor, or null if none specific for this property&lt;br/&gt;
	 */&lt;br/&gt;
	private PropertyEditor getCustomEditor(String propertyName, Class requiredType) 
{
		CustomEditorHolder holder = (CustomEditorHolder) this.customEditors.get(propertyName);
		return (holder != null ? holder.getPropertyEditor(requiredType) : null);
	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Get custom editor for the given type. If no direct match found,&lt;/li&gt;
	&lt;li&gt;try custom editor for superclass (which will in any case be able&lt;/li&gt;
	&lt;li&gt;to render a value as String via &amp;lt;code&amp;gt;getAsText&amp;lt;/code&amp;gt;).&lt;/li&gt;
	&lt;li&gt;@see java.beans.PropertyEditor#getAsText&lt;/li&gt;
	&lt;li&gt;@return the custom editor, or null if none found for this type&lt;br/&gt;
	 */&lt;br/&gt;
	private PropertyEditor getCustomEditor(Class requiredType) {&lt;br/&gt;
		if (requiredType != null) {&lt;br/&gt;
			PropertyEditor editor = (PropertyEditor) this.customEditors.get(requiredType);&lt;br/&gt;
			if (editor == null) {&lt;br/&gt;
				for (Iterator it = this.customEditors.keySet().iterator(); it.hasNext()&lt;img class=&quot;emoticon&quot; src=&quot;https://jira.spring.io/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {					Object key = it.next();					if (key instanceof Class &amp;amp;&amp;amp; ((Class) key).isAssignableFrom(requiredType)) {
						editor = (PropertyEditor) this.customEditors.get(key);
					}				}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;			}&lt;br/&gt;
			return editor;&lt;br/&gt;
		}&lt;br/&gt;
		return null;&lt;br/&gt;
	}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Add property paths with all variations of stripped keys and/or indexes.&lt;/li&gt;
	&lt;li&gt;Invokes itself recursively with nested paths&lt;/li&gt;
	&lt;li&gt;@param strippedPaths the result list to add to&lt;/li&gt;
	&lt;li&gt;@param nestedPath the current nested path&lt;/li&gt;
	&lt;li&gt;@param propertyPath the property path to check for keys/indexes to strip&lt;br/&gt;
	 */&lt;br/&gt;
	private void addStrippedPropertyPaths(List strippedPaths, String nestedPath, String propertyPath) {&lt;br/&gt;
		int startIndex = propertyPath.indexOf(PROPERTY_KEY_PREFIX_CHAR);&lt;br/&gt;
		if (startIndex != -1) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {			int endIndex = propertyPath.indexOf(PROPERTY_KEY_SUFFIX_CHAR);			if (endIndex != -1) {
				String prefix = propertyPath.substring(0, startIndex);
				String key = propertyPath.substring(startIndex, endIndex + 1);
				String suffix = propertyPath.substring(endIndex + 1, propertyPath.length());
				// strip the first key
				strippedPaths.add(nestedPath + prefix + suffix);
				// search for further keys to strip, with the first key stripped
				addStrippedPropertyPaths(strippedPaths, nestedPath + prefix, suffix);
				// search for further keys to strip, with the first key not stripped
				addStrippedPropertyPaths(strippedPaths, nestedPath + prefix + key, suffix);
			}		}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;	}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Determine the first respectively last nested property separator in&lt;/li&gt;
	&lt;li&gt;the given property path, ignoring dots in keys (like &quot;map&lt;span class=&quot;error&quot;&gt;&amp;#91;my.key&amp;#93;&lt;/span&gt;&quot;).&lt;/li&gt;
	&lt;li&gt;@param propertyPath the property path to check&lt;/li&gt;
	&lt;li&gt;@param last whether to return the last separator rather than the first&lt;/li&gt;
	&lt;li&gt;@return the index of the nested property separator, or -1 if none&lt;br/&gt;
	 */&lt;br/&gt;
	private int getNestedPropertySeparatorIndex(String propertyPath, boolean last) {&lt;br/&gt;
		boolean inKey = false;&lt;br/&gt;
		int i = (last ? propertyPath.length()-1 : 0);&lt;br/&gt;
		while ((last &amp;amp;&amp;amp; i &amp;gt;= 0) || i &amp;lt; propertyPath.length()) {&lt;br/&gt;
			switch (propertyPath.charAt&lt;img class=&quot;emoticon&quot; src=&quot;https://jira.spring.io/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {				case PROPERTY_KEY_PREFIX_CHAR}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;			if (last) i--; else i++;&lt;br/&gt;
		}&lt;br/&gt;
		return -1;&lt;br/&gt;
	}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Get the last component of the path. Also works if not nested.&lt;/li&gt;
	&lt;li&gt;@param bw BeanWrapper to work on&lt;/li&gt;
	&lt;li&gt;@param nestedPath property path we know is nested&lt;/li&gt;
	&lt;li&gt;@return last component of the path (the property on the target bean)&lt;br/&gt;
	 */&lt;br/&gt;
	private String getFinalPath(BeanWrapper bw, String nestedPath) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {		if (bw == this) {
			return nestedPath;
		}		return nestedPath.substring(getNestedPropertySeparatorIndex(nestedPath, true) + 1);	}&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Recursively navigate to return a BeanWrapper for the nested property path.&lt;/li&gt;
	&lt;li&gt;@param propertyPath property property path, which may be nested&lt;/li&gt;
	&lt;li&gt;@return a BeanWrapper for the target bean&lt;br/&gt;
	 */&lt;br/&gt;
	protected BeanWrapperImpl getBeanWrapperForPropertyPath(String propertyPath) throws BeansException 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {		int pos = getNestedPropertySeparatorIndex(propertyPath, false);		// handle nested properties recursively		if (pos &amp;gt; -1) {
			String nestedProperty = propertyPath.substring(0, pos);
			String nestedPath = propertyPath.substring(pos + 1);
			BeanWrapperImpl nestedBw = getNestedBeanWrapper(nestedProperty);
			return nestedBw.getBeanWrapperForPropertyPath(nestedPath);
		}		else {
			return this;
		}	}&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Retrieve a BeanWrapper for the given nested property.&lt;/li&gt;
	&lt;li&gt;Create a new one if not found in the cache.&lt;/li&gt;
	&lt;li&gt;&amp;lt;p&amp;gt;Note: Caching nested BeanWrappers is necessary now,&lt;/li&gt;
	&lt;li&gt;to keep registered custom editors for nested properties.&lt;/li&gt;
	&lt;li&gt;@param nestedProperty property to create the BeanWrapper for&lt;/li&gt;
	&lt;li&gt;@return the BeanWrapper instance, either cached or newly created&lt;br/&gt;
	 */&lt;br/&gt;
	private BeanWrapperImpl getNestedBeanWrapper(String nestedProperty) throws BeansException {&lt;br/&gt;
		if (this.nestedBeanWrappers == null) 
{
			this.nestedBeanWrappers = new HashMap();
		}
&lt;p&gt;		// get value of bean property&lt;br/&gt;
		String[] tokens = getPropertyNameTokens(nestedProperty);&lt;br/&gt;
        BeanWrapperImpl wrapper = null;&lt;br/&gt;
        Object propertyValue = null;&lt;br/&gt;
        for(int i = 2 ; i &amp;lt; tokens.length ; i++)&lt;/p&gt;
        &lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {            if(wrapper == null)            {
                propertyValue = getPropertyValue(tokens[0], tokens[1], tokens[i]);
            }&lt;br/&gt;
            else&lt;br/&gt;
            {
                propertyValue = wrapper.getPropertyValue(tokens[i],&quot;&quot;,tokens[i]);
            }&lt;br/&gt;
            wrapper = new BeanWrapperImpl(propertyValue);&lt;br/&gt;
        }&lt;br/&gt;
		String canonicalName = tokens&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;;&lt;br/&gt;
		String propertyName = tokens&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;;&lt;br/&gt;
		if (propertyValue == null) {
			throw new NullValueInNestedPathException(getWrappedClass(), this.nestedPath + canonicalName);
		}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
		// lookup cached sub-BeanWrapper, create new one if not found&lt;br/&gt;
		BeanWrapperImpl nestedBw = (BeanWrapperImpl) this.nestedBeanWrappers.get(canonicalName);&lt;br/&gt;
		if (nestedBw == null || nestedBw.getWrappedInstance() != propertyValue) {&lt;br/&gt;
			if (logger.isDebugEnabled()) {
				logger.debug(&quot;Creating new nested BeanWrapper for property &apos;&quot; + canonicalName + &quot;&apos;&quot;);
			}&lt;br/&gt;
			nestedBw = new BeanWrapperImpl(&lt;br/&gt;
					propertyValue, this.nestedPath + canonicalName + NESTED_PROPERTY_SEPARATOR, this);&lt;br/&gt;
			// inherit all type-specific PropertyEditors&lt;br/&gt;
			if (this.customEditors != null) {&lt;br/&gt;
				for (Iterator it = this.customEditors.entrySet().iterator(); it.hasNext()&lt;img class=&quot;emoticon&quot; src=&quot;https://jira.spring.io/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; {&lt;br/&gt;
					Map.Entry entry = (Map.Entry) it.next();&lt;br/&gt;
					if (entry.getKey() instanceof Class) {
						Class requiredType = (Class) entry.getKey();
						PropertyEditor editor = (PropertyEditor) entry.getValue();
						nestedBw.registerCustomEditor(requiredType, editor);
					}&lt;br/&gt;
					else if (entry.getKey() instanceof String) {&lt;br/&gt;
						String editorPath = (String) entry.getKey();&lt;br/&gt;
						int pos = getNestedPropertySeparatorIndex(editorPath, false);&lt;br/&gt;
						if (pos != -1) {&lt;br/&gt;
							String editorNestedProperty = editorPath.substring(0, pos);&lt;br/&gt;
							String editorNestedPath = editorPath.substring(pos + 1);&lt;br/&gt;
							if (editorNestedProperty.equals(canonicalName) || editorNestedProperty.equals(propertyName)) {
								CustomEditorHolder editorHolder = (CustomEditorHolder) entry.getValue();
								nestedBw.registerCustomEditor(
										editorHolder.getRegisteredType(), editorNestedPath, editorHolder.getPropertyEditor());
							}&lt;br/&gt;
						}&lt;br/&gt;
					}&lt;br/&gt;
				}&lt;br/&gt;
			}&lt;br/&gt;
			this.nestedBeanWrappers.put(canonicalName, nestedBw);&lt;br/&gt;
		}&lt;br/&gt;
		else {&lt;br/&gt;
			if (logger.isDebugEnabled()) {
				logger.debug(&quot;Using cached nested BeanWrapper for property &apos;&quot; + canonicalName + &quot;&apos;&quot;);
			}&lt;br/&gt;
		}&lt;br/&gt;
		return nestedBw;&lt;br/&gt;
	}&lt;br/&gt;
&lt;br/&gt;
	private String[] getPropertyNameTokens(String propertyName) {&lt;br/&gt;
		String actualName = propertyName;&lt;br/&gt;
		String key = null;&lt;br/&gt;
        ArrayList keys = new ArrayList();&lt;br/&gt;
&lt;br/&gt;
		int keyStart = propertyName.indexOf(PROPERTY_KEY_PREFIX);&lt;br/&gt;
&lt;br/&gt;
		while (keyStart != -1) {&lt;br/&gt;
            if(actualName.equals(propertyName))&lt;br/&gt;
    			actualName = propertyName.substring(0, keyStart);&lt;br/&gt;
			String key1 = propertyName.substring(keyStart + 1, propertyName.length() - 1);&lt;br/&gt;
			if (key1.startsWith(&quot;&apos;&quot;)) {
                int endQuoteIdx = propertyName.indexOf(&quot;&apos;&quot;, keyStart + 2);
                if(endQuoteIdx == -1)
                    throw new InvalidPropertyException(this.getWrappedClass(),propertyName,&quot;&apos;s are not matching.&quot;);
				key = propertyName.substring(keyStart + 2, endQuoteIdx - 1);
                if(propertyName.charAt(endQuoteIdx+1) != PROPERTY_KEY_SUFFIX_CHAR)
                    throw new InvalidPropertyException(this.getWrappedClass(),propertyName,&quot;Property name has &apos; .&quot;);
                keyStart = propertyName.indexOf(PROPERTY_KEY_PREFIX, endQuoteIdx);
                keys.add(key);
			}&lt;br/&gt;
			else if (key1.startsWith(&quot;\&quot;&quot;)) {
                int endQuoteIdx = propertyName.indexOf(&quot;\&quot;&quot;, keyStart + 2);
                if(endQuoteIdx == -1)
                    throw new InvalidPropertyException(this.getWrappedClass(),propertyName,&quot;\&quot;s are not matching.&quot;);
				key = propertyName.substring(keyStart + 2, endQuoteIdx - 1);
                if(propertyName.charAt(endQuoteIdx+1) != PROPERTY_KEY_SUFFIX_CHAR)
                    throw new InvalidPropertyException(this.getWrappedClass(),propertyName,&quot;Property name has \&quot; .&quot;);
                keyStart = propertyName.indexOf(PROPERTY_KEY_PREFIX, endQuoteIdx);
                keys.add(key);
			}&lt;br/&gt;
            else&lt;br/&gt;
            {
                int keyEnd = propertyName.indexOf(PROPERTY_KEY_SUFFIX, keyStart + 1);
                if(keyEnd == -1)
                    throw new InvalidPropertyException(this.getWrappedClass(),propertyName,&quot;[] are not matching.&quot;);
                key = propertyName.substring(keyStart + 1, keyEnd);
                keys.add(key);
                keyStart = propertyName.indexOf(PROPERTY_KEY_PREFIX, keyEnd);
            }&lt;br/&gt;
		}&lt;br/&gt;
		String canonicalName = actualName;&lt;br/&gt;
        String[] ret = new String&lt;span class=&quot;error&quot;&gt;&amp;#91;keys.size()+2&amp;#93;&lt;/span&gt;;&lt;br/&gt;
        if(keys.isEmpty())&lt;br/&gt;
        {
            ret = new String[keys.size()+3];
            ret[2] = null;
        }&lt;br/&gt;
        else&lt;br/&gt;
        {&lt;br/&gt;
            ret = new String&lt;span class=&quot;error&quot;&gt;&amp;#91;keys.size()+2&amp;#93;&lt;/span&gt;;&lt;br/&gt;
            for(int i = 0 ; i &amp;lt; keys.size() ; i++) {
                canonicalName += PROPERTY_KEY_PREFIX + keys.get(i) + PROPERTY_KEY_SUFFIX;
                ret[i+2] = (String)keys.get(i);
            }&lt;br/&gt;
        }&lt;br/&gt;
        ret&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; = canonicalName;&lt;br/&gt;
        ret&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; = actualName;&lt;br/&gt;
		return ret;&lt;br/&gt;
	}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
	public Object getPropertyValue(String propertyName) throws BeansException {&lt;br/&gt;
		BeanWrapperImpl nestedBw = getBeanWrapperForPropertyPath(propertyName);&lt;br/&gt;
		String[] tokens = getPropertyNameTokens(getFinalPath(nestedBw, propertyName));&lt;br/&gt;
        BeanWrapperImpl wrapper = null;&lt;br/&gt;
        Object propertyValue = null;&lt;br/&gt;
        for(int i = 2 ; i &amp;lt; tokens.length ; i++)&lt;br/&gt;
        {&lt;br/&gt;
            if(wrapper == null)&lt;br/&gt;
            {                propertyValue = getPropertyValue(tokens[0], tokens[1], tokens[i]);            }            else            {
                propertyValue = wrapper.getPropertyValue(tokens[i],&quot;&quot;,tokens[i]);
            }            wrapper = new BeanWrapperImpl(propertyValue);        }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;		return propertyValue;&lt;br/&gt;
	}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;	protected Object getPropertyValue(String propertyName, String actualName, String key) throws BeansException {&lt;br/&gt;
        Object value = null;&lt;br/&gt;
        PropertyDescriptor pd = null;&lt;br/&gt;
        if(actualName != null &amp;amp;&amp;amp; actualName.length() != 0)&lt;br/&gt;
        {&lt;br/&gt;
            pd = getPropertyDescriptorInternal(actualName);&lt;br/&gt;
            if (pd == null || pd.getReadMethod() == null) &lt;/p&gt;
{
                throw new NotReadablePropertyException(getWrappedClass(), this.nestedPath + propertyName);
            }
&lt;p&gt;            if (logger.isDebugEnabled())&lt;br/&gt;
                logger.debug(&quot;About to invoke read method &lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot; + pd.getReadMethod() + &amp;quot;&amp;#93;&lt;/span&gt; on object of class [&quot; +&lt;br/&gt;
                        this.object.getClass().getName() + &quot;]&quot;);&lt;br/&gt;
        }&lt;br/&gt;
        else&lt;br/&gt;
            if(key == null || key.length() == 0)&lt;br/&gt;
                throw new InvalidPropertyException(getWrappedClass(),this.nestedPath+propertyName,&quot;Both actual name and key are empty.&quot;);&lt;br/&gt;
            else&lt;/p&gt;
            {
                value = this.getWrappedInstance();
            }
&lt;p&gt;		try {&lt;br/&gt;
            if(pd != null)&lt;br/&gt;
    			value = pd.getReadMethod().invoke(this.object, null);&lt;br/&gt;
			if (key != null) {&lt;br/&gt;
				if (value == null) &lt;/p&gt;
{
					throw new NullValueInNestedPathException(
							getWrappedClass(), this.nestedPath + propertyName,
							&quot;Cannot access indexed value of property referenced in indexed &quot; +
							&quot;property path &apos;&quot; + propertyName + &quot;&apos;: returned null&quot;);
				}
&lt;p&gt;				else if (value.getClass().isArray()) &lt;/p&gt;
{
					return Array.get(value, Integer.parseInt(key));
				}
&lt;p&gt;				else if (value instanceof List) &lt;/p&gt;
{
					List list = (List) value;
					return list.get(Integer.parseInt(key));
				}
&lt;p&gt;				else if (value instanceof Set) {&lt;br/&gt;
					// apply index to Iterator in case of a Set&lt;br/&gt;
					Set set = (Set) value;&lt;br/&gt;
					int index = Integer.parseInt(key);&lt;br/&gt;
					Iterator it = set.iterator();&lt;br/&gt;
					for (int i = 0; it.hasNext(); i++) {&lt;br/&gt;
						Object elem = it.next();&lt;br/&gt;
						if (i == index) &lt;/p&gt;
{
							return elem;
						}
&lt;p&gt;					}&lt;br/&gt;
					throw new InvalidPropertyException(&lt;br/&gt;
							getWrappedClass(), this.nestedPath + propertyName,&lt;br/&gt;
							&quot;Cannot get element with index &quot; + index + &quot; from Set of size &quot; +&lt;br/&gt;
							set.size() + &quot;, accessed using property path &apos;&quot; + propertyName + &quot;&apos;&quot;);&lt;br/&gt;
				}&lt;br/&gt;
				else if (value instanceof Map) &lt;/p&gt;
{
					Map map = (Map) value;
					return map.get(key);
				}
&lt;p&gt;				else &lt;/p&gt;
{
					throw new InvalidPropertyException(
							getWrappedClass(), this.nestedPath + propertyName,
							&quot;Property referenced in indexed property path &apos;&quot; + propertyName +
							&quot;&apos; is neither an array nor a List nor a Map; returned value was [&quot; + value + &quot;]&quot;);
				}
&lt;p&gt;			}&lt;br/&gt;
			else &lt;/p&gt;
{
				return value;
			}
&lt;p&gt;		}&lt;br/&gt;
		catch (InvocationTargetException ex) &lt;/p&gt;
{
			throw new InvalidPropertyException(
					getWrappedClass(), this.nestedPath + propertyName,
					&quot;Getter for property &apos;&quot; + actualName + &quot;&apos; threw exception&quot;, ex);
		}
&lt;p&gt;		catch (IllegalAccessException ex) &lt;/p&gt;
{
			throw new InvalidPropertyException(
					getWrappedClass(), this.nestedPath + propertyName,
					&quot;Illegal attempt to get property &apos;&quot; + actualName + &quot;&apos; threw exception&quot;, ex);
		}
&lt;p&gt;		catch (IndexOutOfBoundsException ex) &lt;/p&gt;
{
			throw new InvalidPropertyException(
					getWrappedClass(), this.nestedPath + propertyName,
					&quot;Index of out of bounds in property path &apos;&quot; + propertyName + &quot;&apos;&quot;, ex);
		}
&lt;p&gt;		catch (NumberFormatException ex) &lt;/p&gt;
{
			throw new InvalidPropertyException(
					getWrappedClass(), this.nestedPath + propertyName,
					&quot;Invalid index in property path &apos;&quot; + propertyName + &quot;&apos;&quot;, ex);
		}
&lt;p&gt;	}&lt;/p&gt;

&lt;p&gt;	public void setPropertyValue(String propertyName, Object value) throws BeansException {&lt;br/&gt;
		BeanWrapperImpl nestedBw = null;&lt;br/&gt;
		try &lt;/p&gt;
{
			nestedBw = getBeanWrapperForPropertyPath(propertyName);
		}
&lt;p&gt;		catch (NotReadablePropertyException ex) &lt;/p&gt;
{
			throw new NotWritablePropertyException(
					getWrappedClass(), this.nestedPath + propertyName,
					&quot;Nested property in path &apos;&quot; + propertyName + &quot;&apos; does not exist&quot;, ex);
		}
&lt;p&gt;		String[] tokens = getPropertyNameTokens(getFinalPath(nestedBw, propertyName));&lt;br/&gt;
        String actualName = tokens&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;;&lt;br/&gt;
        String key = tokens&lt;span class=&quot;error&quot;&gt;&amp;#91;tokens.length-1&amp;#93;&lt;/span&gt;;&lt;br/&gt;
        for(int i = 2 ; i &amp;lt; tokens.length-1 ; i++)&lt;br/&gt;
            actualName = actualName + tokens&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt;;&lt;br/&gt;
		nestedBw.setPropertyValue(tokens&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;, actualName, key, value);&lt;br/&gt;
	}&lt;/p&gt;

&lt;p&gt;	protected void setPropertyValue(String propertyName, String actualName, String key, Object value)&lt;br/&gt;
			throws BeansException {&lt;/p&gt;

&lt;p&gt;		if (key != null) {&lt;br/&gt;
			Object propValue = null;&lt;br/&gt;
			try &lt;/p&gt;
{
				propValue = getPropertyValue(actualName);
			}
&lt;p&gt;			catch (NotReadablePropertyException ex) &lt;/p&gt;
{
				throw new NotWritablePropertyException(
						getWrappedClass(), this.nestedPath + propertyName,
						&quot;Cannot access indexed value in property referenced &quot; +
						&quot;in indexed property path &apos;&quot; + propertyName + &quot;&apos;&quot;, ex);
			}
&lt;p&gt;			if (propValue == null) &lt;/p&gt;
{
				throw new NullValueInNestedPathException(
						getWrappedClass(), this.nestedPath + propertyName,
						&quot;Cannot access indexed value in property referenced &quot; +
						&quot;in indexed property path &apos;&quot; + propertyName + &quot;&apos;: returned null&quot;);
			}
&lt;p&gt;			else if (propValue.getClass().isArray()) {&lt;br/&gt;
				Class requiredType = propValue.getClass().getComponentType();&lt;br/&gt;
				Object newValue = doTypeConversionIfNecessary(propertyName, propertyName, null, value, requiredType);&lt;br/&gt;
				try &lt;/p&gt;
{
					Array.set(propValue, Integer.parseInt(key), newValue);
				}
&lt;p&gt;				catch (IllegalArgumentException ex) &lt;/p&gt;
{
					PropertyChangeEvent pce = new PropertyChangeEvent(
							this.object, this.nestedPath + propertyName, null, newValue);
					throw new TypeMismatchException(pce, requiredType, ex);
				}
&lt;p&gt;				catch (IndexOutOfBoundsException ex) &lt;/p&gt;
{
					throw new InvalidPropertyException(
							getWrappedClass(), this.nestedPath + propertyName,
							&quot;Invalid array index in property path &apos;&quot; + propertyName + &quot;&apos;&quot;, ex);
				}
&lt;p&gt;			}&lt;br/&gt;
			else if (propValue instanceof List) {&lt;br/&gt;
				Object newValue = doTypeConversionIfNecessary(propertyName, propertyName, null, value, null);&lt;br/&gt;
				List list = (List) propValue;&lt;br/&gt;
				int index = Integer.parseInt(key);&lt;br/&gt;
				if (index &amp;lt; list.size()) &lt;/p&gt;
{
					list.set(index, newValue);
				}
&lt;p&gt;				else if (index &amp;gt;= list.size()) {&lt;br/&gt;
					for (int i = list.size(); i &amp;lt; index; i++) {&lt;br/&gt;
						try &lt;/p&gt;
{
							list.add(null);
						}
&lt;p&gt;						catch (NullPointerException ex) &lt;/p&gt;
{
							throw new InvalidPropertyException(
									getWrappedClass(), this.nestedPath + propertyName,
									&quot;Cannot set element with index &quot; + index + &quot; in List of size &quot; +
									list.size() + &quot;, accessed using property path &apos;&quot; + propertyName +
									&quot;&apos;: List does not support filling up gaps with null elements&quot;);
						}
&lt;p&gt;					}&lt;br/&gt;
					list.add(newValue);&lt;br/&gt;
				}&lt;br/&gt;
			}&lt;br/&gt;
			else if (propValue instanceof Map) &lt;/p&gt;
{
				Object newValue = doTypeConversionIfNecessary(propertyName, propertyName, null, value, null);
				Map map = (Map) propValue;
				map.put(key, newValue);
			}
&lt;p&gt;			else &lt;/p&gt;
{
				throw new InvalidPropertyException(
						getWrappedClass(), this.nestedPath + propertyName,
						&quot;Property referenced in indexed property path &apos;&quot; + propertyName +
						&quot;&apos; is neither an array nor a List nor a Map; returned value was [&quot; + value + &quot;]&quot;);
			}
&lt;p&gt;		}&lt;/p&gt;

&lt;p&gt;		else {&lt;br/&gt;
			if (!isWritableProperty(propertyName)) &lt;/p&gt;
{
				throw new NotWritablePropertyException(getWrappedClass(), this.nestedPath + propertyName);
			}
&lt;p&gt;			PropertyDescriptor pd = getPropertyDescriptor(propertyName);&lt;br/&gt;
			Method writeMethod = pd.getWriteMethod();&lt;br/&gt;
			Object newValue = null;&lt;br/&gt;
			try {&lt;br/&gt;
				// old value may still be null&lt;br/&gt;
				newValue = doTypeConversionIfNecessary(propertyName, propertyName, null, value, pd.getPropertyType());&lt;/p&gt;

&lt;p&gt;				if (pd.getPropertyType().isPrimitive() &amp;amp;&amp;amp; (newValue == null || &quot;&quot;.equals(newValue))) &lt;/p&gt;
{
					throw new IllegalArgumentException(&quot;Invalid value [&quot; + value + &quot;] for property &apos;&quot; +
								pd.getName() + &quot;&apos; of primitive type [&quot; + pd.getPropertyType() + &quot;]&quot;);
				}

&lt;p&gt;				if (logger.isDebugEnabled()) &lt;/p&gt;
{
					logger.debug(&quot;About to invoke write method [&quot; + writeMethod + &quot;] on object of class [&quot; +
							this.object.getClass().getName() + &quot;]&quot;);
				}
&lt;p&gt;				writeMethod.invoke(this.object, new Object[] &lt;/p&gt;
{ newValue }
&lt;p&gt;);&lt;br/&gt;
				if (logger.isDebugEnabled()) {&lt;br/&gt;
					String msg = &quot;Invoked write method &lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot; + writeMethod + &amp;quot;&amp;#93;&lt;/span&gt; with value &quot;;&lt;br/&gt;
					// only cause toString invocation of new value in case of simple property&lt;br/&gt;
					if (newValue == null || BeanUtils.isSimpleProperty(pd.getPropertyType())) &lt;/p&gt;
{
						logger.debug(msg + PROPERTY_KEY_PREFIX + newValue + PROPERTY_KEY_SUFFIX);
					}
&lt;p&gt;					else &lt;/p&gt;
{
						logger.debug(msg + &quot;of type [&quot; + pd.getPropertyType().getName() + &quot;]&quot;);
					}
&lt;p&gt;				}&lt;br/&gt;
			}&lt;br/&gt;
			catch (InvocationTargetException ex) {&lt;br/&gt;
				PropertyChangeEvent propertyChangeEvent =&lt;br/&gt;
						new PropertyChangeEvent(this.object, this.nestedPath + propertyName, null, value);&lt;br/&gt;
				if (ex.getTargetException() instanceof ClassCastException) &lt;/p&gt;
{
					throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());
				}
&lt;p&gt;				else &lt;/p&gt;
{
					throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());
				}
&lt;p&gt;			}&lt;br/&gt;
			catch (IllegalArgumentException ex) &lt;/p&gt;
{
				PropertyChangeEvent pce =
						new PropertyChangeEvent(this.object, this.nestedPath + propertyName, null, value);
				throw new TypeMismatchException(pce, pd.getPropertyType(), ex);
			}
&lt;p&gt;			catch (IllegalAccessException ex) &lt;/p&gt;
{
				PropertyChangeEvent pce =
						new PropertyChangeEvent(this.object, this.nestedPath + propertyName, null, value);
				throw new MethodInvocationException(pce, ex);
			}
&lt;p&gt;		}&lt;br/&gt;
	}&lt;/p&gt;

&lt;p&gt;	public void setPropertyValue(PropertyValue pv) throws BeansException &lt;/p&gt;
{
		setPropertyValue(pv.getName(), pv.getValue());
	}

&lt;p&gt;	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Bulk update from a Map.&lt;/li&gt;
	&lt;li&gt;Bulk updates from PropertyValues are more powerful: this method is&lt;/li&gt;
	&lt;li&gt;provided for convenience.&lt;/li&gt;
	&lt;li&gt;@param map map containing properties to set, as name-value pairs.&lt;/li&gt;
	&lt;li&gt;The map may include nested properties.&lt;/li&gt;
	&lt;li&gt;@throws BeansException if there&apos;s a fatal, low-level exception&lt;br/&gt;
	 */&lt;br/&gt;
	public void setPropertyValues(Map map) throws BeansException 
{
		setPropertyValues(new MutablePropertyValues(map));
	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;	public void setPropertyValues(PropertyValues pvs) throws BeansException &lt;/p&gt;
{
		setPropertyValues(pvs, false);
	}

&lt;p&gt;	public void setPropertyValues(PropertyValues propertyValues, boolean ignoreUnknown) throws BeansException {&lt;br/&gt;
		List propertyAccessExceptions = new ArrayList();&lt;br/&gt;
		PropertyValue[] pvs = propertyValues.getPropertyValues();&lt;br/&gt;
		for (int i = 0; i &amp;lt; pvs.length; i++) {&lt;br/&gt;
			try &lt;/p&gt;
{
				// This method may throw any BeansException, which won&apos;t be caught
				// here, if there is a critical failure such as no matching field.
				// We can attempt to deal only with less serious exceptions.
				setPropertyValue(pvs[i]);
			}
&lt;p&gt;			catch (NotWritablePropertyException ex) {&lt;br/&gt;
				if (!ignoreUnknown) &lt;/p&gt;
{
					throw ex;
				}
&lt;p&gt;				// otherwise, just ignore it and continue...&lt;br/&gt;
			}&lt;br/&gt;
			catch (PropertyAccessException ex) &lt;/p&gt;
{
				propertyAccessExceptions.add(ex);
			}
&lt;p&gt;		}&lt;/p&gt;

&lt;p&gt;		// If we encountered individual exceptions, throw the composite exception.&lt;br/&gt;
		if (!propertyAccessExceptions.isEmpty()) &lt;/p&gt;
{
			Object[] paeArray = propertyAccessExceptions.toArray(
					new PropertyAccessException[propertyAccessExceptions.size()]);
			throw new PropertyAccessExceptionsException(this, (PropertyAccessException[]) paeArray);
		}
&lt;p&gt;	}&lt;/p&gt;

&lt;p&gt;	private PropertyChangeEvent createPropertyChangeEvent(String propertyName, Object oldValue, Object newValue) &lt;/p&gt;
{
		return new PropertyChangeEvent(
				(this.object != null ? this.object : &quot;constructor&quot;),
				(propertyName != null ? this.nestedPath + propertyName : null),
				oldValue, newValue);
	}

&lt;p&gt;	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Convert the value to the required type (if necessary from a String).&lt;/li&gt;
	&lt;li&gt;Conversions from String to any type use the setAsText method of&lt;/li&gt;
	&lt;li&gt;the PropertyEditor class. Note that a PropertyEditor must be registered&lt;/li&gt;
	&lt;li&gt;for this class for this to work. This is a standard Java Beans API.&lt;/li&gt;
	&lt;li&gt;A number of property editors are automatically registered by this class.&lt;/li&gt;
	&lt;li&gt;@param newValue proposed change value.&lt;/li&gt;
	&lt;li&gt;@param requiredType type we must convert to&lt;/li&gt;
	&lt;li&gt;@throws BeansException if there is an internal error&lt;/li&gt;
	&lt;li&gt;@return new value, possibly the result of type convertion&lt;br/&gt;
	 */&lt;br/&gt;
	public Object doTypeConversionIfNecessary(Object newValue, Class requiredType) throws BeansException 
{
		return doTypeConversionIfNecessary(null, null, null, newValue, requiredType);
	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Convert the value to the required type (if necessary from a String),&lt;/li&gt;
	&lt;li&gt;for the specified property.&lt;/li&gt;
	&lt;li&gt;@param propertyName name of the property&lt;/li&gt;
	&lt;li&gt;@param oldValue previous value, if available (may be null)&lt;/li&gt;
	&lt;li&gt;@param newValue proposed change value.&lt;/li&gt;
	&lt;li&gt;@param requiredType type we must convert to&lt;/li&gt;
	&lt;li&gt;@throws BeansException if there is an internal error&lt;/li&gt;
	&lt;li&gt;@return converted value (i.e. possibly the result of type conversion)&lt;br/&gt;
	 */&lt;br/&gt;
	protected Object doTypeConversionIfNecessary(String propertyName, String fullPropertyName,&lt;br/&gt;
																							 Object oldValue, Object newValue,&lt;br/&gt;
																							 Class requiredType) throws BeansException {&lt;br/&gt;
		Object convertedValue = newValue;&lt;br/&gt;
		if (convertedValue != null) {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;			// custom editor for this type?&lt;br/&gt;
			PropertyEditor pe = findCustomEditor(requiredType, fullPropertyName);&lt;/p&gt;

&lt;p&gt;			// value not of required type?&lt;br/&gt;
			if (pe != null ||&lt;br/&gt;
					(requiredType != null &amp;amp;&amp;amp;&lt;br/&gt;
					 (requiredType.isArray() || !requiredType.isAssignableFrom(convertedValue.getClass())))) {&lt;/p&gt;

&lt;p&gt;				if (pe == null &amp;amp;&amp;amp; requiredType != null) {&lt;br/&gt;
					// no custom editor -&amp;gt; check BeanWrapperImpl&apos;s default editors&lt;br/&gt;
					pe = (PropertyEditor) this.defaultEditors.get(requiredType);&lt;br/&gt;
					if (pe == null) &lt;/p&gt;
{
						// no BeanWrapper default editor -&amp;gt; check standard JavaBean editors
						pe = PropertyEditorManager.findEditor(requiredType);
					}
&lt;p&gt;				}&lt;/p&gt;

&lt;p&gt;				if (requiredType != null &amp;amp;&amp;amp; !requiredType.isArray() &amp;amp;&amp;amp; convertedValue instanceof String[]) {&lt;br/&gt;
					if (logger.isDebugEnabled()) &lt;/p&gt;
{
						logger.debug(&quot;Converting String array to comma-delimited String [&quot; + convertedValue + &quot;]&quot;);
					}
&lt;p&gt;					convertedValue = StringUtils.arrayToCommaDelimitedString((String[]) convertedValue);&lt;br/&gt;
				}&lt;/p&gt;

&lt;p&gt;				if (pe != null) {&lt;br/&gt;
					if (convertedValue instanceof String) {&lt;br/&gt;
						// use PropertyEditor&apos;s setAsText in case of a String value&lt;br/&gt;
						if (logger.isDebugEnabled()) &lt;/p&gt;
{
							logger.debug(&quot;Converting String to [&quot; + requiredType + &quot;] using property editor [&quot; + pe + &quot;]&quot;);
						}
&lt;p&gt;						try &lt;/p&gt;
{
							pe.setAsText((String) convertedValue);
							convertedValue = pe.getValue();
						}
&lt;p&gt;						catch (IllegalArgumentException ex) &lt;/p&gt;
{
							throw new TypeMismatchException(
									createPropertyChangeEvent(fullPropertyName, oldValue, newValue), requiredType, ex);
						}&lt;br/&gt;
					}&lt;br/&gt;
					else {&lt;br/&gt;
						// Not a String -&amp;gt; use PropertyEditor&apos;s setValue.&lt;br/&gt;
						// With standard PropertyEditors, this will return the very same object;&lt;br/&gt;
						// we just want to allow special PropertyEditors to override setValue&lt;br/&gt;
						// for type conversion from non-String values to the required type.&lt;br/&gt;
						try {
							pe.setValue(convertedValue);
							convertedValue = pe.getValue();
						}&lt;br/&gt;
						catch (IllegalArgumentException ex) {							throw new TypeMismatchException(									createPropertyChangeEvent(fullPropertyName, oldValue, newValue), requiredType, ex);						}
&lt;p&gt;					}&lt;br/&gt;
				}&lt;/p&gt;

&lt;p&gt;				// array required -&amp;gt; apply appropriate conversion of elements&lt;br/&gt;
				if (requiredType != null &amp;amp;&amp;amp; requiredType.isArray()) {&lt;br/&gt;
					Class componentType = requiredType.getComponentType();&lt;br/&gt;
					if (convertedValue instanceof Collection) {&lt;br/&gt;
						// convert individual elements to array elements&lt;br/&gt;
						Collection coll = (Collection) convertedValue;&lt;br/&gt;
						Object result = Array.newInstance(componentType, coll.size());&lt;br/&gt;
						int i = 0;&lt;br/&gt;
						for (Iterator it = coll.iterator(); it.hasNext(); i++) &lt;/p&gt;
{
							Object value = doTypeConversionIfNecessary(
									propertyName, propertyName + PROPERTY_KEY_PREFIX + i + PROPERTY_KEY_SUFFIX,
									null, it.next(), componentType);
							Array.set(result, i, value);
						}
&lt;p&gt;						return result;&lt;br/&gt;
					}&lt;br/&gt;
					else if (convertedValue != null &amp;amp;&amp;amp; convertedValue.getClass().isArray()) {&lt;br/&gt;
						// convert individual elements to array elements&lt;br/&gt;
						int arrayLength = Array.getLength(convertedValue);&lt;br/&gt;
						Object result = Array.newInstance(componentType, arrayLength);&lt;br/&gt;
						for (int i = 0; i &amp;lt; arrayLength; i++) &lt;/p&gt;
{
							Object value = doTypeConversionIfNecessary(
									propertyName, propertyName + PROPERTY_KEY_PREFIX + i + PROPERTY_KEY_SUFFIX,
									null, Array.get(convertedValue, i), componentType);
							Array.set(result, i, value);
						}
&lt;p&gt;						return result;&lt;br/&gt;
					}&lt;br/&gt;
					else &lt;/p&gt;
{
						// a plain value: convert it to an array with a single component
						Object result = Array.newInstance(componentType, 1) ;
						Object val = doTypeConversionIfNecessary(
								propertyName, propertyName + PROPERTY_KEY_PREFIX + 0 + PROPERTY_KEY_SUFFIX,
								null, convertedValue, componentType);
						Array.set(result, 0, val);
						return result;
					}
&lt;p&gt;				}&lt;br/&gt;
			}&lt;/p&gt;

&lt;p&gt;			// Throw explicit TypeMismatchException with full context information&lt;br/&gt;
			// if the resulting value definitely doesn&apos;t match the required type.&lt;br/&gt;
			if (convertedValue != null &amp;amp;&amp;amp; requiredType != null &amp;amp;&amp;amp; !requiredType.isPrimitive() &amp;amp;&amp;amp;&lt;br/&gt;
					!requiredType.isAssignableFrom(convertedValue.getClass())) &lt;/p&gt;
{
				throw new TypeMismatchException(
						createPropertyChangeEvent(fullPropertyName, oldValue, newValue), requiredType);
			}
&lt;p&gt;		}&lt;/p&gt;

&lt;p&gt;		return convertedValue;&lt;br/&gt;
	}&lt;/p&gt;


&lt;p&gt;	public PropertyDescriptor[] getPropertyDescriptors() &lt;/p&gt;
{
		return this.cachedIntrospectionResults.getBeanInfo().getPropertyDescriptors();
	}

&lt;p&gt;	public PropertyDescriptor getPropertyDescriptor(String propertyName) throws BeansException {&lt;br/&gt;
		if (propertyName == null) &lt;/p&gt;
{
			throw new IllegalArgumentException(&quot;Can&apos;t find property descriptor for null property&quot;);
		}
&lt;p&gt;		PropertyDescriptor pd = getPropertyDescriptorInternal(propertyName);&lt;br/&gt;
		if (pd != null) &lt;/p&gt;
{
			return pd;
		}
&lt;p&gt;		else &lt;/p&gt;
{
			throw new InvalidPropertyException(getWrappedClass(), this.nestedPath + propertyName,
																				 &quot;No property &apos;&quot; + propertyName + &quot;&apos; found&quot;);
		}
&lt;p&gt;	}&lt;/p&gt;

&lt;p&gt;	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Internal version of getPropertyDescriptor:&lt;/li&gt;
	&lt;li&gt;Returns null if not found rather than throwing an exception.&lt;br/&gt;
	 */&lt;br/&gt;
	protected PropertyDescriptor getPropertyDescriptorInternal(String propertyName) throws BeansException 
{
		BeanWrapperImpl nestedBw = getBeanWrapperForPropertyPath(propertyName);
		return nestedBw.cachedIntrospectionResults.getPropertyDescriptor(getFinalPath(nestedBw, propertyName));
	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;	public Class getPropertyType(String propertyName) throws BeansException {&lt;br/&gt;
		try {&lt;br/&gt;
			PropertyDescriptor pd = getPropertyDescriptorInternal(propertyName);&lt;br/&gt;
			if (pd != null) &lt;/p&gt;
{
				return pd.getPropertyType();
			}
&lt;p&gt;			else {&lt;br/&gt;
				// maybe an indexed/mapped property&lt;br/&gt;
				Object value = getPropertyValue(propertyName);&lt;br/&gt;
				if (value != null) &lt;/p&gt;
{
					return value.getClass();
				}
&lt;p&gt;			}&lt;br/&gt;
		}&lt;br/&gt;
		catch (InvalidPropertyException ex) &lt;/p&gt;
{
			// consider as not determinable
		}
&lt;p&gt;		return null;&lt;br/&gt;
	}&lt;/p&gt;

&lt;p&gt;	public boolean isReadableProperty(String propertyName) {&lt;br/&gt;
		// This is a programming error, although asking for a property&lt;br/&gt;
		// that doesn&apos;t exist is not.&lt;br/&gt;
		if (propertyName == null) &lt;/p&gt;
{
			throw new IllegalArgumentException(&quot;Can&apos;t find readability status for null property&quot;);
		}
&lt;p&gt;		try {&lt;br/&gt;
			PropertyDescriptor pd = getPropertyDescriptorInternal(propertyName);&lt;br/&gt;
			if (pd != null) {&lt;br/&gt;
				if (pd.getReadMethod() != null) &lt;/p&gt;
{
					return true;
				}&lt;br/&gt;
			}&lt;br/&gt;
			else {
				// maybe an indexed/mapped property
				getPropertyValue(propertyName);
				return true;
			}&lt;br/&gt;
		}&lt;br/&gt;
		catch (InvalidPropertyException ex) {
			// cannot be evaluated, so can&apos;t be readable
		}&lt;br/&gt;
		return false;&lt;br/&gt;
	}&lt;br/&gt;
&lt;br/&gt;
	public boolean isWritableProperty(String propertyName) {&lt;br/&gt;
		// This is a programming error, although asking for a property&lt;br/&gt;
		// that doesn&apos;t exist is not.&lt;br/&gt;
		if (propertyName == null) {
			throw new IllegalArgumentException(&quot;Can&apos;t find writability status for null property&quot;);
		}&lt;br/&gt;
		try {&lt;br/&gt;
			PropertyDescriptor pd = getPropertyDescriptorInternal(propertyName);&lt;br/&gt;
			if (pd != null) {&lt;br/&gt;
				if (pd.getWriteMethod() != null) {					return true;				}
&lt;p&gt;			}&lt;br/&gt;
			else &lt;/p&gt;
{
				// maybe an indexed/mapped property
				getPropertyValue(propertyName);
				return true;
			}
&lt;p&gt;		}&lt;br/&gt;
		catch (InvalidPropertyException ex) &lt;/p&gt;
{
			// cannot be evaluated, so can&apos;t be writable
		}
&lt;p&gt;		return false;&lt;br/&gt;
	}&lt;/p&gt;


&lt;p&gt;	//---------------------------------------------------------------------&lt;br/&gt;
	// Diagnostics&lt;br/&gt;
	//---------------------------------------------------------------------&lt;/p&gt;

&lt;p&gt;	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;This method is expensive! Only call for diagnostics and debugging reasons,&lt;/li&gt;
	&lt;li&gt;not in production.&lt;/li&gt;
	&lt;li&gt;@return a string describing the state of this object&lt;br/&gt;
	 */&lt;br/&gt;
	public String toString() {&lt;br/&gt;
		StringBuffer sb = new StringBuffer();&lt;br/&gt;
		try {&lt;br/&gt;
			sb.append(&quot;BeanWrapperImpl: wrapping class &lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot; + getWrappedClass().getName() + &amp;quot;&amp;#93;&lt;/span&gt;; &quot;);&lt;br/&gt;
			PropertyDescriptor pds[] = getPropertyDescriptors();&lt;br/&gt;
			if (pds != null) {&lt;br/&gt;
				for (int i = 0; i &amp;lt; pds.length; i++) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {					Object val = getPropertyValue(pds[i].getName());					String valStr = (val != null) ? val.toString() }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;			}&lt;br/&gt;
		}&lt;br/&gt;
		catch (Exception ex) &lt;/p&gt;
{
			sb.append(&quot;exception encountered: &quot; + ex);
		}
&lt;p&gt;		return sb.toString();&lt;br/&gt;
	}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Holder for a registered custom editor with property name.&lt;/li&gt;
	&lt;li&gt;Keeps the PropertyEditor itself plus the type it was registered for.&lt;br/&gt;
	 */&lt;br/&gt;
	private static class CustomEditorHolder {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;		private final PropertyEditor propertyEditor;&lt;/p&gt;

&lt;p&gt;		private final Class registeredType;&lt;/p&gt;

&lt;p&gt;		private CustomEditorHolder(PropertyEditor propertyEditor, Class registeredType) &lt;/p&gt;
{
			this.propertyEditor = propertyEditor;
			this.registeredType = registeredType;
		}

&lt;p&gt;		private PropertyEditor getPropertyEditor() &lt;/p&gt;
{
			return propertyEditor;
		}

&lt;p&gt;		private Class getRegisteredType() &lt;/p&gt;
{
			return registeredType;
		}

&lt;p&gt;		private PropertyEditor getPropertyEditor(Class requiredType) {&lt;br/&gt;
			// Special case: If no required type specified, which usually only happens for&lt;br/&gt;
			// Collection elements, or required type is not assignable to registered type,&lt;br/&gt;
			// which usually only happens for generic properties of type Object -&lt;br/&gt;
			// then return PropertyEditor if not registered for Collection or array type.&lt;br/&gt;
			// (If not registered for Collection or array, it is assumed to be intended&lt;br/&gt;
			// for elements.)&lt;br/&gt;
			if (this.registeredType == null ||&lt;br/&gt;
					(requiredType != null &amp;amp;&amp;amp;&lt;br/&gt;
			    (BeanUtils.isAssignable(this.registeredType, requiredType) ||&lt;br/&gt;
			    BeanUtils.isAssignable(requiredType, this.registeredType))) ||&lt;br/&gt;
					(requiredType == null &amp;amp;&amp;amp;&lt;br/&gt;
			    (!Collection.class.isAssignableFrom(this.registeredType) &amp;amp;&amp;amp; !this.registeredType.isArray()))) &lt;/p&gt;
{
				return this.propertyEditor;
			}
&lt;p&gt;			else &lt;/p&gt;
{
				return null;
			}
&lt;p&gt;		}&lt;br/&gt;
	}&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;</comment>
                            <comment id="11438" author="juergen.hoeller" created="Sat, 6 Nov 2004 05:59:54 +0000"  >&lt;p&gt;Thanks for the report! However, please submit a patch (clearly indicating which lines in BeanWrapperImpl you changed), and a test case which reproduces the issue (to validate that it didn&apos;t work before but does work after applying the patch). I&apos;ll look at the issue immediately then.&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="11444" author="janaki_srini" created="Mon, 8 Nov 2004 02:09:46 +0000"  >&lt;p&gt;This file contains changed methods of BeanWrapperImpl class&lt;/p&gt;</comment>
                            <comment id="11446" author="janaki_srini" created="Mon, 8 Nov 2004 02:10:48 +0000"  >&lt;p&gt;Test bean used in the testing code&lt;/p&gt;</comment>
                            <comment id="11447" author="janaki_srini" created="Mon, 8 Nov 2004 02:11:15 +0000"  >&lt;p&gt;Class to run the test. This is not junit test case&lt;/p&gt;</comment>
                            <comment id="11448" author="janaki_srini" created="Mon, 8 Nov 2004 02:11:52 +0000"  >&lt;p&gt;sample proerties used in the testing. This should be in the class path of the test class.&lt;/p&gt;</comment>
                            <comment id="11449" author="janaki_srini" created="Mon, 8 Nov 2004 02:13:39 +0000"  >&lt;p&gt;I have attached bunch of files specifying my changes and tests. When the test is run with 1.1 spring.jar it throws the exception mentioned and the changes BeanWrapperImpl does not and assigns the values from the file.&lt;/p&gt;</comment>
                            <comment id="11453" author="juergen.hoeller" created="Mon, 8 Nov 2004 07:24:03 +0000"  >&lt;p&gt;Thanks for the submission! I just added a corresponding test case to BeanWrapperTests and implemented the corresponding functionality in BeanWrapperImpl.&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="10304" name="BeanWrapperImpl changed methods.txt" size="9138" author="janaki_srini" created="Mon, 8 Nov 2004 02:09:46 +0000"/>
                            <attachment id="10306" name="PropBindTest.java" size="2268" author="janaki_srini" created="Mon, 8 Nov 2004 02:11:15 +0000"/>
                            <attachment id="10305" name="TestBean.java" size="1487" author="janaki_srini" created="Mon, 8 Nov 2004 02:10:47 +0000"/>
                            <attachment id="10307" name="sample.properties" size="89" author="janaki_srini" created="Mon, 8 Nov 2004 02:11:52 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_10180" key="com.atlassian.jira.toolkit:dayslastcommented">
                        <customfieldname>Days since last comment</customfieldname>
                        <customfieldvalues>
                                        12 years, 8 weeks, 3 days ago
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10170" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>First Response Date</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sat, 6 Nov 2004 05:59:54 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10181" key="com.atlassian.jira.toolkit:lastusercommented">
                        <customfieldname>Last commented by a User</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>false</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10182" key="com.atlassian.jira.toolkit:lastupdaterorcommenter">
                        <customfieldname>Last updater</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>tmarshall</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10880" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i04y07:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10380" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>28883</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_10171" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>