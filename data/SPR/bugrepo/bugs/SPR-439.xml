<!-- 
RSS generated by JIRA (6.4.11#64026-sha1:78f6ec473a3f058bd5d6c30e9319c7ab376bdb9c) at Thu Dec 22 19:02:59 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://jira.spring.io/si/jira.issueviews:issue-xml/SPR-439/SPR-439.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>Spring JIRA</title>
    <link>https://jira.spring.io</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.4.11</version>
        <build-number>64026</build-number>
        <build-date>25-08-2015</build-date>
    </build-info>

<item>
            <title>[SPR-439] session.flush executes sql that were rolled back</title>
                <link>https://jira.spring.io/browse/SPR-439</link>
                <project id="10000" key="SPR">Spring Framework</project>
                    <description>&lt;p&gt;situation:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;a transaction is begun.&lt;/li&gt;
	&lt;li&gt;different objects are persisted or removed from the database.&lt;/li&gt;
	&lt;li&gt;the transaction is rolled back.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Problem:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The database operations are first put into hibernate&apos;s session cache. And they won&apos;t be executed/removed until session.flush() or session.clear() are called. The TransactionInterceptor only issues a rollback on the Transaction. Therefore flushing the session after the transaction is over will execute the database operations even though they should have been rolled back.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I have fixed these issues by making changes to HibernateTransactionManager, i.e. flushing the session and setting the sessionHolder.rollbackOnly to false before rollback.&lt;/p&gt;</description>
            <key id="10702">SPR-439</key>
            <summary>session.flush executes sql that were rolled back</summary>
                <type id="1" iconUrl="https://jira.spring.io/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://jira.spring.io/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://jira.spring.io/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="juergen.hoeller">Juergen Hoeller</assignee>
                                    <reporter username="s.meyer">Stefan Meyer</reporter>
                        <labels>
                    </labels>
                <created>Sun, 31 Oct 2004 19:54:49 +0000</created>
                <updated>Tue, 2 Nov 2004 01:39:16 +0000</updated>
                            <resolved>Sun, 31 Oct 2004 21:20:48 +0000</resolved>
                                    <version>1.0.2</version>
                                    <fixVersion>1.1.2</fixVersion>
                                    <component>Data</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="11404" author="juergen.hoeller" created="Sun, 31 Oct 2004 21:20:48 +0000"  >&lt;p&gt;That&apos;s a good point!&lt;/p&gt;

&lt;p&gt;Of course, with purely transaction-scoped Sessions, it doesn&apos;t matter: The Session will be discarded after transaction completion anyway.&lt;/p&gt;

&lt;p&gt;However, with OpenSessionInViewFilter, it does sometimes matter: The Session is an inconsistent state after the rollback. If all you do is propagate the exception and show an error page, it&apos;s not relevant. But if you continue processing, it is indeed desirable to have a consistent Session again.&lt;/p&gt;

&lt;p&gt;Clearing the Session will of course not only remove the pending inserts/updates/deletes but also clear the entire first-level cache. That&apos;s acceptable, though: After a rollback, everything needs to be loaded again from scratch.&lt;/p&gt;

&lt;p&gt;Regarding the rollbackOnly flag: As I&apos;ve pointed out in the other issue you created, this is reset in cleanupAfterCompletion, so there&apos;s no need to reset it in the doRollback implementation.&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="11408" author="s.meyer" created="Mon, 1 Nov 2004 03:28:32 +0000"  >&lt;p&gt;I am afraif that clearing the session is not desirable for my example. I load a collection of job entries form the database. Then I iterate over the entries using a new transaction each. After each job is executed I decide whether or not to delete update the job entry. Therefore all operations have to executed in one session.&lt;/p&gt;</comment>
                            <comment id="11410" author="juergen.hoeller" created="Mon, 1 Nov 2004 04:11:34 +0000"  >&lt;p&gt;Well, the problem is that the Session is gonna be inconsistent after a transaction failed, even if you flush it to the database before the rollback: The in-memory state, i.e. the objects registered in the Session&apos;s first-level cache, does not correspond to the state in the database anymore. This is the main reason why it is highly recommended to not use a single Session for multiple transactions, in particular not to reuse the same Session after a failed transaction.&lt;/p&gt;

&lt;p&gt;In your scenario, I would recommend to find a way to not use the same Session for both each job execution and the job update tracking. You could either track the updates manually (which job to update or delete) and persist those updates in their own transaction (with its own Session) at the end, after all jobs have executed.&lt;/p&gt;

&lt;p&gt;Or you could execute the job iteration within a transaction, but execute each job in its own transaction - through specifying PROPAGATION_REQUIRES_NEW for each job execution. Each such job execution will then use its own Hibernate Session, while the outer iteration is able to perform Hibernate operations independently, on its independent Hibernate Session in its own transaction.&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="11413" author="s.meyer" created="Mon, 1 Nov 2004 20:06:27 +0000"  >&lt;p&gt;One more thing. The HibernateInterceptor usually flushes the session before closing it. This will issue all database operations left in the session after a roll back. The connection is set to autocommit in this situation. Therefore the rolled back operations might partially be executed anyways.&lt;/p&gt;</comment>
                            <comment id="11415" author="juergen.hoeller" created="Tue, 2 Nov 2004 01:39:16 +0000"  >&lt;p&gt;Indeed, HibernateInterceptor will by default flush the Session, although you can turn that off through specifying &quot;FLUSH_NEVER&quot; as &quot;flushModeName&quot; property.&lt;/p&gt;

&lt;p&gt;However, with out new Session.clear call on rollback, the Session won&apos;t contain any unflushed data after a rollback, so the HibernateInterceptor-driven flush should not matter.&lt;/p&gt;

&lt;p&gt;I actually recommend against using HibernateInterceptor in that style: I rather advise to use an outer transaction and inner transactions with PROPAGATION_REQUIRES_NEW, with no HibernateInterceptor in the mix.&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_10180" key="com.atlassian.jira.toolkit:dayslastcommented">
                        <customfieldname>Days since last comment</customfieldname>
                        <customfieldvalues>
                                        12 years, 9 weeks, 2 days ago
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10170" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>First Response Date</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sun, 31 Oct 2004 21:20:48 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10181" key="com.atlassian.jira.toolkit:lastusercommented">
                        <customfieldname>Last commented by a User</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>false</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10182" key="com.atlassian.jira.toolkit:lastupdaterorcommenter">
                        <customfieldname>Last updater</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>tmarshall</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10880" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i00zs7:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10380" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>5842</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_10171" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>