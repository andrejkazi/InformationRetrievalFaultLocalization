<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sat Nov 19 22:45:00 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/COLLECTIONS-310/COLLECTIONS-310.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[COLLECTIONS-310] Modifications of a SetUniqueList.subList() invalidate the parent list</title>
                <link>https://issues.apache.org/jira/browse/COLLECTIONS-310</link>
                <project id="12310465" key="COLLECTIONS">Commons Collections</project>
                    <description>&lt;p&gt;The List returned by SetUniqueList.subList() is again a SetUniqueList. The contract for List.subList() says that the returned list supports all the operations of the parent list, and it is backed by the parent list.&lt;/p&gt;

&lt;p&gt;We have a SetUniqueList uniqueList equal to &lt;/p&gt;
{&quot;Hello&quot;, &quot;World&quot;}
&lt;p&gt;. We get a subList containing the last element. Now we add the element &quot;Hello&quot;, contained in the uniqueList but not in the subList, to the subList.&lt;/p&gt;

&lt;p&gt;What should happen?&lt;/p&gt;

&lt;p&gt;Should the subList behave like a SetUniqueList and add the element - meaning that it changes position in the uniqueList because at the old place it gets removed, so now uniqueList equals &lt;/p&gt;
{&quot;World&quot;, &quot;Hello&quot;}
&lt;p&gt; (which fails)?&lt;br/&gt;
Or should the element not be added, because it is already contained in the parent list, thereby violating the SetUniqueList-ness of the subList (which fails)?&lt;br/&gt;
I prefer the former behaviour, because modifications should only be made through the subList and not through the parent list (as explained in List.subList()).&lt;/p&gt;

&lt;p&gt;What should happen if we replace (using set) the subList element &quot;World&quot; with &quot;Hello&quot; instead of adding an element?&lt;/p&gt;

&lt;p&gt;The subList should contain only &quot;Hello&quot;, and for the parent list, the old element 0 (now a duplicate of the just set element 1) should be removed (which fails).&lt;/p&gt;

&lt;p&gt;And of course the parent list should know what happens to it (specifically, its uniqueness Set) (which fails in the current snapshot).&lt;/p&gt;


&lt;p&gt;	public void testSubListAddNew() {&lt;br/&gt;
		List uniqueList = SetUniqueList.decorate(new ArrayList());&lt;br/&gt;
		uniqueList.add(&quot;Hello&quot;);&lt;br/&gt;
		uniqueList.add(&quot;World&quot;);&lt;br/&gt;
		List subList = uniqueList.subList(1, 2);&lt;/p&gt;

&lt;p&gt;		subList.add(&quot;Goodbye&quot;);&lt;/p&gt;

&lt;p&gt;		List expectedSubList = Arrays.asList(new Object[] &lt;/p&gt;
{ &quot;World&quot;, &quot;Goodbye&quot; }
&lt;p&gt;);&lt;br/&gt;
		List expectedParentList = Arrays.asList(new Object[] &lt;/p&gt;
{ &quot;Hello&quot;, &quot;World&quot;, &quot;Goodbye&quot; }
&lt;p&gt;);&lt;br/&gt;
		assertEquals(expectedSubList, subList);&lt;br/&gt;
		assertEquals(expectedParentList, uniqueList);&lt;br/&gt;
		assertTrue(uniqueList.contains(&quot;Goodbye&quot;)); // fails&lt;br/&gt;
	}&lt;/p&gt;

&lt;p&gt;	public void testSubListAddDuplicate() {&lt;br/&gt;
		List uniqueList = SetUniqueList.decorate(new ArrayList());&lt;br/&gt;
		uniqueList.add(&quot;Hello&quot;);&lt;br/&gt;
		uniqueList.add(&quot;World&quot;);&lt;br/&gt;
		List subList = uniqueList.subList(1, 2);&lt;/p&gt;

&lt;p&gt;		subList.add(&quot;Hello&quot;);&lt;/p&gt;

&lt;p&gt;		List expectedSubList = Arrays.asList(new Object[] &lt;/p&gt;
{ &quot;World&quot;, &quot;Hello&quot; });&lt;br/&gt;
		List expectedParentList = Arrays.asList(new Object[] { &quot;World&quot;, &quot;Hello&quot; }
&lt;p&gt;);&lt;br/&gt;
		assertEquals(expectedSubList, subList);&lt;br/&gt;
		assertEquals(expectedParentList, uniqueList); // fails&lt;br/&gt;
	}&lt;/p&gt;

&lt;p&gt;	public void testSubListSetDuplicate() {&lt;br/&gt;
		List uniqueList = SetUniqueList.decorate(new ArrayList());&lt;br/&gt;
		uniqueList.add(&quot;Hello&quot;);&lt;br/&gt;
		uniqueList.add(&quot;World&quot;);&lt;br/&gt;
		List subList = uniqueList.subList(1, 2);&lt;/p&gt;

&lt;p&gt;		subList.set(0, &quot;Hello&quot;);&lt;/p&gt;

&lt;p&gt;		List expectedSubList = Arrays.asList(new Object[] &lt;/p&gt;
{ &quot;Hello&quot; });&lt;br/&gt;
		List expectedParentList = Arrays.asList(new Object[] { &quot;Hello&quot; }
&lt;p&gt;);&lt;br/&gt;
		assertEquals(expectedSubList, subList);&lt;br/&gt;
		assertEquals(expectedParentList, uniqueList); // fails&lt;br/&gt;
	}&lt;/p&gt;</description>
                <environment></environment>
        <key id="12412112">COLLECTIONS-310</key>
            <summary>Modifications of a SetUniqueList.subList() invalidate the parent list</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="chsemrau">Christian Semrau</reporter>
                        <labels>
                    </labels>
                <created>Sat, 10 Jan 2009 13:58:28 +0000</created>
                <updated>Sun, 9 Nov 2014 14:31:26 +0000</updated>
                            <resolved>Sat, 27 Apr 2013 11:57:35 +0000</resolved>
                                    <version>3.2</version>
                    <version>Nightly Builds</version>
                                    <fixVersion>4.0-alpha1</fixVersion>
                    <fixVersion>4.0</fixVersion>
                                    <component>List</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="12662689" author="chsemrau" created="Sat, 10 Jan 2009 20:25:58 +0000"  >&lt;p&gt;It seems that properties of the SetUniqueList.subList are currently not tested: The bulk tests for TestSetUniqueList are disabled.&lt;/p&gt;

&lt;p&gt;I managed to enable them by using a copy of BulkTestSubList which is subclassed from TestSetUniqueList instead of AbstractTestList, and which disables extraVerify for itself and the outer test. For the bulkTestListIterator, TestListIterator.supportsSet() must return false (but then still one test fails).&lt;/p&gt;

&lt;p&gt;But maybe this should be subject of a different jira issue.&lt;/p&gt;</comment>
                            <comment id="13563537" author="t.vahrst" created="Sat, 26 Jan 2013 16:30:52 +0000"  >&lt;p&gt;As already stated in the javadoc of SetUniqueList, this class does not adhere to the api contract of java.util.List. The class name as well as the implemented interface (java.util.List) implies the behavior of a List, but that is not true. Several methods violate the List contract and state this in its javadocs. &lt;/p&gt;

&lt;p&gt;Furthermore: some javadocs are not clear enough about the contract violation. For example the javadoc of the &apos;add()&apos; method states a &apos;violation&apos; of the api because the method may return &apos;false&apos;. But this method also violates the java.util.List &lt;b&gt;semantics&lt;/b&gt;, because the specified element is not only added, an other element is possibly removed during the invocation. &lt;/p&gt;

&lt;p&gt;Imagine a generic sort algorithm for lists, which internal moves elements in the list by &lt;b&gt;first&lt;/b&gt; adding the element at the new position and then removing the element at the old position. This algorithm would probably remove most of the elements in the list... (Btw: this test fails with an UnsupportedOperationException:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  List&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;&amp;gt; list = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;&amp;gt;();
  list.addAll( Arrays.asList(&lt;span class=&quot;code-quote&quot;&gt;&quot;one&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;two&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;three&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;four&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;five&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;six&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;seven&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;eight&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;nine&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;ten&quot;&lt;/span&gt;));
  SetUniqueList&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;&amp;gt; uniquelist = SetUniqueList.setUniqueList(list);

  Collections.sort(uniquelist);

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In my opinion this jira issue concerning the subList() behavior cannot be solved in a way that makes the behavior expectable for the user. So instead of providing an implementation which may work in most cases but sometimes fails and describing this strange behavior (it took some time to understand the issue...) in the method&apos;s javadoc, I would suggest to throw an UnsupportedOperationException.&lt;/p&gt;

&lt;p&gt;I personally would consider removing the whole class. Many developers use the apache commons classes as code reference for their own concrete coding problems and SetUniqueList isn&apos;t a good example of the decorator pattern - as stated above. (And in addition violates the liskov substitution principle). The better solution is already described in SetUniqueList&apos;s javadoc:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
 * The {@link org.apache.commons.collections.set.ListOrderedSet ListOrderedSet}
 * class provides an alternative approach, by wrapping an existing Set and
 * retaining insertion order in the iterator.
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;What do yout think? Any comments?&lt;/p&gt;</comment>
                            <comment id="13566631" author="tn" created="Wed, 30 Jan 2013 17:09:20 +0000"  >&lt;p&gt;Hi Thomas,&lt;/p&gt;

&lt;p&gt;I agree in general with your observation, but I do not understand your statement &apos;because the specified element is not only added, an other element is possibly removed during the invocation&apos;.&lt;/p&gt;

&lt;p&gt;Looking at the add method, I fail to see how this may happen. The use-case you describe does explicitly call remove, so I wonder how this is related to the previous statement.&lt;/p&gt;

&lt;p&gt;This class in general should be used with a lot of care, and only if you know exactly what you are doing, which is probably not very convincing either. I would prefer to keep the class for now, but improve the javadoc wrt the current limitations, which may never be fully resolved.&lt;/p&gt;</comment>
                            <comment id="13566703" author="t.vahrst" created="Wed, 30 Jan 2013 18:07:38 +0000"  >&lt;p&gt;Mmmh, I don&apos;t understand my own comment any more... Must have been tired. So you are right: the sorting example is nonsense, please ignore it. &lt;/p&gt;

&lt;p&gt;I agree to keep the class - I&apos;ll try to write some additions to the javadoc comment for the subList() method to clarify the behavior... &lt;/p&gt;</comment>
                            <comment id="13569532" author="t.vahrst" created="Sat, 2 Feb 2013 12:47:35 +0000"  >&lt;p&gt;I took a deeper look on this issue and the suggested behavior/junit tests and tried to understand the problem(s). It seems, there a two issues with the current implementation regarding modifications of sublists:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Modifications of sublist items are delegated to the underlying backing list (which is the default sublist implementation) but &lt;b&gt;not&lt;/b&gt; to the internal set of the parent SetUniqueList.  So a new entry is added to the list, but the contains() method of the parent SetUniqueList returns false&lt;/li&gt;
	&lt;li&gt;Modifications of the sublist may result in changes &lt;b&gt;outside&lt;/b&gt; the range of the sublist. For example adding an element which is not in the sublist but somewhere in the backing list should result in &lt;b&gt;moving&lt;/b&gt; the item from its current position to the new position defined by the subset. This move may corrupt the internal range offsets of the sublist.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;The first issue seems easy to solve, for example by holding a reference of the parent set in the subset. But if another subset is created based on the first subset, we have to maintain a collections of parent sets.&lt;/p&gt;

&lt;p&gt;The second issue is similar to a direct modification of a backing list - which is not supported. The javadoc of sublist states&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The semantics of the list returned by this method become undefined if the backing list (i.e., this list) is structurally modified in any way other than via the returned list. (Structural modifications are those that change the size of this list, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results.)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;To solve this problem, the subList implementation has to track all modifications of the backing list and adjust it&apos;s internal range offsets accordingly. For example adding a duplicate item to a sublist, which exists  &apos;in front&apos; of the sublist will result &lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;moving the item to the new sublist position&lt;/li&gt;
	&lt;li&gt;decrement the range offsets of the sublist.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;So first of all I wrote a short javadoc comment for the sublist method:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    /**
     * Returns a view of the portion of &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; list between the specified 
     * fromIndex, inclusive, and toIndex, exclusive.
     * &amp;lt;p&amp;gt;
     * &amp;lt;i&amp;gt;(Violation)&amp;lt;/i&amp;gt; According to the &amp;lt;code&amp;gt;List&amp;lt;/code&amp;gt; &lt;span class=&quot;code-keyword&quot;&gt;interface&lt;/span&gt; the returned
     * sublist has to be backed by the original list. Because a &amp;lt;code&amp;gt;SetUniqueList&amp;lt;/code&amp;gt;
     * requires both a defined ordering of the list items &amp;lt;i&amp;gt;and&amp;lt;/i&amp;gt; uniqueness of
     * all list items, modifications cannot garantee consistant behavior of both
     * the backing list and the sub list. It is strongly recommended not to modify
     * the sublist. 
     * &amp;lt;p&amp;gt;
     * 
     * @param fromIndex
     * @param toIndex
     * @&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; 
     */

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Should we perhaps return the sublist as a UnmodifiableList?&lt;/p&gt;


</comment>
                            <comment id="13573550" author="tn" created="Thu, 7 Feb 2013 14:48:57 +0000"  >&lt;p&gt;Right now, when calling subList, a new, independent SetUniqueList is created which is filled with elements from the backing list of the specified range.&lt;/p&gt;

&lt;p&gt;The problem comes from the fact that this new SetUniqueList does not check for uniqueness in the backing list, but only in the sublist. If we would create an inner class (see for example ListOrderedMap), which would delegate the calls (after properly adjusting some arguments, e.g. calculate real index) to the backing SeUniqueList we could support the sublist contract.&lt;/p&gt;

&lt;p&gt;The order is maintained and the uniqueness is validated by the backing list.&lt;/p&gt;

&lt;p&gt;What do you think?&lt;/p&gt;</comment>
                            <comment id="13580278" author="t.vahrst" created="Sun, 17 Feb 2013 20:39:19 +0000"  >&lt;p&gt;Many new testcases for sublists.&lt;/p&gt;</comment>
                            <comment id="13580284" author="t.vahrst" created="Sun, 17 Feb 2013 20:51:40 +0000"  >&lt;p&gt;I am trying to create a sublist implementation which conforms to the required functions. The first attachement (SetUniqueListTest.patch) contains many new testcases for sublist, checking this functions. &lt;/p&gt;

&lt;p&gt;I implemented two possible solutions, more of that in the following posts (in the next days). During the coding I realized a further problem concerning ListIterator. ListIterator supports add/set/remove functionality, which means, that a ListIterator based on a sublist needs the corresponding sublist behavior. And ListIterator may start at a specified index, so this  means, that a ListIterator with index &amp;gt; 0 based on a SetUniqueList itself is a subList of the underlying SetUniqueList - with all the necessary behavior. &lt;/p&gt;

&lt;p&gt;So for the first iteration on this issue, I ommited these tests. I will provided them later...&lt;/p&gt;</comment>
                            <comment id="13580821" author="t.vahrst" created="Mon, 18 Feb 2013 20:36:29 +0000"  >&lt;p&gt;SetUniqueList.patch contains JUnit Tests and Variant No. 1 for SetUniqueList. I am not sure whether the patch has a correct format (I am not able to re-apply the patch in Netbeans...) so I attached the corresponding java files as well.&lt;/p&gt;

&lt;p&gt;Some comment to this solution: &lt;br/&gt;
1. During the implementation I recognized, that the existing implementation of subList() uses the subList() method on the decorated list and then creates a new Set and fills all elements of the sublist into the set. &lt;/p&gt;

&lt;p&gt;Now this issue requires, that a parent list has to be modified on certain invocations on a sublist - for example when adding an element to the sublist which exists in the parent list somewhere outside the range of the sublist. With the current sublist implementation, any attempt to modify a parent list fails with a ConcurrentModifiationException. So we have to reimplement the sublist functionality inside SetUniqueList and can not reuse the service of AbstractListDecorator.&lt;/p&gt;

&lt;p&gt;2. When we create a subList on a SetUniqueList, this sublist has to obbey the SetUniqueList contracts. The original parent list will have slightly different behavior when adding or setting values. When we create a second sublist based on the first sublist, this top most list has to provide SetUniqueList semantics.&lt;/p&gt;

&lt;p&gt;Example (from JUnit Tests)&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt; 
 subList2                    ! e ! f ! g !              offset = 2
 subList1            ! c ! d ! e ! f ! g ! h !          offset = 2
 list        ! a ! b ! c ! d ! e ! f ! g ! h ! i ! j !  offset = 0
             -----------------------------------------
 Index         0   1   2   3   4   5   6   7   8   9

 Adds a &apos;d&apos; to subList2. This should move the &apos;d&apos; in subList1 and list in the range of subList2
 Expected result:

 subList2                ! e ! f ! g ! d !              offset = 1
 subList1            ! c ! e ! f ! g ! d ! h !          offset = 2
 list        ! a ! b ! c ! e ! f ! g ! d ! h ! i ! j !  offset = 0
             -----------------------------------------
 Index         0   1   2   3   4   5   6   7   8   9
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt; 

&lt;p&gt;(The &apos;movement&apos; of &apos;d&apos; causes the ConcurrentModificationException mentioned above.)&lt;/p&gt;

&lt;p&gt;Because of this requirements I decided for Variant No. 1, that every SetUniqueList holds its own list and set and maintains a reference to it&apos;s parent SetUniqueList and an offset value. The SetUniqueList garantees, that all parent lists are updated according to the required functionality and that all offset values are adjusted if necessary. This solution does not use the sublist functionality of the decorated list but creates allway a new Set &lt;b&gt;and&lt;/b&gt; List.&lt;/p&gt;

&lt;p&gt;I copied the existing code for creating a new Set to also create a new List based on the existing list. &lt;/p&gt;

&lt;p&gt;At this time, there are two things missing:&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;a very details javadoc comment for the subList() method, explaining the behavior.&lt;/li&gt;
	&lt;li&gt;the implementation for listIterator().&lt;/li&gt;
&lt;/ol&gt;



&lt;p&gt;... to be continued with variant no. 2 ...&lt;/p&gt;





</comment>
                            <comment id="13592609" author="t.vahrst" created="Mon, 4 Mar 2013 20:35:53 +0000"  >&lt;p&gt;2nd variant of modified SetUniqueList and even more Testcases f&#252;r sublist.&lt;/p&gt;</comment>
                            <comment id="13592633" author="t.vahrst" created="Mon, 4 Mar 2013 21:02:33 +0000"  >&lt;p&gt;SetUniqueListTest.java now contains some new testcases to test the behavior of listiterators of sublists. &lt;/p&gt;

&lt;p&gt;SetUniqueList.v2.java is the 2nd variant I implemented. In contrast to the first attempt, this class does not inherit from AbstractListDecorator but inherits from java.util.AbstractList. It holds a reference to a underlying list which is &lt;b&gt;shared&lt;/b&gt; with all sublists. So every sublist holds the reference to the underlying list and maintains it&apos;s own set and a offset of its element range in the underlying list.&lt;/p&gt;

&lt;p&gt;This variant contains support for iterators and listiterators on sublists.&lt;/p&gt;

&lt;p&gt;I personally found this solution a bit more elegant than the first variant. &lt;/p&gt;
</comment>
                            <comment id="13604567" author="tn" created="Sun, 17 Mar 2013 10:22:33 +0000"  >&lt;p&gt;Hi Thomas,&lt;/p&gt;

&lt;p&gt;I have looked through both variants, but am still undecided.&lt;br/&gt;
Generally, I think we should keep the inheritance to AbstractSerializableListDecorator, as the class should remain a decorator. Adding more fields to the actual class also has the down-side that we need to make sure that serialization still works correctly, so I would prefer to create an inner static View class, which is returned when calling subList.&lt;/p&gt;

&lt;p&gt;I will further play with your patch, and give you more feedback.&lt;/p&gt;

&lt;p&gt;Thanks!&lt;/p&gt;</comment>
                            <comment id="13642120" author="tn" created="Thu, 25 Apr 2013 19:33:43 +0000"  >&lt;p&gt;I did take another look at your provided test-cases and I do not agree with the following behavior:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;adding an element in a subList that is contained in the backing list results in moving the element to the new location&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This is not what I would expect, and also the backing list does not do this, e.g. when calling add(obj) where obj is already contained in the list will result in no change at all. I think we should make it clear, that the returned subList is &lt;b&gt;backed&lt;/b&gt; by a SetUniqueList, thus adding elements that are in the backing list but not in the subList should not be added at all, as they are already present, just not visible in this view.&lt;/p&gt;</comment>
                            <comment id="13642987" author="t.vahrst" created="Fri, 26 Apr 2013 16:14:30 +0000"  >&lt;p&gt;Hi Thomas,&lt;br/&gt;
Christian Semrau, who reported this issue, provides in the issue description two possible solutions to the inconsistency of sublist. In a nutshell:&lt;br/&gt;
When adding a value to a SubList and this value exists in the underlying SetUniqueList,&lt;br/&gt;
1. the subList behaves like a SetUniqueList and the existing value is &lt;b&gt;moved&lt;/b&gt; to the new position - thus breaking the contract of the underlying SetUniqueList.&lt;br/&gt;
2. nothing happens because the value already exists - which means that the &lt;b&gt;sublist&lt;/b&gt; does not behave like a SetUniqueList.&lt;/p&gt;

&lt;p&gt;Christian preferred the first solution, so I implemented all JUnit tests (and the proposed changes of SetUniqueList) according to solution no. 1&lt;/p&gt;


&lt;p&gt;If we decide to switch to solution no. 2, I would at first change all unit tests according to this solution. Ok?&lt;/p&gt;

&lt;p&gt;btw: invoking set() method with a value that exists outside the sublist will move the value to the new position, right? And also: removing a value in a sublist which exists outside the sublist range will remove this value in the underlying SEtUnqiqueList?&lt;/p&gt;

&lt;p&gt;(btw 2: did I allready mention that I am not happy at all with our attempt to solve a obviously inconsistent construct? Whether solution No. 1 or 2: I wonder how to write a good javadoc comment for sublist() which describes the behavior in a clear manner... The possibly most simple javadoc could read: &quot;This method returns a sublist which is umodifiable.&quot; &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="13643093" author="tn" created="Fri, 26 Apr 2013 18:16:33 +0000"  >&lt;p&gt;Hi Thomas,&lt;/p&gt;

&lt;p&gt;I did not mean to criticize your outstanding effort (and your choice was perfectly reasonable).&lt;br/&gt;
Maybe we should really do as you suggest and return an unmodifiable list for 4.0 to be on the safe side (although you put so much effort into this issue).&lt;/p&gt;

&lt;p&gt;What do you think?&lt;/p&gt;</comment>
                            <comment id="13643603" author="t.vahrst" created="Sat, 27 Apr 2013 08:38:17 +0000"  >&lt;p&gt;Hi Thomas,&lt;br/&gt;
oops, I definitly do not feel criticized - I am sorry if my comment sounds this way. In fact this issue is a interesting programming challenge. Regardless of the efforts: I am convinced that SetUniqueList&apos;s &apos;mixture&apos; of List API and Set behavior makes it very difficult to provide a simple, intuitive and consistent implementation of the sublist() method.&lt;/p&gt;

&lt;p&gt;So I would appreciate the decision to let sublist() return an unmodifiable list. &lt;/p&gt;</comment>
                            <comment id="13643637" author="tn" created="Sat, 27 Apr 2013 11:57:35 +0000"  >&lt;p&gt;Applied change in r1476557.&lt;/p&gt;

&lt;p&gt;Thanks for all the effort so far!&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12633927">COLLECTIONS-444</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12569854" name="SetUniqueList.java" size="18862" author="t.vahrst" created="Mon, 18 Feb 2013 20:34:05 +0000"/>
                            <attachment id="12569853" name="SetUniqueList.patch" size="51590" author="t.vahrst" created="Mon, 18 Feb 2013 20:34:05 +0000"/>
                            <attachment id="12571946" name="SetUniqueList.v2.java" size="20855" author="t.vahrst" created="Mon, 4 Mar 2013 20:35:53 +0000"/>
                            <attachment id="12571947" name="SetUniqueListTest.java" size="79006" author="t.vahrst" created="Mon, 4 Mar 2013 20:35:53 +0000"/>
                            <attachment id="12569855" name="SetUniqueListTest.java" size="59847" author="t.vahrst" created="Mon, 18 Feb 2013 20:34:05 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>5.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sat, 26 Jan 2013 16:30:52 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>18691</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            3 years, 30 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0fth3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>90373</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>