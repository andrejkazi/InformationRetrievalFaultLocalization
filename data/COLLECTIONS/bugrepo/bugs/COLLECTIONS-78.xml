<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sat Nov 19 23:27:09 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/COLLECTIONS-78/COLLECTIONS-78.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[COLLECTIONS-78] BinaryHeap.remove(Object) seems to break heap order</title>
                <link>https://issues.apache.org/jira/browse/COLLECTIONS-78</link>
                <project id="12310465" key="COLLECTIONS">Commons Collections</project>
                    <description>&lt;p&gt;I am currently attempting to migrate from my own implementation of a BinaryHeap&lt;br/&gt;
to the implementation in org.apache.commons.collections.BinaryHeap.&lt;/p&gt;

&lt;p&gt;I have some existing unit tests for my implementation which fail when I run them&lt;br/&gt;
on the commons BinaryHeap.  Below is source-code for the JUnit test which fails.&lt;br/&gt;
 The test &apos;testRandom&apos; is the test that fails.  This test creates heaps&lt;br/&gt;
initialised with 100 randomly generated Integers and proceeds to add and remove&lt;br/&gt;
random elements from these heaps and then checks the heap order.  Some of the&lt;br/&gt;
elements that are removed may not exist in the heap.  Heap order is checked by&lt;br/&gt;
disassembling the heap using BinaryHeap.pop() and ensuring that subsequent&lt;br/&gt;
elements are &amp;gt;= earlier elements.&lt;/p&gt;

&lt;p&gt;The problem appears to be related to the BinaryHeap.remove(Object) method-- if&lt;br/&gt;
this is commented out the test succeeds.  It may be the case that the problem&lt;br/&gt;
occurs when non-existant elements are removed, but I have not attempted to&lt;br/&gt;
verify this.  &lt;/p&gt;


&lt;p&gt;---------&lt;br/&gt;
BinaryHeapTest.java&lt;br/&gt;
---------&lt;br/&gt;
/*&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;JASA Java Auction Simulator API&lt;/li&gt;
	&lt;li&gt;Copyright (C) 2001-2003 Steve Phelps&lt;br/&gt;
 *&lt;/li&gt;
	&lt;li&gt;This program is free software; you can redistribute it and/or&lt;/li&gt;
	&lt;li&gt;modify it under the terms of the GNU General Public License as&lt;/li&gt;
	&lt;li&gt;published by the Free Software Foundation; either version 2 of&lt;/li&gt;
	&lt;li&gt;the License, or (at your option) any later version.&lt;br/&gt;
 *&lt;/li&gt;
	&lt;li&gt;This program is distributed in the hope that it will be useful,&lt;/li&gt;
	&lt;li&gt;but WITHOUT ANY WARRANTY; without even the implied warranty of&lt;/li&gt;
	&lt;li&gt;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&lt;/li&gt;
	&lt;li&gt;See the GNU General Public License for more details.&lt;br/&gt;
 */&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;package test.uk.ac.liv.util;&lt;/p&gt;

&lt;p&gt;import test.uk.ac.liv.PRNGTestSeeds;&lt;/p&gt;

&lt;p&gt;import junit.framework.*;&lt;/p&gt;

&lt;p&gt;//import uk.ac.liv.util.*;&lt;/p&gt;

&lt;p&gt;import org.apache.commons.collections.BinaryHeap;&lt;/p&gt;

&lt;p&gt;import java.util.Random;&lt;br/&gt;
import java.util.Iterator;&lt;br/&gt;
import java.util.LinkedList;&lt;/p&gt;

&lt;p&gt;public class BinaryHeapTest extends TestCase {&lt;/p&gt;

&lt;p&gt;  BinaryHeap h1;&lt;/p&gt;

&lt;p&gt;  public BinaryHeapTest( String name ) &lt;/p&gt;
{
    super(name);
  }

&lt;p&gt;  public void setUp() &lt;/p&gt;
{

    h1 = new BinaryHeap();

    h1.insert(new Integer(1));
    h1.insert(new Integer(3));
    h1.insert(new Integer(9));
    h1.insert(new Integer(3));
    h1.insert(new Integer(5));
    h1.insert(new Integer(7));
  }

&lt;p&gt;  public void test() &lt;/p&gt;
{
    System.out.println(&quot;h1 = &quot; + h1);
    assertTrue( h1.contains(new Integer(3)) );
    assertTrue( h1.contains(new Integer(9)) );
    assertTrue( h1.contains(new Integer(1)) );
    assertTrue( h1.contains(new Integer(5)) );
    assertTrue( !h1.contains(new Integer(10)) );
    assertTrue( !h1.contains(new Integer(-1)) );
    Object x = h1.pop();
    System.out.println(&quot;h1 after removing first = &quot; + h1);
    checkOrder(h1);
    assertTrue( ((Integer) x).equals(new Integer(1)));
    assertTrue( !h1.contains(new Integer(1)) );
    assertTrue( h1.contains(new Integer(3)) );
    assertTrue( h1.contains(new Integer(9)) );
    assertTrue( h1.contains(new Integer(5)) );
    h1.remove(new Integer(9));
    System.out.println(&quot;h1 after removing 9 = &quot; + h1);
    assertTrue( h1.contains(new Integer(3)) );
    assertTrue( !h1.contains(new Integer(9)) );
    assertTrue( h1.remove( new Integer(3) ) );
    System.out.println(&quot;h1 after removing 3 = &quot; + h1);
    // assertTrue( ! h1.contains(new Integer(3)) );
    x = h1.pop();
    System.out.println(&quot;h1 after removing first = &quot; + h1);
    h1.pop();
    System.out.println(&quot;h1 after removing first = &quot; + h1);
    assertTrue( h1.remove( new Integer(7) ) );
    System.out.println(&quot;h1 after removing 7 = &quot; + h1);
    assertTrue( h1.isEmpty() );
    assertTrue( ! h1.remove( new Integer(7) ) );
    h1.add( new Integer(666) );
    h1.add( new Integer(667) );
    assertTrue( h1.remove(new Integer(667)) );
    assertTrue( h1.size() == 1 );
    assertTrue( ! h1.contains(new Integer(667)) );
    assertTrue( h1.remove(new Integer(666)) );

  }


&lt;p&gt;  public void checkOrder( BinaryHeap h ) {&lt;br/&gt;
    System.out.println(&quot;Checking order of &quot; + h);&lt;br/&gt;
    Integer lastNum = null;&lt;br/&gt;
    LinkedList l = new LinkedList();&lt;br/&gt;
    while ( !h.isEmpty() ) {&lt;br/&gt;
      Integer num = (Integer) h.pop();&lt;br/&gt;
      System.out.println(num);&lt;br/&gt;
      if ( lastNum != null &amp;amp;&amp;amp; num.intValue() &amp;lt; lastNum.intValue() ) &lt;/p&gt;
{
        System.out.println(&quot;!!??***  &quot; + num + &quot; smaller than &quot; + lastNum);
      }
&lt;p&gt;      assertTrue( lastNum == null || num.intValue() &amp;gt;= lastNum.intValue() );&lt;br/&gt;
      lastNum = num;&lt;br/&gt;
      l.add(num);&lt;br/&gt;
    }&lt;br/&gt;
    Iterator it = l.iterator();&lt;br/&gt;
    while ( it.hasNext() ) &lt;/p&gt;
{
      h.add( it.next() );
    }
&lt;p&gt;  }&lt;/p&gt;

&lt;p&gt;  public void testRandom() {&lt;br/&gt;
    Random randGenerator = new Random(PRNGTestSeeds.UNIT_TEST_SEED);&lt;br/&gt;
    for( int i=0; i&amp;lt;1000; i++ ) {&lt;br/&gt;
      BinaryHeap h = new BinaryHeap();&lt;br/&gt;
      for( int r=0; r&amp;lt;100; r++ ) &lt;/p&gt;
{
        h.add( new Integer( randGenerator.nextInt(100)) );
      }
&lt;p&gt;      System.out.println(&quot;Starting with heap &quot; + h);&lt;br/&gt;
      for( int r=0; r&amp;lt;20; r++ ) &lt;/p&gt;
{
        System.out.println(&quot;Attempting to remove &quot; + r);
        System.out.println(&quot;result = &quot; + h.remove( new Integer(r) ) );
        Integer n = new Integer( randGenerator.nextInt(100) );
        System.out.println(&quot;Adding &quot; + n);
        h.add(n);
      }
&lt;p&gt;      checkOrder(h);&lt;br/&gt;
    }&lt;br/&gt;
  }&lt;/p&gt;


&lt;p&gt;  public static void main( String[] args ) &lt;/p&gt;
{
    junit.textui.TestRunner.run (suite());
  }

&lt;p&gt;  public static Test suite() &lt;/p&gt;
{
    return new TestSuite(BinaryHeapTest.class);
  }

&lt;p&gt;}&lt;/p&gt;


&lt;p&gt;/*&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;JASA Java Auction Simulator API&lt;/li&gt;
	&lt;li&gt;Copyright (C) 2001-2003 Steve Phelps&lt;br/&gt;
 *&lt;/li&gt;
	&lt;li&gt;This program is free software; you can redistribute it and/or&lt;/li&gt;
	&lt;li&gt;modify it under the terms of the GNU General Public License as&lt;/li&gt;
	&lt;li&gt;published by the Free Software Foundation; either version 2 of&lt;/li&gt;
	&lt;li&gt;the License, or (at your option) any later version.&lt;br/&gt;
 *&lt;/li&gt;
	&lt;li&gt;This program is distributed in the hope that it will be useful,&lt;/li&gt;
	&lt;li&gt;but WITHOUT ANY WARRANTY; without even the implied warranty of&lt;/li&gt;
	&lt;li&gt;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&lt;/li&gt;
	&lt;li&gt;See the GNU General Public License for more details.&lt;br/&gt;
 */&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;-------&lt;br/&gt;
PRNGTestSeeds.java&lt;br/&gt;
-------&lt;/p&gt;

&lt;p&gt;package test.uk.ac.liv;&lt;/p&gt;

&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;The PRNG seed to use for deterministing unit-testing of seedable classes.&lt;/li&gt;
	&lt;li&gt;This was introduced for ecj10, which uses a seed based on the&lt;/li&gt;
	&lt;li&gt;current system time when using the null argument constructor.&lt;br/&gt;
 *&lt;/li&gt;
	&lt;li&gt;@author Steve Phelps&lt;/li&gt;
	&lt;li&gt;@version $Revision: 1.2 $&lt;br/&gt;
 */&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;public class PRNGTestSeeds &lt;/p&gt;
{

  /**
   * The seed to use for all unit tests.
   */
  public static final long UNIT_TEST_SEED = 1465187;

}</description>
                <environment>&lt;p&gt;Operating System: Linux&lt;br/&gt;
Platform: PC&lt;/p&gt;</environment>
        <key id="12341179">COLLECTIONS-78</key>
            <summary>BinaryHeap.remove(Object) seems to break heap order</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="sphelps@csc.liv.ac.uk">Steve Phelps</reporter>
                        <labels>
                    </labels>
                <created>Tue, 30 Dec 2003 16:46:06 +0000</created>
                <updated>Sat, 15 Mar 2008 21:36:00 +0000</updated>
                            <resolved>Sat, 15 Mar 2008 21:36:00 +0000</resolved>
                                    <version>Nightly Builds</version>
                                                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12405724" author="scolebourne@joda.org" created="Wed, 31 Dec 2003 07:47:17 +0000"  >&lt;p&gt;The problem lies with the remove 19. Unfortunately, I don&apos;t understand the &lt;br/&gt;
meachanics of this class, so I could be stuck solving it &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12405725" author="phil@steitz.com" created="Wed, 31 Dec 2003 17:13:30 +0000"  >&lt;p&gt;There is nothing obviously wrong with the iterator remove() and simple&lt;br/&gt;
add/remove tests work fine.  The random test above fails sporadically, always&lt;br/&gt;
for elements which have had copies removed.  There is usually just one element&lt;br/&gt;
out of order (out of 100-110).  Very strange.  I will work on this.  &lt;/p&gt;</comment>
                            <comment id="12405726" author="sphelps@csc.liv.ac.uk" created="Wed, 31 Dec 2003 17:15:59 +0000"  >&lt;p&gt;I&apos;ve done a bit more investigation of the actual source for commons.BinaryHeap,&lt;br/&gt;
and I think that there might be a comparision missing from the remove() method&lt;br/&gt;
of the Iterator returned by BinaryHeap.iterator().  This iterator is used by&lt;br/&gt;
AbstractCollection to implement the remove(Object) method.  &lt;/p&gt;

&lt;p&gt;Attached is the code for the method remove(Object x) from my own implementation&lt;br/&gt;
of BinaryHeap.  Notice that after we swap the last element with the deleted&lt;br/&gt;
element we need to do a comparision before deciding whether to percolate up or&lt;br/&gt;
down the heap.  The full code for my BinaryHeap is included at the end of this&lt;br/&gt;
message.&lt;/p&gt;


&lt;p&gt;  public boolean remove( Object x ) &lt;/p&gt;
{
    return remove(indexOf(x));
  }&lt;br/&gt;
&lt;br/&gt;
  public boolean remove( int index ) {&lt;br/&gt;
    if ( index &amp;lt; 1 ) {
      return false;
    }&lt;br/&gt;
    Object x = get(size());&lt;br/&gt;
    set(index, x);&lt;br/&gt;
    contents.shrink();&lt;br/&gt;
    if ( index &amp;lt;= size() ) {&lt;br/&gt;
      if ( index &amp;gt; 1 &amp;amp;&amp;amp; compare(x, get(index/2)) &amp;lt; 0 ) {
        percolateUp(index);
      } else {
        percolateDown(index);
      }&lt;br/&gt;
    }&lt;br/&gt;
    return true;&lt;br/&gt;
  }&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
------&lt;br/&gt;
uk.ac.liv.util.BinaryHeap&lt;br/&gt;
------&lt;br/&gt;
/*&lt;br/&gt;
 * JASA Java Auction Simulator API&lt;br/&gt;
 * Copyright (C) 2001-2003 Steve Phelps&lt;br/&gt;
 *&lt;br/&gt;
 * This program is free software; you can redistribute it and/or&lt;br/&gt;
 * modify it under the terms of the GNU General Public License as&lt;br/&gt;
 * published by the Free Software Foundation; either version 2 of&lt;br/&gt;
 * the License, or (at your option) any later version.&lt;br/&gt;
 *&lt;br/&gt;
 * This program is distributed in the hope that it will be useful,&lt;br/&gt;
 * but WITHOUT ANY WARRANTY; without even the implied warranty of&lt;br/&gt;
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&lt;br/&gt;
 * See the GNU General Public License for more details.&lt;br/&gt;
 */&lt;br/&gt;
&lt;br/&gt;
package uk.ac.liv.util;&lt;br/&gt;
&lt;br/&gt;
import java.util.Comparator;&lt;br/&gt;
import java.util.Iterator;&lt;br/&gt;
import java.util.Collection;&lt;br/&gt;
import java.util.Vector;&lt;br/&gt;
&lt;br/&gt;
import java.io.Serializable;&lt;br/&gt;
&lt;br/&gt;
/**&lt;br/&gt;
 * This Collection class represents a binary heap, also known as a priority queue.&lt;br/&gt;
 *&lt;br/&gt;
 * The underlying data structure is a Vector.  Items are organised in such&lt;br/&gt;
 * a way that retrieving the smallest, or largest, item can be done in O(1) time.&lt;br/&gt;
 *&lt;br/&gt;
 * @author Steve Phelps&lt;br/&gt;
 * @version $Revision: 1.8 $&lt;br/&gt;
 *&lt;br/&gt;
 */&lt;br/&gt;
&lt;br/&gt;
public class BinaryHeap implements Collection, PriorityQueue, Serializable {&lt;br/&gt;
&lt;br/&gt;
  /**&lt;br/&gt;
   * The default initial capacity of the underlying Vector.&lt;br/&gt;
   */&lt;br/&gt;
  static final int DEFAULT_CAPACITY = 100;&lt;br/&gt;
&lt;br/&gt;
  /**&lt;br/&gt;
   * Used to assign a unique id to each heap.&lt;br/&gt;
   */&lt;br/&gt;
  static IdAllocator idAllocator = new IdAllocator();&lt;br/&gt;
&lt;br/&gt;
  /**&lt;br/&gt;
   * A unique id for this heap.  Its used mainly for debugging purposes.&lt;br/&gt;
   */&lt;br/&gt;
  long id;&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
  /**&lt;br/&gt;
   * The underlying Vector data structure holding the elements of the heap.&lt;br/&gt;
   */&lt;br/&gt;
  HeapContents contents;&lt;br/&gt;
&lt;br/&gt;
  /**&lt;br/&gt;
   * The Comparator used to order items in the heap.  If it is not present then the&lt;br/&gt;
   * compareTo method of the Comparable interface is used.&lt;br/&gt;
   */&lt;br/&gt;
  Comparator comparator;&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
  /**&lt;br/&gt;
   * Inner class used to iterate over items in the heap.&lt;br/&gt;
   */&lt;br/&gt;
  class HeapIterator implements Iterator {&lt;br/&gt;
&lt;br/&gt;
      int currentIndex = 1;&lt;br/&gt;
&lt;br/&gt;
      public HeapIterator() {&lt;br/&gt;
      }&lt;br/&gt;
&lt;br/&gt;
      public boolean hasNext() {
        return currentIndex &amp;lt;= size();
      }&lt;br/&gt;
&lt;br/&gt;
      public Object next() {
        return get(currentIndex++);
      }&lt;br/&gt;
&lt;br/&gt;
      public void remove() {&lt;br/&gt;
      }&lt;br/&gt;
&lt;br/&gt;
    }&lt;br/&gt;
&lt;br/&gt;
  /**&lt;br/&gt;
   * Construct the binary heap.  Objects will be ordered according to the Comparable&lt;br/&gt;
   * interface.&lt;br/&gt;
   */&lt;br/&gt;
  public BinaryHeap( )&lt;br/&gt;
  {
    this(DEFAULT_CAPACITY);
  }&lt;br/&gt;
&lt;br/&gt;
  /**&lt;br/&gt;
    * Construct the binary heap.&lt;br/&gt;
    *&lt;br/&gt;
    * @param comparator If this comparator is non-null then it is used to order&lt;br/&gt;
items in the heap.&lt;br/&gt;
    * @param capacity The initial capacity of the underlying Vector&lt;br/&gt;
    */&lt;br/&gt;
  public BinaryHeap( Comparator comparator, int capacity ) {
    id = idAllocator.nextId();
    contents = new HeapContents(capacity);
    this.comparator = comparator;
  }&lt;br/&gt;
&lt;br/&gt;
  /**&lt;br/&gt;
   * Construct the binary heap.&lt;br/&gt;
   * @param capacity The initial capcity of the underlying Vector&lt;br/&gt;
   */&lt;br/&gt;
  public BinaryHeap( int capacity ) {
    this(null, capacity);
  }&lt;br/&gt;
&lt;br/&gt;
  public BinaryHeap( Comparator comparator ) {
    this(comparator, DEFAULT_CAPACITY);
  }&lt;br/&gt;
&lt;br/&gt;
  /**&lt;br/&gt;
   * Compares two objects using either the heap&apos;s comparator, if it is present, or&lt;br/&gt;
   * the result of the compareTo method on o1.  Both o1 and o2 must implement&lt;br/&gt;
   * Comparable if no comparator is present.&lt;br/&gt;
   *&lt;br/&gt;
   * @param o1 The first object to compare&lt;br/&gt;
   * @param o2 The second object to compare&lt;br/&gt;
   */&lt;br/&gt;
  public int compare( Object o1, Object o2 ) {&lt;br/&gt;
    if ( comparator != null ) {
      return comparator.compare(o1,o2);
    } else {
      return ((Comparable) o1).compareTo((Comparable) o2);
    }&lt;br/&gt;
  }&lt;br/&gt;
&lt;br/&gt;
  public Iterator iterator() {
    return new HeapIterator();
  }&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
  /**&lt;br/&gt;
   * Transfer the first item of this heap into the second heap.&lt;br/&gt;
   *&lt;br/&gt;
   * @param toOther The heap to transfer to&lt;br/&gt;
   */&lt;br/&gt;
  public void transfer( PriorityQueue toOther ) {&lt;br/&gt;
    // if ( ! isEmpty() ) {
      toOther.insert(removeFirst());
    // }&lt;br/&gt;
  }&lt;br/&gt;
&lt;br/&gt;
  /**&lt;br/&gt;
   * Insert into the priority queue, maintaining heap order.&lt;br/&gt;
   * Duplicates are allowed.&lt;br/&gt;
   *&lt;br/&gt;
   * @param x the item to insert.&lt;br/&gt;
   */&lt;br/&gt;
  public void insert( Object x ) {
    int index = size()+1;
    set(index, x);
    percolateUp(index);
  }&lt;br/&gt;
&lt;br/&gt;
  public boolean add( Object x ) {
    insert(x);
    return true;
  }&lt;br/&gt;
&lt;br/&gt;
  /**&lt;br/&gt;
   * Find the smallest item in the priority queue.&lt;br/&gt;
   *&lt;br/&gt;
   * @return the smallest item, or null, if empty.&lt;br/&gt;
   */&lt;br/&gt;
  public Object getFirst() {&lt;br/&gt;
    if( isEmpty() ) {
      return null;
    }&lt;br/&gt;
    return get(1);&lt;br/&gt;
  }&lt;br/&gt;
&lt;br/&gt;
  /**&lt;br/&gt;
   * Test if the priority queue is logically empty.&lt;br/&gt;
   *&lt;br/&gt;
   * @return true if empty, false otherwise.&lt;br/&gt;
   */&lt;br/&gt;
  public boolean isEmpty() {
    return size() == 0;
  }&lt;br/&gt;
&lt;br/&gt;
  public boolean retainAll( Collection other ) {
    throw new UnsupportedOperationException(&quot;BinaryHeap does not implement
retainAll&quot;);
  }&lt;br/&gt;
&lt;br/&gt;
  public boolean removeAll( Collection other ) {
    throw new UnsupportedOperationException(&quot;BinaryHeap does not implement
removeAll&quot;);
  }&lt;br/&gt;
&lt;br/&gt;
  public boolean addAll( Collection other ) {
    throw new UnsupportedOperationException(&quot;BinaryHeap does not implement addAll&quot;);
  }&lt;br/&gt;
&lt;br/&gt;
  public boolean containsAll( Collection other ) {
    throw new UnsupportedOperationException(&quot;BinaryHeap does not implement
containsAll&quot;);
  }&lt;br/&gt;
&lt;br/&gt;
  /**&lt;br/&gt;
   * Make the priority queue logically empty.&lt;br/&gt;
   */&lt;br/&gt;
  public void clear() {
    contents.clear();
  }&lt;br/&gt;
&lt;br/&gt;
  public int indexOf( Object key ) {&lt;br/&gt;
    for( int i=1; i&amp;lt;=contents.getCurrentSize(); i++ ) {&lt;br/&gt;
      if ( key.equals(get&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;) ) {
        return i;
      }&lt;br/&gt;
    }&lt;br/&gt;
    return -1;&lt;br/&gt;
  }&lt;br/&gt;
&lt;br/&gt;
  public Object pop() {
    return removeFirst();
  }&lt;br/&gt;
&lt;br/&gt;
  public Object get() {
    return getFirst();
  }&lt;br/&gt;
&lt;br/&gt;
  public Object peek() {
    return getFirst();
  }&lt;br/&gt;
&lt;br/&gt;
  public boolean contains( Object key ) {
    return indexOf(key) &amp;gt; 0;
  }&lt;br/&gt;
&lt;br/&gt;
  public boolean remove( Object x ) {
    return remove(indexOf(x));
  }

&lt;p&gt;  public boolean remove( int index ) {&lt;br/&gt;
    if ( index &amp;lt; 1 ) &lt;/p&gt;
{
      return false;
    }
&lt;p&gt;    Object x = get(size());&lt;br/&gt;
    set(index, x);&lt;br/&gt;
    contents.shrink();&lt;br/&gt;
    if ( index &amp;lt;= size() ) {&lt;br/&gt;
      if ( index &amp;gt; 1 &amp;amp;&amp;amp; compare(x, get(index/2)) &amp;lt; 0 ) &lt;/p&gt;
{
        percolateUp(index);
      }
&lt;p&gt; else &lt;/p&gt;
{
        percolateDown(index);
      }
&lt;p&gt;    }&lt;br/&gt;
    return true;&lt;br/&gt;
  }&lt;/p&gt;

&lt;p&gt;  /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Remove the smallest item from the priority queue.&lt;/li&gt;
	&lt;li&gt;@return the smallest item, or null, if empty.&lt;br/&gt;
   */&lt;br/&gt;
  public Object removeFirst() {&lt;br/&gt;
    if( isEmpty() ) 
{
        return null;
    }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Object minItem = getFirst();&lt;br/&gt;
    if ( size() &amp;gt; 1 ) &lt;/p&gt;
{
      set(1, get(size()));
      percolateDown(1);
    }
&lt;p&gt;    contents.shrink();&lt;/p&gt;

&lt;p&gt;    return minItem;&lt;br/&gt;
  }&lt;/p&gt;

&lt;p&gt;  public String toString() {&lt;br/&gt;
    StringBuffer out = new StringBuffer(&quot;(&quot; + getClass() + &quot; id:&quot; + id + &quot;&lt;br/&gt;
size:&quot; + size() + &quot; contents&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;\n&quot;);&lt;br/&gt;
    Iterator i = new HeapIterator();&lt;br/&gt;
    while ( i.hasNext() ) &lt;/p&gt;
{
      out.append(&quot;\t&quot; + i.next() + &quot;\n&quot;);
    }
&lt;p&gt;    out.append(&quot;))&quot;);&lt;br/&gt;
    return out.toString();&lt;br/&gt;
  }&lt;/p&gt;

&lt;p&gt;  public Object[] toArray() &lt;/p&gt;
{
    return contents.toArray();
  }&lt;br/&gt;
&lt;br/&gt;
  public Object[] toArray( Object[] a ) {
    return contents.toArray(a);
  }&lt;br/&gt;
&lt;br/&gt;
  public int size() {
    return contents.getCurrentSize();
  }&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
  /**&lt;br/&gt;
   * Internal method to percolate down in the heap.&lt;br/&gt;
   *&lt;br/&gt;
   * @param hole the index at which the percolate begins.&lt;br/&gt;
   */&lt;br/&gt;
  protected void percolateDown( int hole ) {&lt;br/&gt;
    int child;&lt;br/&gt;
    Object tmp = get(hole);&lt;br/&gt;
&lt;br/&gt;
    for( ; hole * 2 &amp;lt;= size(); hole = child ) {&lt;br/&gt;
      child = hole * 2;&lt;br/&gt;
      if( child != size() &amp;amp;&amp;amp;&lt;br/&gt;
              compare(get(child+1), get(child)) &amp;lt; 0 )&lt;br/&gt;
          child++;&lt;br/&gt;
      if( compare(get(child), tmp) &amp;lt; 0 ) {
        set(hole, get(child));
      } else {
        break;
      }&lt;br/&gt;
    }&lt;br/&gt;
    set(hole, tmp);&lt;br/&gt;
  }&lt;br/&gt;
&lt;br/&gt;
  protected void percolateUp( int hole ) {&lt;br/&gt;
    Object x = get(hole);&lt;br/&gt;
    for( ; hole &amp;gt; 1 &amp;amp;&amp;amp; compare(x, get(hole/2)) &amp;lt; 0; hole /= 2 ) {
      set(hole, get(hole/2));
    }&lt;br/&gt;
    set(hole,x);&lt;br/&gt;
  }&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
  protected void set( int index, Object x ) {
    contents.set(index, x);
  }&lt;br/&gt;
&lt;br/&gt;
  protected Object get( int index ) {
    return contents.get(index);
  }&lt;br/&gt;
&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
/**&lt;br/&gt;
 * Basically a wrapper for Vector with indexing starting at 1.&lt;br/&gt;
 */&lt;br/&gt;
&lt;br/&gt;
class HeapContents implements Serializable {&lt;br/&gt;
&lt;br/&gt;
  /**&lt;br/&gt;
   * The underlying data&lt;br/&gt;
   */&lt;br/&gt;
  private Vector contents;&lt;br/&gt;
&lt;br/&gt;
 /**&lt;br/&gt;
   * The current size of the heap.&lt;br/&gt;
   */&lt;br/&gt;
  private int currentSize, maxSize = 0;&lt;br/&gt;
&lt;br/&gt;
  public HeapContents( int capacity ) {
    contents = new Vector(capacity);
    currentSize = 0;
  }&lt;br/&gt;
&lt;br/&gt;
  protected void grow( int increment ) {
    currentSize += increment;
    contents.ensureCapacity(currentSize);
  }&lt;br/&gt;
&lt;br/&gt;
  public void set( int index, Object obj ) {&lt;br/&gt;
    if ( index &amp;gt; currentSize ) {
      grow(index-currentSize);
    }&lt;br/&gt;
    if ( index &amp;gt; maxSize ) {
      maxSize = index;
      contents.add(index-1, obj);
    } else {
      contents.set(index-1, obj);
    }&lt;br/&gt;
  }&lt;br/&gt;
&lt;br/&gt;
  public Object get( int index ) {
    return contents.get(index-1);
  }&lt;br/&gt;
&lt;br/&gt;
  public void shrink() {
    currentSize--;
  }&lt;br/&gt;
&lt;br/&gt;
  public int getCurrentSize() {
    return currentSize;
  }&lt;br/&gt;
&lt;br/&gt;
  public void clear() {
    currentSize = 0;
  }&lt;br/&gt;
&lt;br/&gt;
  public Object[] toArray() {
    return contents.toArray();
  }

&lt;p&gt;  public Object[] toArray( Object[] a ) &lt;/p&gt;
{
    return contents.toArray(a);
  }
&lt;p&gt;}&lt;/p&gt;</comment>
                            <comment id="12405727" author="phil@steitz.com" created="Thu, 1 Jan 2004 02:22:57 +0000"  >&lt;p&gt;Ouch!  Yes, looks &quot;obviously wrong&quot; to always percolate down.  Interestingly,&lt;br/&gt;
the pop() operations in checkOrder() usually repair the tree before an element&lt;br/&gt;
pops off out of sequence, which explains the low incidence of failures.&lt;/p&gt;

&lt;p&gt;For example, the following test (using checkOrder() above) succeeds, but&lt;br/&gt;
produces output showing what looks to me to be bad heap state after the remove.&lt;br/&gt;
 The pop()s in checkOrder() repair the damage (when 0 is popped).&lt;/p&gt;

&lt;p&gt;public void testAddRemove() &lt;/p&gt;
{
        BinaryHeap h = new BinaryHeap();
        h.add(new Integer(0));
        h.add(new Integer(2));
        h.add(new Integer(4));
        h.add(new Integer(3));
        h.add(new Integer(8));
        h.add(new Integer(10));
        h.add(new Integer(12));
        h.add(new Integer(3));
        System.out.println(h);
        h.remove(new Integer(12));
        System.out.println(h);
        checkOrder(h);
    }

&lt;p&gt;Output:&lt;/p&gt;

&lt;p&gt;[ 0, 2, 4, 3, 8, 10, 12, 3 ]&lt;br/&gt;
[ 0, 2, 4, 3, 8, 10, 3 ] &amp;lt;-- 3 should have percolated up after taking 12&apos;s spot.&lt;/p&gt;

&lt;p&gt;A small test case like above showing API failure would be nice.&lt;/p&gt;
</comment>
                            <comment id="12405728" author="scolebourne@joda.org" created="Fri, 2 Jan 2004 02:07:03 +0000"  >&lt;p&gt;Test case that fails:&lt;br/&gt;
    public void testAddRemove() &lt;/p&gt;
{
        resetEmpty();
        BinaryBuffer heap = (BinaryBuffer) collection;
        heap.add(new Integer(0));
        heap.add(new Integer(2));
        heap.add(new Integer(4));
        heap.add(new Integer(3));
        heap.add(new Integer(8));
        heap.add(new Integer(10));
        heap.add(new Integer(12));
        heap.add(new Integer(3));
        confirmed.addAll(heap);
        System.out.println(heap);
        Object obj = new Integer(10);
        heap.remove(obj);
        confirmed.remove(obj);
        System.out.println(heap);
        verify();
    }</comment>
                            <comment id="12405729" author="phil@steitz.com" created="Fri, 2 Jan 2004 02:55:44 +0000"  >&lt;p&gt;Thanks, Stephen.  I am completing final testing/review of a fix Modifing&lt;br/&gt;
remove() to decide whether to percolate up or down, and adding percolateUp&lt;br/&gt;
methods that take start indexes.  All tests (incl the one you just suggested w/&lt;br/&gt;
&quot;BinaryHeap&quot; in place of &quot;BinaryBuffer&quot;) pass.  &lt;/p&gt;</comment>
                            <comment id="12405730" author="phil@steitz.com" created="Fri, 2 Jan 2004 08:35:25 +0000"  >&lt;p&gt;Fixed in nightly builds starting 1/2/04.&lt;/p&gt;

&lt;p&gt;Modified iterator remove() to compare repositioned &quot;last&quot; element to its new&lt;br/&gt;
parent to decide whether to percolate up or down.  Added percolateUp methods&lt;br/&gt;
with starting indexes to support this.  &lt;/p&gt;

&lt;p&gt;Thanks, Steve, for reporting (and identifying the source of) this bug.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_10010" key="com.atlassian.jira.plugin.system.customfieldtypes:importid">
                        <customfieldname>Bugzilla Id</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>25818</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 31 Dec 2003 07:47:17 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>18920</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            12 years, 48 weeks, 1 day ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0sjgn:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>164630</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>