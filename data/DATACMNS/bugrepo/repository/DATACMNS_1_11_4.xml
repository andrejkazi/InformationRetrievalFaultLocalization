<?xml version = "1.0" encoding = "UTF-8" ?>
<bugrepository name="DATACMNS">
	<bug id="812" opendate="2016-01-29 20:53:59" fixdate="2016-03-07 10:34:55" resolution="Fixed">
		<buginformation>
			<summary>Confusing message generated by  PageImpl.toString()</summary>
			<description>The PageImpl.toString() uses getNumber() and getTotalPages(). The problem is:

getNumber() uses 0-based index
getTotalPages() is the total number of pages

So you end up with:






Page 0 of 2 containing com.foo.Bar instances




Page 1 of 2 containing com.foo.Bar instances





</description>
			<version>1.11.4 (Gosling SR4)</version>
			<fixedVersion>1.12 RC1 (Hopper), 1.10.3 (Fowler SR3), 1.11.5 (Gosling SR5)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.domain.PageImpl.java</file>
		</fixedFiles>
	</bug>
	<bug id="829" opendate="2016-03-15 14:06:25" fixdate="2016-03-15 14:52:10" resolution="Fixed">
		<buginformation>
			<summary>Projecting a Map with a null value causes an exception</summary>
			<description>ProjectingMethodInterceptor.getProjection(Object, Class&amp;lt;?&amp;gt;) assumes the first param to be non-null, but it may be null if there is a Map with a null value, e.g. a Collections.createSingletonMap("key", null).
That means that returning such map from a @Projection, e.g.:






public interface MyProjection {




    Map&amp;lt;String, Object&amp;gt; getData();




}






results in an exception.
A kind of a workaround is to remove nulls from a projected map, e.g.:






public interface MyProjection {




    @Value("#{T(...).mapWithoutNulls(target.getData())}")




    Map&amp;lt;String, Object&amp;gt; getData();




}









...









public static &amp;lt;K, V&amp;gt; Map&amp;lt;K, V&amp;gt; mapWithoutNulls(Map&amp;lt;K, V&amp;gt; map) {




    return map.entrySet().stream()




            .filter(entry -&amp;gt; entry.getValue() != null)




            .collect(Collectors.toMap(




                    Map.Entry::getKey,




                    Map.Entry::getValue));




}





</description>
			<version>1.11.4 (Gosling SR4)</version>
			<fixedVersion>1.12 RC1 (Hopper), 1.10.3 (Fowler SR3), 1.11.5 (Gosling SR5)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.projection.ProxyProjectionFactoryUnitTests.java</file>
			<file type="M">org.springframework.data.projection.ProjectingMethodInterceptor.java</file>
		</fixedFiles>
	</bug>
	<bug id="854" opendate="2016-05-06 20:07:28" fixdate="2016-05-24 17:08:02" resolution="Fixed">
		<buginformation>
			<summary>Custom implementation of repository fails when overriding methods containing generics</summary>
			<description>I am using the method for creating custom implementation of repositories, as described (among other places) here. This works great for just about all methods, including methods from the standard CrudRepository and PagingAndSortingRepository like Page&amp;lt;T&amp;gt; findAll(Pageable pageable). However, this does not work if the method defined in CrudRepository or PagingAndSortingRepository contains parameters with generics, like T findOne(ID id).
Why am I doing this you ask? Well, I am trying to find a work around while waiting for DATACMNS-293. This allows me to implement the methods manually, while keeping all the goodness of the restful exposure code as-is, which given QueryDSL is suprisingly simple and I am nearly questioning the need for the solution in DATACMNS-293...
The following patch fixes the issue for me, but I am not able to see if this has further unwanted ramifications:






iff --git a/src/main/java/org/springframework/data/repository/core/support/DefaultRepositoryInformation.java b/src/main/java/org/springframework/data/repository/core/support/DefaultRepositoryInformation.java




index 48bcdac..785c575 100644




--- a/src/main/java/org/springframework/data/repository/core/support/DefaultRepositoryInformation.java




+++ b/src/main/java/org/springframework/data/repository/core/support/DefaultRepositoryInformation.java




@@ -356,7 +356,7 @@ class DefaultRepositoryInformation implements RepositoryInformation {




                                        return false;




                                }




                        } else {




-                               if (!types[i].equals(parameterType)) {




+                               if (!types[i].isAssignableFrom(parameterType)) {




                                        return false;




                                }




                        }





</description>
			<version>1.11.4 (Gosling SR4)</version>
			<fixedVersion>1.11.5 (Gosling SR5), 1.12.2 (Hopper SR2), 1.13 M1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.core.support.DefaultRepositoryInformation.java</file>
			<file type="M">org.springframework.data.repository.core.support.DefaultRepositoryInformationUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">912</link>
		</links>
	</bug>
	<bug id="831" opendate="2016-03-23 19:22:03" fixdate="2016-05-31 17:05:26" resolution="Fixed">
		<buginformation>
			<summary>AbstractMappingContext.getPersistentEntity sometimes returns an empty entity when called by multiple threads</summary>
			<description>If you call the getPersistentEntity() method in the AbstractMappingContext class with the same type from multiple threads concurrently, you will sometimes get an empty entity back, i.e. an entity without any properties. This is caused by a race condition at the beginning of the addPersistentEntity() method. If one thread calls the method while another one is already executing inside the write lock in the method, the first thread will return an empty entity from the persistentEntities map even though the second thread is still populating it with properties. To fix this, the addPersistentEntity() method should acquire the read lock before accessing the persistentEntities map.</description>
			<version>1.11.4 (Gosling SR4)</version>
			<fixedVersion>1.11.5 (Gosling SR5), 1.12.2 (Hopper SR2), 1.13 M1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mapping.context.AbstractMappingContext.java</file>
		</fixedFiles>
	</bug>
	<bug id="863" opendate="2016-06-04 12:29:03" fixdate="2016-06-06 16:34:11" resolution="Fixed">
		<buginformation>
			<summary>Query method Parameter should return element type for wrapper ones (e.g. Optional)</summary>
			<description></description>
			<version>1.11.4 (Gosling SR4)</version>
			<fixedVersion>1.11.5 (Gosling SR5), 1.12.2 (Hopper SR2), 1.13 M1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.query.ParametersUnitTests.java</file>
			<file type="M">org.springframework.data.repository.query.Parameter.java</file>
		</fixedFiles>
	</bug>
	<bug id="882" opendate="2016-07-15 07:42:08" fixdate="2016-07-15 09:10:29" resolution="Duplicate">
		<buginformation>
			<summary>Allow to filter value inside list of object via query URL</summary>
			<description>Create a support for query inside list of object, see issue in this link.
I&amp;amp;apos;m trying to implement by myself, see code here but I also hit a roadblock with issue of querydsl itself (here issue).
If you think that the issue of querydsl is not important, I can improve code quality and then create a pull request to your repo.
I think my code quality is not as good as yours, please give me an advice.</description>
			<version>1.11.4 (Gosling SR4)</version>
			<fixedVersion></fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslBindings.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslPredicateBuilderUnitTests.java</file>
			<file type="M">org.springframework.data.querydsl.QueryDslUtils.java</file>
			<file type="M">org.springframework.data.querydsl.User.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslPredicateBuilder.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslBindingsUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">883</link>
		</links>
	</bug>
	<bug id="883" opendate="2016-07-15 08:26:03" fixdate="2016-07-25 18:13:29" resolution="Fixed">
		<buginformation>
			<summary>NullPointerException for Querydsl bindings referring to collection element attributes</summary>
			<description>Assume you have a domain model like this:






class User {




  List&amp;lt;Address&amp;gt; addresses;




}









class Address {




  String street;




}






Referring to the property addresses.street via Querydsl-backed web requests doesn&amp;amp;apos;t work as we&amp;amp;apos;re inspecting the properties in the Querydsl generated classes, and the ListPath generated for addresses needs a dedicated any() lookup to get back to the EntityPath for the element predicates.
Manually specifying a binding, doesn&amp;amp;apos;t help either as the translation into a PropertyPath fails, as we currently rely on the toString() representation of the PathMetadata, which in case of the usage of any() returns any(user.addresses).street.
We need to fix the to-dot-path translation in that step and should add the implicit call to any() for derived path expressions in case we encounter a Path that points to a collection.</description>
			<version>1.11.4 (Gosling SR4)</version>
			<fixedVersion>1.13 M1 (Ingalls), 1.12.3 (Hopper SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslBindings.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslPredicateBuilderUnitTests.java</file>
			<file type="M">org.springframework.data.querydsl.QueryDslUtils.java</file>
			<file type="M">org.springframework.data.querydsl.User.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslPredicateBuilder.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslBindingsUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">882</link>
		</links>
	</bug>
	<bug id="896" opendate="2016-08-18 20:48:18" fixdate="2016-08-19 17:58:10" resolution="Fixed">
		<buginformation>
			<summary>ClassTypeInformation computes incorrect TypeVariable mappings for recursive generics</summary>
			<description>When using a class with type variables in the class hierarchy, which contains variables referencing other classes also using common parts of the same class hierarchy, the type variables type mappings for the referenced classes are incorrectly mixed into the original classes type variables.
See the attached JUnit test which can demonstrate the problem.  It may require several runs for it appear, but it is consistently failing for us.
I believe this is due the essentially random ordering of the HashSet.entrySet().iterator() on line 130 and the putAll() on line 136:
https://github.com/spring-projects/spring-data-commons/blob/master/src/main/java/org/springframework/data/util/ClassTypeInformation.java#L130
https://github.com/spring-projects/spring-data-commons/blob/master/src/main/java/org/springframework/data/util/ClassTypeInformation.java#L136
Depending on the sequencing, you either get your own type variable value, or some other related classes.  Last one wins.
We&amp;amp;apos;ve tried modifying this class to removed the putAll (line 136), and it fixes this test, and does not appear to cause problems for 100s of other Spring Data Repository based tests we have.  It&amp;amp;apos;s not clear why the type variable mappings from other classes that are not direct superclasses or interfaces are included at all, it seems very wrong.

It took us 4 days to track down this as the ultimate source of a random startup failures of a Spring Data JPA Repository while parsing of dynamic query methods on a particular part of our domain model.  It was very hard to reproduce, but one developers box seemed to want to fail rather consistently, which gave the opportunity to narrow it down.  My hope, for now, is to work around it by mapping the query method to a custom implementation.</description>
			<version>1.11.4 (Gosling SR4)</version>
			<fixedVersion>1.11.5 (Gosling SR5), 1.12.3 (Hopper SR3), 1.13 RC1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.util.ClassTypeInformation.java</file>
			<file type="M">org.springframework.data.util.ClassTypeInformationUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="909" opendate="2016-09-08 08:55:13" fixdate="2016-09-09 20:02:51" resolution="Fixed">
		<buginformation>
			<summary>Exclude decoratedClass from JSON links, created from Projection and received with Spring @RestController</summary>
			<description>Experiment with spring-boot version: in 1.3.7.RELEASE (spring data 2.4.4) decoratedClass is absent, but in 1.4.0.RELEASE (spring data 2.5.2) it is present
I&amp;amp;apos;d like get clean JSON, when using Projection as DTO with RestController. However, in the best case we get JSON, most of which contain links to dekoratedClass.
{"name":"Dmitry","id":1,"decoratedClass":"ru.inkontext.domain.Person", "adress":{"id":1,"decoratedClass":"ru.inkontext.domain.Adress","city":"Surgut"}}
Decide by Oliver Gierke
Looks like this is caused by proxies created through Spring&amp;amp;apos;s ProxyFactory now also implementing a new DecoratingProxy, which exposes getDecoratedClass() and our TargetAware interface that&amp;amp;apos;s in place to mask the artificial proxy properties doesn&amp;amp;apos;t mask that newly introduced attribute. I can adapt our TargetAware accordingly.
A temporary workaround would be to redeclare the getDecoratedClass() method on your projection interface and annotate it with @JsonIgnore.
Tests below imaging matter of question.
RestController
Without Projection
mockMvc.perform(get("/rest/persons/1"))
.andExpect(jsonPath("id").value(1)
.andExpect(jsonPath("decoratedClass").doesNotExist());
Projection created by Repository
mockMvc.perform(get("/rest/persons/1/projected"))
.andExpect(jsonPath("id").value(1))
.andExpect(jsonPath("decoratedClass").value("java.util.HashMap"));
Projection created by Repository with Generic
mockMvc.perform(get("/rest/persons/1/projectedClass"))
.andExpect(jsonPath("id").value(1))
.andExpect(jsonPath("decoratedClass").value("java.util.HashMap"));
Projection created by Projection Factory
mockMvc.perform(get("/rest/persons/1/adressCity"))
.andExpect(jsonPath("id").value(1))
.andExpect(jsonPath("decoratedClass").value("ru.inkontext.domain.Person"));
Standard Sring Data REST API
without Projection
mockMvc.perform(get("/rest/api/persons/1"))
.andExpect(jsonPath("id").doesNotExist())
.andExpect(jsonPath("_links").exists());
with Projection
mockMvc.perform(get("/rest/api/persons/1?projection=adressCity"))
.andExpect(status().isOk())
.andExpect(jsonPath("id").value(1))
.andExpect(jsonPath("_links").exists());</description>
			<version>1.11.4 (Gosling SR4)</version>
			<fixedVersion>1.11.5 (Gosling SR5), 1.12.3 (Hopper SR3), 1.13 RC1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.projection.TargetAware.java</file>
		</fixedFiles>
	</bug>
</bugrepository>