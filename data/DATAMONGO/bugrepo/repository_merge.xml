<?xml version = "1.0" encoding = "UTF-8" ?>
<bugrepository name="DATAMONGO">
	<bug id="1" master="469" duplicate="481" opendate="2012-06-25 12:57:40" fixdate="2012-08-31 01:39:48" resolution="Fixed">
		<buginformation>
			<summary>Query creation from method names using AND criteria does not work anymore After upgrading to 1.0.2 IsTrue does not work properly in query method</summary>
			<description>When migrating from 1.0.1 to 1.0.2, one of my test failed.






@Test




public void testFindByPseudoAndPassword_wrongPseudo() {




    Member member = new Member("pseudo");




    member.setPassword("password");









    memberRepository.save(member);









    Member findMember = memberRepository.findByPseudoAndPassword("wrong-pseudo", "password");




    assertThat(findMember).isNull(); // FAILS HERE because the query retrieve the member with password equals "password" and miss the pseudo value




}






and the log is : 





 DEBUG [MongoTemplate] findOne using query: { "password" : "password" , "$and" : [ { "password" : "password"}]} 






I saw that in https://github.com/SpringSource/spring-data-mongodb/blob/1.0.x/spring-data-mongodb/src/test/java/org/springframework/data/mongodb/repository/query/MongoQueryCreatorUnitTests.java there is no assertion for the test #createsQueryCorrectly which test the Criteria AND case.
May be it is due to https://github.com/SpringSource/spring-data-mongodb/commit/c8bb46ffb3b2ffa5456417a199ffa0d3b977bf0b For such created query:
Account findByUsernameAndConfirmedIsTrue(String username);
I see following in logs:
Created query Query: { "confirmed" : true , "$and" : [ 
{ "confirmed" : true}
]}, Fields: null, Sort: null
And the query does not return proper value.
In previous release (1.0.1.RELEASE) the same code produces valid query:
Created query 
{ "username" : "me" , "confirmed" : true}</description>
			<version>1.0.2</version>
			<fixedVersion>1.0.3, 1.1 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.query.MongoQueryCreator.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.MongoQueryCreatorUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">481</link>
			<link type="Relate" description="relates to">547</link>
			<link type="Duplicate" description="duplicates">469</link>
		</links>
	</bug>
	<bug id="2" master="392" duplicate="459" opendate="2012-02-07 04:28:15" fixdate="2013-07-08 06:13:48" resolution="Fixed">
		<buginformation>
			<summary>Updating an object does not write type information for objects to be updated Using Update.set in nested arrays does not save the _class attribute</summary>
			<description>I&amp;amp;apos;m using quite complex domain model, that consist of instantiable domain classes as well as of abstract ones. I used 1.0.0.M5 version, and the type information (under _class key) was stored with object when it was necessary to be able to read it from database later. That worked perfectly for me till my upgrade to 1.0.0.RELEASE version that broke my application as it saves the objects without type information and later it is impossible to read it back to java model. 
What I found is that MappingMongoConverter.writeInternal(...) method that in turn calls addCustomTypeIfNecessary(...) (line 330) which puts type information into DBObject. During execution of convertToMongoType(...) (at line 851) removeTypeInfoRecursively(...) is called which clears type data saved earlier under _class key. I had to comment out this call in order to 
The first point is that there is a contradiction: why to save type information to DBObject if it is later removed by other method? The second point is that there should be a way to persist the type information inferred from runtime along the persisted object and not just the class definition.
 I have a service method like that:






	public Goal save(Goal goal) {




		Match match = this.mongoTemplate.findAndModify(




				query(where("goals").elemMatch(where("id").is(goal.getId()))),




				new Update().set("goals.$", goal), Match.class);




		return match.findGoalById(goal.getId());




	}






classes:






class Match {




     List&amp;lt;Goal&amp;gt; goals;




}




class Goal {




     Player player;




}




abstract class Player {}




class Forward extends Player {}




class Defender extends Player{}






When running the method above, the _class information for the Player object in the Goal class does not get saved in the database. This makes the saved document unloadable by Spring MongoDB.
Doing like that however will work:






Goal g = match.getGoal(&amp;lt;id&amp;gt;);




g.setPlayer(&amp;lt;a player&amp;gt;);






matchRepository.save(match);</description>
			<version>1.0.1</version>
			<fixedVersion>1.3 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">459</link>
			<link type="Relate" description="relates to">407</link>
			<link type="Relate" description="relates to">724</link>
			<link type="Duplicate" description="duplicates">392</link>
		</links>
	</bug>
	<bug id="3" master="633" duplicate="669" opendate="2013-03-25 09:10:22" fixdate="2013-05-03 11:05:43" resolution="Fixed">
		<buginformation>
			<summary>Upgrade to Querydsl 3.0.0 Incompatibility with Querydsl 3.1.1</summary>
			<description> 





java.lang.NoSuchMethodError: com.mysema.query.types.PathMetadata.getExpression()Lcom/mysema/query/types/Expression;




	at org.springframework.data.mongodb.repository.support.SpringDataMongodbSerializer.getKeyForPath(SpringDataMongodbSerializer.java:66)




	at com.mysema.query.mongodb.MongodbSerializer.visit(MongodbSerializer.java:223)




	at com.mysema.query.mongodb.MongodbSerializer.visit(MongodbSerializer.java:34)




	at com.mysema.query.types.PathImpl.accept(PathImpl.java:94)




	at com.mysema.query.mongodb.MongodbSerializer.asDBValue(MongodbSerializer.java:75)




	at com.mysema.query.mongodb.MongodbSerializer.asDBKey(MongodbSerializer.java:71)




	at com.mysema.query.mongodb.MongodbSerializer.visit(MongodbSerializer.java:93)




	at com.mysema.query.mongodb.MongodbSerializer.visit(MongodbSerializer.java:34)




	at com.mysema.query.types.expr.BooleanOperation.accept(BooleanOperation.java:61)




	at com.mysema.query.mongodb.MongodbSerializer.handle(MongodbSerializer.java:39)




	at com.mysema.query.mongodb.MongodbSerializer.visit(MongodbSerializer.java:102)




	at com.mysema.query.mongodb.MongodbSerializer.visit(MongodbSerializer.java:34)




	at com.mysema.query.types.OperationImpl.accept(OperationImpl.java:91)




	at com.mysema.query.mongodb.MongodbSerializer.handle(MongodbSerializer.java:39)




	at com.mysema.query.mongodb.MongodbQuery.createQuery(MongodbQuery.java:389)




	at com.mysema.query.mongodb.MongodbQuery.createCursor(MongodbQuery.java:286)




	at com.mysema.query.mongodb.MongodbQuery.createCursor(MongodbQuery.java:281)




	at com.mysema.query.mongodb.MongodbQuery.list(MongodbQuery.java:267)




	at org.springframework.data.mongodb.repository.support.QueryDslMongoRepository.findAll(QueryDslMongoRepository.java:93)




	at org.springframework.data.mongodb.repository.support.QueryDslMongoRepository.findAll(QueryDslMongoRepository.java:47)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:601)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.executeMethodOn(RepositoryFactorySupport.java:333)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.invoke(RepositoryFactorySupport.java:318)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)




	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:204)




	at com.sun.proxy.$Proxy27.findAll(Unknown Source)




	at ch.twinf.mongodb.repositories.PersonRepositoryTest.querydsl(PersonRepositoryTest.java:137)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:601)




	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)




	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)




	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)




	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)




	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)




	at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:74)




	at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:83)




	at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:72)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:231)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:88)




	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)




	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)




	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)




	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)




	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)




	at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)




	at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:71)




	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:174)




	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)




	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)





</description>
			<version>1.2.1</version>
			<fixedVersion>1.3 M1</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.support.SpringDataMongodbSerializer.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">669</link>
			<link type="Duplicate" description="duplicates">633</link>
		</links>
	</bug>
	<bug id="4" master="1120" duplicate="1126" opendate="2014-12-15 13:39:20" fixdate="2015-01-20 08:04:31" resolution="Fixed">
		<buginformation>
			<summary>Pageable queries timeout or return incorrect counts Repository keyword query findByInId with pageable not returning correctly</summary>
			<description>Counts for total elements and pages on some repositories return 0 and some throw a 500 when the socket times out.  This is ONLY occurring on calls that return a Page object and accept a Pageable input.  After debugging a bit, the inputs all seem to be populated from the controller fine.  The query definitions are
findByActiveIsTrue = wrong counts for totalElements and totalPages. both are 0
findByUserId = this collection is large at around 3 million records, but is indexed.
This is only happening in 1.6.1 and works correctly in 1.6.0 I&amp;amp;apos;ve been trying to use the In-keyword with identifiers and making the query pageable. The query returns results but getTotalElements() and getTotalPages() always returns 0. Also when you try to get any other page than 0, no results return. I&amp;amp;apos;ve tried using In with another member other than id and it works as expected. Below is a strip down example I used for testing;
I&amp;amp;apos;ve created 3 types and 10 items per those types, results in a total of 30 items.






@Document




public class Item {









    @Id




    private String id;




    private String type;




}












public interface ItemRepository extends MongoRepository&amp;lt;Item, String&amp;gt; {









    Page&amp;lt;Item&amp;gt; findByIdIn(Collection ids, Pageable pageable);




    Page&amp;lt;Item&amp;gt; findByTypeIn(Collection types, Pageable pageable);




}












@RunWith(SpringJUnit4ClassRunner.class)




@ContextConfiguration(classes = {MongoDbConfig.class})




@TransactionConfiguration(defaultRollback = false)




public class TestPageableIdIn {









    @Autowired




    private ItemRepository itemRepository;




    




    private List&amp;lt;String&amp;gt; allIds = new LinkedList&amp;lt;&amp;gt;();









    @Before




    public void setUp() {




        itemRepository.deleteAll();




        String[] types = {"SWORD", "SHIELD", "ARMOUR"};









        // 10 items per type




        for (String type : types) {




            for (int i = 0; i &amp;lt; 10; i++) {




                String id = UUID.randomUUID().toString();




                allIds.add(id);




                itemRepository.save(new Item(id, type));




            }




        }




    }









    @Test




    public void testPageableIdIn() {




        




        Pageable pageable = new PageRequest(0, 5);




        




        // expect 5 Items returned, total of 10 Items(SWORDS) in 2 Pages




        Page&amp;lt;Item&amp;gt; results = itemRepository.findByTypeIn(Arrays.asList("SWORD"), pageable);




        Assert.assertEquals(5, results.getContent().size());




        Assert.assertEquals(10, results.getTotalElements());




        Assert.assertEquals(2, results.getTotalPages());




        




        // expect 5 Items returned, total of 30 Items in 6 Pages




        results = itemRepository.findByIdIn(allIds, pageable);




        Assert.assertEquals(5, results.getContent().size());




        Assert.assertEquals(30, results.getTotalElements()); // this is returning 0




        Assert.assertEquals(6, results.getTotalPages());     // this is returning 0




    }




}





</description>
			<version>1.6.1 (Evans SR1)</version>
			<fixedVersion>1.6.2 (Evans SR2), 1.7 RC1 (Fowler)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.query.AbstractMongoQueryUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.AbstractMongoQuery.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoOperations.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
			<file type="M">org.springframework.data.mongodb.repository.Person.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1126</link>
			<link type="Relate" description="is related to">1080</link>
			<link type="Duplicate" description="duplicates">1120</link>
		</links>
	</bug>
	<bug id="5" master="934" duplicate="1190" opendate="2014-05-14 01:45:14" fixdate="2015-11-26 17:00:21" resolution="Fixed">
		<buginformation>
			<summary>Add support for the bulk operations introduced in MongoDB 2.6. Please consider adding BulkWriteOperations, in particular unorderedBulkInsert</summary>
			<description>Latest version of spring data mongodb have no support for the bulk operations introduced in MongoDB 2.6 and mongodb recommends using the new write protocols and new bulk api for bulk opertations. Please consider adding bulk write operations to mongoOperations.
E.g. initializeUnorderedBulkOperation  which allows bulk writes that do not abort on the first error, and are potentially faster (allowing reordering &amp;amp; parallelism). 
A naive start would be :
class MongoTemplate {
public BulkWriteResult  insert(List&amp;lt;Object&amp;gt; list, boolean isOrdered, String collectionName){
        DBCollection col=mongoOperations.getCollection(colName);
        BulkWriteOperation bulk=isOrdered?     
              col.initializeOrderdBulkOperation():
              col.initializeUnorderedBulkOperation();
        MongoConverter converter= mongoOperations.getConverter();
        for(String Object o:list)
{
            DBObject dbDoc=new BasicDBObject();
            maybeEmitEvent(new BeforeConvertEvent&amp;lt;T&amp;gt;(o));
            converter.write(element, dbDoc);
            maybeEmitEvent(new BeforeSaveEvent&amp;lt;T&amp;gt;(o, dbDoc));
            bulk.insert(dbDoc);                    	
        }
       ... // loop and emit "AfterSaveEvent"s
        return bulk.execute(writeConcern);
}
This is a naive start, i&amp;amp;apos;d appreciate other people&amp;amp;apos;s view on additional design considerations:
(1) Major issue - it&amp;amp;apos;s a problem to get the returned IDs and match them to the original objects!
(2) should it be generalized to other bulk operations
thanks,
Pelit</description>
			<version>1.4.2 (Codd SR2)</version>
			<fixedVersion>1.9 M1 (Hopper)</fixedVersion>
			<type>New Feature</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.BulkOperationException.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoExceptionTranslator.java</file>
			<file type="M">org.springframework.data.mongodb.core.DefaultBulkOperations.java</file>
			<file type="D">org.springframework.data.mongodb.util.Tuple.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoOperations.java</file>
			<file type="M">org.springframework.data.mongodb.core.DefaultBulkOperationsIntegrationTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.BulkOperations.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoActionOperation.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1190</link>
			<link type="Duplicate" description="duplicates">934</link>
			<link type="Relate" description="is related to">665</link>
		</links>
	</bug>
	<bug id="6" master="1025" duplicate="1027" opendate="2014-08-14 02:42:25" fixdate="2014-08-26 06:29:39" resolution="Fixed">
		<buginformation>
			<summary>Duplicate index creation on embedded documents  Collection inherits complex index from embedded class/object</summary>
			<description>Having the documents:






@CompoundIndexes({ @CompoundIndex(collection="timeRead", name = "eventIdAndChip", def = "{eventId : 1, chip : 1}"),




        @CompoundIndex(collection="timeRead", name = "eventIdAndPublish", def = "{ eventId : 1, publish : 1}"),




        @CompoundIndex(collection="timeRead", name = "chipAndTimeReadTickIndex", def = "{&amp;amp;apos;chip&amp;amp;apos; : -1, &amp;amp;apos;timeReadTick&amp;amp;apos; : 1}") })




@Document




public class TimeRead { }






and 






@Document




public class TimeReadChip {









    private Map&amp;lt;String, TimeRead&amp;gt; timeReads;




    private Map&amp;lt;String, TimeRead&amp;gt; pointNameToTimeRead;




}






The Mongo driver tries to create the same indexes twice: once because they are defined as compound on TimeRead (which is correct), and a second time when parsing the TimeReadChip document (incorrect). I&amp;amp;apos;m assuming it sees the Map&amp;lt;String, TimeRead&amp;gt; and tries to create indexes on timeRead collection (again). This bug was introduced after 1.3.5.RELEASE. Say I have two collections:
Books and Author
Author has a unique compound index and Book has a list of authors as property.
Now if I add different book with the same author to books, the insert is ignored because books inherits the index from authors.
On a subsequent context restart I&amp;amp;apos;m also getting a duplicate key exception:






com.mongodb.MongoException$DuplicateKey: { "serverUsed" : "" , "err" : "E11000 duplicate key error index: db.books.$name_appId_idx  dup key






</description>
			<version>1.5.2 (Dijkstra SR2)</version>
			<fixedVersion>1.5.4 (Dijkstra SR4), 1.6 GA (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolverUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.index.Indexed.java</file>
			<file type="M">org.springframework.data.mongodb.core.index.GeoSpatialIndexed.java</file>
			<file type="M">org.springframework.data.mongodb.core.index.CompoundIndex.java</file>
			<file type="M">org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.java</file>
			<file type="M">org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexCreatorUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1027</link>
			<link type="Duplicate" description="duplicates">1025</link>
		</links>
	</bug>
	<bug id="7" master="376" duplicate="359" opendate="2011-12-23 14:22:07" fixdate="2012-01-16 11:59:43" resolution="Fixed">
		<buginformation>
			<summary>Fix potential NPE in SpringDataMongodbSerializer Collection any() paths can&amp;apos;t be treated as property paths.</summary>
			<description>We currently run into a NPE in case no property with the to-string expression is found. This is inevitably the case if an any() expression is used in the predicate because of the way visit() is implemented in the superclass. I&amp;amp;apos;ve opened a ticket against Querydsl to prevent the invocation (as it doesn&amp;amp;apos;t seem necessary) but we should guard against the issue nevertheless. NPE in QueryDslMongoRepository after M4 - RC1 upgrade 
Example code, variable state and stacktraces nicely formatted in the reference forum post.
Timo Westkmper from QDSL has indicated this is a bug in Spring Data https://groups.google.com/forum/#!topic/querydsl/bZVxc4v0NPk</description>
			<version>1.0 GA</version>
			<fixedVersion>1.0.1, 1.1 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.support.SpringDataMongodbSerializerUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.support.QueryDslMongoRepository.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">359</link>
			<link type="Duplicate" description="duplicates">376</link>
		</links>
	</bug>
	<bug id="8" master="617" duplicate="646" opendate="2013-02-20 02:13:42" fixdate="2013-04-08 11:15:14" resolution="Fixed">
		<buginformation>
			<summary>NullPointerException in MongoTemplate.initializeVersionProperty() Can&amp;apos;t insert DBObjects through MongoTemplate</summary>
			<description>If mongoPersistentEntity is null, NullPointerException is thrown (line 671).
Write this (ligne 669) : 






if (mongoPersistentEntity != null &amp;amp;&amp;amp; mongoPersistentEntity.hasVersionProperty()) 






Instead of : 






if (mongoPersistentEntity == null || mongoPersistentEntity.hasVersionProperty())





 It appears that inserting DBObject instances directly through MongoTemplate is no longer possible in 1.2.0. Is this supposed to be the case?
When I try to insert a raw DBObject (to test conversion logic from old schema to new upon read), the following exception is thrown:






java.lang.NullPointerException




	at org.springframework.data.mongodb.core.MongoTemplate.initializeVersionProperty(MongoTemplate.java:671)




	at org.springframework.data.mongodb.core.MongoTemplate.doInsert(MongoTemplate.java:651)




	at org.springframework.data.mongodb.core.MongoTemplate.insert(MongoTemplate.java:613)




	at com.portalify.a.project.AnITCase.testThatRequiresInsertionOfRawObjects(AnITCase.java:123)






The direct problem is that initializeVersionProperty() doesn&amp;amp;apos;t do proper null checking before calling mongoPersistentEntity.getVersionProperty(). In fact, it specifically allows proceeding to the problematic branch when mongoPersistentEntity is null.</description>
			<version>1.2 GA</version>
			<fixedVersion>1.2.1, 1.3 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">646</link>
			<link type="Duplicate" description="duplicates">617</link>
		</links>
	</bug>
	<bug id="9" master="1416" duplicate="1436" opendate="2016-04-10 15:43:11" fixdate="2016-05-24 16:25:27" resolution="Fixed">
		<buginformation>
			<summary>Standard bootstrap issues warning in converter registration CustomConversions complains about built-in converters</summary>
			<description>I just upgraded to 1.9.1 from 1.8.4 and keep getting these warnings. 






org.springframework.data.mongodb.core.convert.CustomConversions:229 - Registering converter from class java.lang.Number to class java.lang.Number as writing converter although it doesn&amp;amp;apos;t convert to a Mongo supported type! You might wanna check you annotation setup at the converter implementation






 I have NO custom converters configured.  Not sure where this is coming from or how to fix. When registering any custom converters for MongoDB, the CustomConversions constructor adds a whole slew of hard-coded converters to the list. These include NumberToNumberConverterFactory, which apparently converts java.lang.Number-&amp;gt;java.lang.Number and causes warnings to be logged.</description>
			<version>1.9.1 (Hopper SR1)</version>
			<fixedVersion>1.9.2 (Hopper SR2), 1.10 M1 (Ingalls)</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.MongoConvertersUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MongoConverters.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1436</link>
			<link type="Duplicate" description="is duplicated by">1438</link>
			<link type="Duplicate" description="duplicates">1416</link>
		</links>
	</bug>
	<bug id="10" master="1078" duplicate="1088" opendate="2014-10-28 02:23:26" fixdate="2014-11-12 23:11:42" resolution="Fixed">
		<buginformation>
			<summary>@Query annotated repository query fails to map complex Id structure. @Query $in does not remove "_class" property on collection of embedded objects </summary>
			<description>StringBasedMongoQuery converts any complex object to the according mongo type including type restrictions via _class. Therefore annotated queries like:






@Query("{&amp;amp;apos;_id&amp;amp;apos;: {$in: ?0}}")




List&amp;lt;User&amp;gt; findByUserIds(Collection&amp;lt;MyUserId&amp;gt; userIds);






end up being converted to:






{_id:  {$in: [ {_class:"com.sampleuser.MyUserId", userId:"....", sampleId:"...."}, ...






So we need to check for the presence of typeKey when converting id properties. Following method on repository 






	@Query(value = "{ embedded : { $in : ?0} }")




	List&amp;lt;Foo&amp;gt; findByEmbeddedIn2(Collection&amp;lt;EmbeddedObject&amp;gt; c);






generates incorrect query. 






{ "embedded" : { "$in" : [ {  "_class" : "demo.EmbeddedObject" , "s" : "hello"}]}}






Query should be without _class property e.g.:






{ "embedded" : { "$in" : [ { "s" : "hello"}]}}






I attached test project demonstrating this bug.
This bug is related to https://jira.spring.io/browse/DATAMONGO-893</description>
			<version>1.6.1 (Evans SR1)</version>
			<fixedVersion>1.7 M1 (Fowler), 1.5.5 (Dijkstra SR5), 1.6.2 (Evans SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.MyId.java</file>
			<file type="M">org.springframework.data.mongodb.repository.ComplexIdRepositoryIntegrationTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.UserWithComplexId.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1088</link>
			<link type="Duplicate" description="duplicates">1078</link>
		</links>
	</bug>
	<bug id="11" master="1232" duplicate="1368" opendate="2015-06-03 10:27:23" fixdate="2016-11-02 18:25:24" resolution="Fixed">
		<buginformation>
			<summary>IgnoreCase should escape queries findByIgnoreCase Not Escaping Parenthesis</summary>
			<description>The IgnoreCase query generator is subject to a sort of "regex injection" attack, because the query generator simply slaps ^..$ around the string and passes it directly to MongoDB. This fails when the string contains any sort of special characters. In my case, I&amp;amp;apos;m trying to perform a case-insensitive find on an e-mail address with the + sign, a legal character, but the regex interprets this as 1..*.
The query generator needs to properly escape regex-special characters. This was tested on 1.7.0.RELEASE.
I have a method in the interface like:
Object findOneByIdAndNameIgnoreCase(String id, String name);
I call the function like this:
dao.findOneByIdAndNameIgnoreCase("uid", "Engineer (TX)");
This causes the following query to be generated (as seen in the debug log):
(MongoTemplate.java:2066) - findOne using query: { "id" : "uid" , "name" : { "$regex" : "^Engineer (TX)$" , "$options" : "i"}} in db.collection
Which fails to find the record having:
{
"id" : "uid",
"name" : "Engineer (TX)"
}

Because the regex sees the parenthesis as part of the regex (as a group matcher) when it should see them as part of the plaintext.  i.e. they are not being escaped.
</description>
			<version>1.7.2 (Fowler SR2)</version>
			<fixedVersion>1.6.3 (Evans SR3), 1.7.1 (Fowler SR1), 1.5.6 (Dijkstra SR6), 1.8 RC1 (Gosling)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.query.MongoQueryCreator.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.MongoQueryCreatorUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1368</link>
			<link type="Duplicate" description="duplicates">1232</link>
		</links>
	</bug>
	<bug id="12" master="642" duplicate="594" opendate="2012-12-24 11:37:31" fixdate="2013-04-02 03:40:27" resolution="Fixed">
		<buginformation>
			<summary>MongoChangeSetPersister does not use mapped collection name cross-store=&gt; Define document name using annotation</summary>
			<description> In a cross-store configuration, the RelatedDocument is stored in a MongoDB collection using the container&amp;amp;apos;s Entity&amp;amp;apos;s package name.
It would be nice if the collection name would be either the name of the class (document, not entity) or as specified using annotations(@Document(collection="")).
This "issue" is caused by the class
org.springframework.data.mongodb.crossstore.MongoChangeSetPersister
which gets the name of the collection from the method getCollectionNameForEntity which does:
return ClassUtils.getQualifiedName(entityClass);</description>
			<version>1.1.1</version>
			<fixedVersion>1.2.1, 1.3 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.crossstore.CrossStoreMongoTests.java</file>
			<file type="M">org.springframework.data.mongodb.crossstore.MongoChangeSetPersister.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">594</link>
			<link type="Duplicate" description="duplicates">642</link>
		</links>
	</bug>
	<bug id="13" master="1276" duplicate="1295" opendate="2015-08-19 02:31:58" fixdate="2015-11-02 09:21:59" resolution="Fixed">
		<buginformation>
			<summary>MongoTemplate.CloseableIterableCursorAdapter does not null check return values from PersistenceExceptionTranslator. The MongoTemplate.CloseableIterableCusorAdapter runs into an NPE when a MappingException was raised</summary>
			<description>Using the Stream support in a MongoRepository I suddenly started getting exceptions like these:






java.lang.NullPointerException: null




	at org.springframework.data.mongodb.core.MongoTemplate$CloseableIterableCusorAdapter.next(MongoTemplate.java:2389)




	at java.util.Iterator.forEachRemaining(Iterator.java:116)




	at java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801)




	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:512)




	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:502)




	at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708)




	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)




	at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499)




...






After a bit if investigation it turns out that due to some domain model changes I appear to be getting an org.springframework.data.mapping.model.MappingException in the data mapping and since MongoExceptionTranslator does not specifically know about it. So it just returns null.
That appears to be fine according to the PersistenceExceptionTranslator interface. But it appears that the Spring Data MongoDB code will often throw the result without any null checks. Provoking an NPE and hiding the actual reason for the exception. When a MappingException occurs, the MongoTemplate.CloseableIterableCusorAdapter will run into an NPE and swallow the source MappingException. That makes the stack trace unusable. CloseableIterableCursorAdapter is used for the new java.util.Stream support. The source of this issue here. The MongoExceptionTranslator.translateExceptionIfPossible(...)  returns null in case of mapping exceptions.
The stack trace (where the nice MappingException is swallowed):






Exception in thread "main" java.lang.IllegalStateException: Failed to execute CommandLineRunner




	at org.springframework.boot.SpringApplication.runCommandLineRunners(SpringApplication.java:676)




	at org.springframework.boot.SpringApplication.afterRefresh(SpringApplication.java:691)




	at org.springframework.boot.SpringApplication.run(SpringApplication.java:322)




	at org.springframework.boot.SpringApplication.run(SpringApplication.java:967)




	at org.springframework.boot.SpringApplication.run(SpringApplication.java:956)




	at com....ExtractorApplication.main(ExtractorApplication.java:25)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:483)




	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:140)




Caused by: java.lang.NullPointerException &amp;lt;---- That should be the Mapping Exception




	at org.springframework.data.mongodb.core.MongoTemplate$CloseableIterableCusorAdapter.next(MongoTemplate.java:2395)




	at java.util.Iterator.forEachRemaining(Iterator.java:116)




	at java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801)




	at java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:580)




	at com......(XXX.java:48)




	at com.....ExtractorApplication.run(ExtractorApplication.java:37)




	at org.springframework.boot.SpringApplication.runCommandLineRunners(SpringApplication.java:673)




	... 10 more





</description>
			<version>1.8 GA (Gosling)</version>
			<fixedVersion>1.8.1 (Gosling SR1), 1.9 M1 (Hopper), 1.7.3 (Fowler SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1295</link>
			<link type="Duplicate" description="is duplicated by">1307</link>
			<link type="Duplicate" description="duplicates">1276</link>
		</links>
	</bug>
	<bug id="14" master="369" duplicate="430" opendate="2012-01-02 07:47:13" fixdate="2012-04-10 07:38:52" resolution="Fixed">
		<buginformation>
			<summary>Wrong query created when one value is a DBObject Query criteria is not considered in the query</summary>
			<description>Regression in 1.0.0-RELEASE. Works as expected in 1.0.0-RC1
Query: { "type" : 
{ "$in" : [ "folder"]}
 , "deleted" : false }
When a query contains a DBObject as a value like "type" in the example QueryMapper.getMappedObject will return in line 103 ignoring all further keys of the query.
This results in the query { "type" : 
{ "$in" : [ "folder"]}
 } sent to MongoDB.
 When I perform a query that includes more than one criteria, only the first criteria is being considered, others are discarded.
An example is attached; When the query is performed by MongoDB driver it works fine, but with Spring, the problem occurs.</description>
			<version>1.0 GA</version>
			<fixedVersion>1.0.1, 1.1 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.QueryMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.query.QueryMapperUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">381</link>
			<link type="Duplicate" description="is duplicated by">430</link>
			<link type="Relate" description="relates to">363</link>
			<link type="Relate" description="relates to">364</link>
			<link type="Relate" description="relates to">393</link>
			<link type="Relate" description="relates to">417</link>
			<link type="Duplicate" description="duplicates">369</link>
		</links>
	</bug>
	<bug id="15" master="1416" duplicate="1438" opendate="2016-04-10 15:43:11" fixdate="2016-05-26 14:03:47" resolution="Fixed">
		<buginformation>
			<summary>Standard bootstrap issues warning in converter registration I get a warning in my logs since switched to Spring Data MongoDB Hopper-SR1 Release Train in Spring Boot 1.3.5</summary>
			<description>I just upgraded to 1.9.1 from 1.8.4 and keep getting these warnings. 






org.springframework.data.mongodb.core.convert.CustomConversions:229 - Registering converter from class java.lang.Number to class java.lang.Number as writing converter although it doesn&amp;amp;apos;t convert to a Mongo supported type! You might wanna check you annotation setup at the converter implementation






 I have NO custom converters configured.  Not sure where this is coming from or how to fix. When I start my Spring Boot 1.3.5 application with no custom conversions and with Spring Data MongoDB Release Train Hopper-SR1 I get following warning in my logs:






Registering converter from class java.lang.Number to class java.lang.Number as writing converter although it doesn&amp;amp;apos;t convert to a Mongo supported type! You might wanna check you annotation setup at the converter implementation.






With the in Spring Boot 1.3.5 integrated version the warning is not exists..
I have alle my Domain classes they are saved in MongoDB annotated with @Document (see DATAMONGO-1413)</description>
			<version>1.9.1 (Hopper SR1)</version>
			<fixedVersion>1.9.2 (Hopper SR2), 1.10 M1 (Ingalls)</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.MongoConvertersUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MongoConverters.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1436</link>
			<link type="Duplicate" description="is duplicated by">1438</link>
			<link type="Duplicate" description="duplicates">1416</link>
		</links>
	</bug>
	<bug id="16" master="380" duplicate="398" opendate="2012-01-16 10:47:58" fixdate="2013-02-04 08:17:04" resolution="Fixed">
		<buginformation>
			<summary>maps with mongo reserved characters for keys generate on save: java.lang.IllegalArgumentException: fields stored in the db can&amp;apos;t have . in them Fails to store org.osgi.service.event.Event</summary>
			<description>create an object like:






@Document




class MyDataObject {




  private Map&amp;lt;String, Long&amp;gt; impressionsByOSVersion;




}






add an entry to map like






myObject.osVersions.put("iPhone 4.3.2", 1L);






save this object using mongo operations i.e.
see exception:






java.lang.IllegalArgumentException: fields stored in the db can&amp;amp;apos;t have . in them. (Bad Key: &amp;amp;apos;iPhone 5.0.1&amp;amp;apos;)




        at com.mongodb.DBCollection.validateKey(DBCollection.java:1203)




        at com.mongodb.DBCollection._checkKeys(DBCollection.java:1171)




        at com.mongodb.DBCollection._checkKeys(DBCollection.java:1174)




        at com.mongodb.DBCollection._checkObject(DBCollection.java:1161)




        at com.mongodb.DBCollection.save(DBCollection.java:706)




        at com.mongodb.DBCollection.save(DBCollection.java:691)




        at org.springframework.data.mongodb.core.MongoTemplate$11.doInCollection(MongoTemplate.java:790)




        at org.springframework.data.mongodb.core.MongoTemplate.execute(MongoTemplate.java:368)




        at org.springframework.data.mongodb.core.MongoTemplate.saveDBObject(MongoTemplate.java:784)




        at org.springframework.data.mongodb.core.MongoTemplate.doSave(MongoTemplate.java:720)




        at org.springframework.data.mongodb.core.MongoTemplate.save(MongoTemplate.java:707)




        at org.springframework.data.mongodb.repository.support.SimpleMongoRepository.save(SimpleMongoRepository.java:72)




        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)




        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




        at java.lang.reflect.Method.invoke(Method.java:601)




        at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.executeMethodOn(RepositoryFactorySupport.java:322)




        at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.invoke(RepositoryFactorySupport.java:307)




        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)




        at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:202)




        at $Proxy3022.save(Unknown Source)






if I extend MappingMongoConverter and use it, the save works.






class KeyEscapingMongoConverter extends MappingMongoConverter {









    public KeyEscapingMongoConverter(MongoDbFactory mongoDbFactory,




        MappingContext&amp;lt;? extends MongoPersistentEntity&amp;lt;?&amp;gt;, MongoPersistentProperty&amp;gt; mappingContext) {




        super(mongoDbFactory, mappingContext);




    }









    @Override




    protected Map&amp;lt;Object, Object&amp;gt; readMap(TypeInformation&amp;lt;?&amp;gt; type, DBObject dbObject) {




        return unescapeKeys(super.readMap(type, dbObject));




    }









    @Override




    protected DBObject writeMapInternal(Map&amp;lt;Object, Object&amp;gt; map, DBObject dbo, TypeInformation&amp;lt;?&amp;gt; propertyType) {




        return super.writeMapInternal(escapeKeys(map), dbo, propertyType);




    }









    @SuppressWarnings("unchecked")




    private &amp;lt;K, V&amp;gt; Map&amp;lt;K, V&amp;gt; escapeKeys(Map&amp;lt;K, V&amp;gt; map) {




        Map&amp;lt;K, V&amp;gt; escaped = newHashMap();




        for (Object key : map.keySet()) {




            Object newKey = key;




            if (key instanceof String) {




                newKey = escapeMongoValue((String) key);




            }




            escaped.put((K) newKey, map.get(key));




        }




        return escaped;




    }









    @SuppressWarnings("unchecked")




    private &amp;lt;K, V&amp;gt; Map&amp;lt;K, V&amp;gt; unescapeKeys(Map&amp;lt;K, V&amp;gt; map) {




        Map&amp;lt;K, V&amp;gt; unescaped = newHashMap();




        for (Object key : map.keySet()) {




            Object newKey = key;




            if (key instanceof String) {




                newKey = unescapeMongoValue((String) key);




            }




            unescaped.put((K) newKey, map.get(key));




        }




        return unescaped;




    }









    private String escapeMongoValue(String raw) {




        return raw.replaceAll("\\.", "ZZ");




    }









    private String unescapeMongoValue(String raw) {




        return raw.replaceAll("ZZ", "\\.");




    }




}





 When I attempt to save an object from org.apache.felix&amp;amp;apos;s versions of org.osgi.service.event.Event, the stack trace below occurs. This appears to be due to the system attempting to save the topic field in Event as event.topics. If anyone could confirm this as a bug, or tell me what I am doing wrong that would be great.
I am using the following dependency versions






&amp;lt;dependency&amp;gt;




    &amp;lt;groupId&amp;gt;org.apache.felix&amp;lt;/groupId&amp;gt;




    &amp;lt;artifactId&amp;gt;org.osgi.core&amp;lt;/artifactId&amp;gt;




    &amp;lt;version&amp;gt;1.4.0&amp;lt;/version&amp;gt;




&amp;lt;/dependency&amp;gt;









&amp;lt;dependency&amp;gt;




    &amp;lt;groupId&amp;gt;org.springframework.data&amp;lt;/groupId&amp;gt;




    &amp;lt;artifactId&amp;gt;spring-data-mongodb&amp;lt;/artifactId&amp;gt;




    &amp;lt;version&amp;gt;1.0.0.RELEASE&amp;lt;/version&amp;gt;




&amp;lt;/dependency&amp;gt;









&amp;lt;dependency&amp;gt;




    &amp;lt;groupId&amp;gt;org.apache.felix&amp;lt;/groupId&amp;gt;




    &amp;lt;artifactId&amp;gt;org.osgi.compendium&amp;lt;/artifactId&amp;gt;




    &amp;lt;version&amp;gt;1.4.0&amp;lt;/version&amp;gt;




&amp;lt;/dependency&amp;gt;












org.osgi.framework.BundleException: Exception in myproject.bundle.dbtest.Activator.start() of bundle myproject.bundle.dbtest.policy-db-test.




	at org.eclipse.osgi.framework.internal.core.BundleContextImpl.startActivator(BundleContextImpl.java:806)




	at org.eclipse.osgi.framework.internal.core.BundleContextImpl.start(BundleContextImpl.java:755)




	at org.eclipse.osgi.framework.internal.core.BundleHost.startWorker(BundleHost.java:370)




	at org.eclipse.osgi.framework.internal.core.AbstractBundle.start(AbstractBundle.java:284)




	at org.eclipse.osgi.framework.internal.core.AbstractBundle.start(AbstractBundle.java:276)




	at org.eclipse.osgi.framework.internal.core.FrameworkCommandProvider._start(FrameworkCommandProvider.java:252)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:616)




	at org.eclipse.osgi.framework.internal.core.FrameworkCommandInterpreter.execute(FrameworkCommandInterpreter.java:155)




	at org.eclipse.osgi.framework.internal.core.FrameworkConsole.docommand(FrameworkConsole.java:156)




	at org.eclipse.osgi.framework.internal.core.FrameworkConsole.runConsole(FrameworkConsole.java:141)




	at org.eclipse.osgi.framework.internal.core.FrameworkConsole.run(FrameworkConsole.java:105)




	at java.lang.Thread.run(Thread.java:679)




Caused by: java.lang.IllegalArgumentException: fields stored in the db can&amp;amp;apos;t have . in them. (Bad Key: &amp;amp;apos;event.topics&amp;amp;apos;)




	at com.mongodb.DBCollection.validateKey(DBCollection.java:1213)




	at com.mongodb.DBCollection._checkKeys(DBCollection.java:1181)




	at com.mongodb.DBCollection._checkKeys(DBCollection.java:1184)




	at com.mongodb.DBCollection._checkObject(DBCollection.java:1171)




	at com.mongodb.DBCollection.save(DBCollection.java:718)




	at com.mongodb.DBCollection.save(DBCollection.java:703)




	at org.springframework.data.mongodb.core.MongoTemplate$11.doInCollection(MongoTemplate.java:790)




	at org.springframework.data.mongodb.core.MongoTemplate.execute(MongoTemplate.java:368)




	at org.springframework.data.mongodb.core.MongoTemplate.saveDBObject(MongoTemplate.java:784)




	at org.springframework.data.mongodb.core.MongoTemplate.doSave(MongoTemplate.java:720)




	at org.springframework.data.mongodb.core.MongoTemplate.save(MongoTemplate.java:707)




	at org.springframework.data.mongodb.core.MongoTemplate.save(MongoTemplate.java:703)




	at myproject.bundle.db.PolicyDb.updatePolicy(PolicyDb.java:32)




	at myproject.bundle.dbtest.Activator.start(Activator.java:21)




	at org.eclipse.osgi.framework.internal.core.BundleContextImpl$1.run(BundleContextImpl.java:783)




	at java.security.AccessController.doPrivileged(Native Method)




	at org.eclipse.osgi.framework.internal.core.BundleContextImpl.startActivator(BundleContextImpl.java:774)




	... 14 more




Nested Exception:




java.lang.IllegalArgumentException: fields stored in the db can&amp;amp;apos;t have . in them. (Bad Key: &amp;amp;apos;event.topics&amp;amp;apos;)




	at com.mongodb.DBCollection.validateKey(DBCollection.java:1213)




	at com.mongodb.DBCollection._checkKeys(DBCollection.java:1181)




	at com.mongodb.DBCollection._checkKeys(DBCollection.java:1184)




	at com.mongodb.DBCollection._checkObject(DBCollection.java:1171)




	at com.mongodb.DBCollection.save(DBCollection.java:718)




	at com.mongodb.DBCollection.save(DBCollection.java:703)




	at org.springframework.data.mongodb.core.MongoTemplate$11.doInCollection(MongoTemplate.java:790)




	at org.springframework.data.mongodb.core.MongoTemplate.execute(MongoTemplate.java:368)




	at org.springframework.data.mongodb.core.MongoTemplate.saveDBObject(MongoTemplate.java:784)




	at org.springframework.data.mongodb.core.MongoTemplate.doSave(MongoTemplate.java:720)




	at org.springframework.data.mongodb.core.MongoTemplate.save(MongoTemplate.java:707)




	at org.springframework.data.mongodb.core.MongoTemplate.save(MongoTemplate.java:703)




	at myproject.bundle.db.PolicyDb.updatePolicy(PolicyDb.java:32)




	at myproject.bundle.dbtest.Activator.start(Activator.java:21)




	at org.eclipse.osgi.framework.internal.core.BundleContextImpl$1.run(BundleContextImpl.java:783)




	at java.security.AccessController.doPrivileged(Native Method)




	at org.eclipse.osgi.framework.internal.core.BundleContextImpl.startActivator(BundleContextImpl.java:774)




	at org.eclipse.osgi.framework.internal.core.BundleContextImpl.start(BundleContextImpl.java:755)




	at org.eclipse.osgi.framework.internal.core.BundleHost.startWorker(BundleHost.java:370)




	at org.eclipse.osgi.framework.internal.core.AbstractBundle.start(AbstractBundle.java:284)




	at org.eclipse.osgi.framework.internal.core.AbstractBundle.start(AbstractBundle.java:276)




	at org.eclipse.osgi.framework.internal.core.FrameworkCommandProvider._start(FrameworkCommandProvider.java:252)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:616)




	at org.eclipse.osgi.framework.internal.core.FrameworkCommandInterpreter.execute(FrameworkCommandInterpreter.java:155)




	at org.eclipse.osgi.framework.internal.core.FrameworkConsole.docommand(FrameworkConsole.java:156)




	at org.eclipse.osgi.framework.internal.core.FrameworkConsole.runConsole(FrameworkConsole.java:141)




	at org.eclipse.osgi.framework.internal.core.FrameworkConsole.run(FrameworkConsole.java:105)




	at java.lang.Thread.run(Thread.java:679)




Nested Exception:




java.lang.IllegalArgumentException: fields stored in the db can&amp;amp;apos;t have . in them. (Bad Key: &amp;amp;apos;event.topics&amp;amp;apos;)




	at com.mongodb.DBCollection.validateKey(DBCollection.java:1213)




	at com.mongodb.DBCollection._checkKeys(DBCollection.java:1181)




	at com.mongodb.DBCollection._checkKeys(DBCollection.java:1184)




	at com.mongodb.DBCollection._checkObject(DBCollection.java:1171)




	at com.mongodb.DBCollection.save(DBCollection.java:718)




	at com.mongodb.DBCollection.save(DBCollection.java:703)




	at org.springframework.data.mongodb.core.MongoTemplate$11.doInCollection(MongoTemplate.java:790)




	at org.springframework.data.mongodb.core.MongoTemplate.execute(MongoTemplate.java:368)




	at org.springframework.data.mongodb.core.MongoTemplate.saveDBObject(MongoTemplate.java:784)




	at org.springframework.data.mongodb.core.MongoTemplate.doSave(MongoTemplate.java:720)




	at org.springframework.data.mongodb.core.MongoTemplate.save(MongoTemplate.java:707)




	at org.springframework.data.mongodb.core.MongoTemplate.save(MongoTemplate.java:703)




	at myproject.bundle.db.PolicyDb.updatePolicy(PolicyDb.java:32)




	at myproject.bundle.dbtest.Activator.start(Activator.java:21)




	at org.eclipse.osgi.framework.internal.core.BundleContextImpl$1.run(BundleContextImpl.java:783)




	at java.security.AccessController.doPrivileged(Native Method)




	at org.eclipse.osgi.framework.internal.core.BundleContextImpl.startActivator(BundleContextImpl.java:774)




	at org.eclipse.osgi.framework.internal.core.BundleContextImpl.start(BundleContextImpl.java:755)




	at org.eclipse.osgi.framework.internal.core.BundleHost.startWorker(BundleHost.java:370)




	at org.eclipse.osgi.framework.internal.core.AbstractBundle.start(AbstractBundle.java:284)




	at org.eclipse.osgi.framework.internal.core.AbstractBundle.start(AbstractBundle.java:276)




	at org.eclipse.osgi.framework.internal.core.FrameworkCommandProvider._start(FrameworkCommandProvider.java:252)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:616)




	at org.eclipse.osgi.framework.internal.core.FrameworkCommandInterpreter.execute(FrameworkCommandInterpreter.java:155)




	at org.eclipse.osgi.framework.internal.core.FrameworkConsole.docommand(FrameworkConsole.java:156)




	at org.eclipse.osgi.framework.internal.core.FrameworkConsole.runConsole(FrameworkConsole.java:141)




	at org.eclipse.osgi.framework.internal.core.FrameworkConsole.run(FrameworkConsole.java:105)




	at java.lang.Thread.run(Thread.java:679)





</description>
			<version>1.0 GA</version>
			<fixedVersion>1.0.1, 1.1 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverterUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">398</link>
			<link type="Relate" description="relates to">615</link>
			<link type="Duplicate" description="duplicates">380</link>
		</links>
	</bug>
	<bug id="17" master="369" duplicate="381" opendate="2012-01-02 07:47:13" fixdate="2012-01-22 22:27:19" resolution="Fixed">
		<buginformation>
			<summary>Wrong query created when one value is a DBObject Querying criteria for "$in" on enum field gets lost in QueryMapper</summary>
			<description>Regression in 1.0.0-RELEASE. Works as expected in 1.0.0-RC1
Query: { "type" : 
{ "$in" : [ "folder"]}
 , "deleted" : false }
When a query contains a DBObject as a value like "type" in the example QueryMapper.getMappedObject will return in line 103 ignoring all further keys of the query.
This results in the query { "type" : 
{ "$in" : [ "folder"]}
 } sent to MongoDB.
 As I was updating my project from M5 to GA, some of my tests started failing. It seemed that "$in" stopped working because I was getting an unfiltered result set back. I was able to trace the problem to QueryMapper.
Before it goes in, the DBOBject for query.getCriteriaObject()&amp;amp;apos;s toString() shows:






{




"cardId" : "12345" , 




"interactionTime" : { "$lte" : { "$date" : "2012-01-18T00:44:06.469Z"}} , 




"isDeleted" : false , 




"actionCode" : { "$in" : [ "AVATAR_STAND"]} , 




"sourcePersonId" : { "$in" : [ "4f1615cb036416a89c12a60f"]}




}






after query mapper, when it gets passed into new FindCallback(...), the query DBObject is reduced to only the following:






{




"cardId" : "12345" , 




"interactionTime" : { "$lte" : { "$date" : "2012-01-18T00:44:06.469Z"}}




}






So I&amp;amp;apos;m not sure exactly what I&amp;amp;apos;m doing wrong / missing, but something between M5 and GA must&amp;amp;apos;ve changed. Any pointers?
Here&amp;amp;apos;s part of my class, in case it&amp;amp;apos;s any help:






@Document




public class CardInteraction {




  @Id private String interactionId;




  private String cardId;




  private String sourcePersonId;




  private ActionCodeEnum actionCode; // a java enum class




  private Date interactionTime;




  private boolean isDeleted;









  ...




}





</description>
			<version>1.0 GA</version>
			<fixedVersion>1.0.1, 1.1 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.QueryMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.query.QueryMapperUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">381</link>
			<link type="Duplicate" description="is duplicated by">430</link>
			<link type="Relate" description="relates to">363</link>
			<link type="Relate" description="relates to">364</link>
			<link type="Relate" description="relates to">393</link>
			<link type="Relate" description="relates to">417</link>
			<link type="Duplicate" description="duplicates">369</link>
		</links>
	</bug>
	<bug id="18" master="1276" duplicate="1307" opendate="2015-08-19 02:31:58" fixdate="2015-10-21 13:12:38" resolution="Fixed">
		<buginformation>
			<summary>MongoTemplate.CloseableIterableCursorAdapter does not null check return values from PersistenceExceptionTranslator. Stop converting user-defined runtime exceptions to NPEs</summary>
			<description>Using the Stream support in a MongoRepository I suddenly started getting exceptions like these:






java.lang.NullPointerException: null




	at org.springframework.data.mongodb.core.MongoTemplate$CloseableIterableCusorAdapter.next(MongoTemplate.java:2389)




	at java.util.Iterator.forEachRemaining(Iterator.java:116)




	at java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801)




	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:512)




	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:502)




	at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708)




	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)




	at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499)




...






After a bit if investigation it turns out that due to some domain model changes I appear to be getting an org.springframework.data.mapping.model.MappingException in the data mapping and since MongoExceptionTranslator does not specifically know about it. So it just returns null.
That appears to be fine according to the PersistenceExceptionTranslator interface. But it appears that the Spring Data MongoDB code will often throw the result without any null checks. Provoking an NPE and hiding the actual reason for the exception. MongoTemplate has code like this in many places:
} catch (RuntimeException ex) {
	throw exceptionTranslator.translateExceptionIfPossible(ex);
MongoExceptionTranslator, however, often does NOT return an exception. If it encounters an unknown exception it does this:
// If we get here, we have an exception that resulted from user code,
// rather than the persistence provider, so we return null to indicate
// that translation should not occur.
return null;
MongoTemplate then "eats" the original exception and throws a null-pointer exception instead.
MongoTemplate should throw the original exception if it gets null back from the exception translator.</description>
			<version>1.7.2 (Fowler SR2)</version>
			<fixedVersion>1.8.1 (Gosling SR1), 1.9 M1 (Hopper), 1.7.3 (Fowler SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1295</link>
			<link type="Duplicate" description="is duplicated by">1307</link>
			<link type="Duplicate" description="duplicates">1276</link>
		</links>
	</bug>
	<bug id="19" master="354" duplicate="410" opendate="2011-12-20 00:14:49" fixdate="2014-02-17 02:55:12" resolution="Fixed">
		<buginformation>
			<summary>MongoTemplate does not support multiple $pushAll in one update Update with pushAll doesnt recognize defined Converter</summary>
			<description>Update.push uses "addMultiFieldOperation". For some reason Update.pushAll does not. Second pushAll over-writes the first one. I am not being lazy, but i think this quote from the code that i attach can describe better :






List&amp;lt;MyNested&amp;gt; someValues = Arrays.asList(new MyNested("my"), new MyNested("name"), new MyNested("is"));




MyNested[] array = new MyNested[someValues.size()];




this.ops.updateFirst(




	Query.query(Criteria.where("id").is("testId")),




	new Update().pushAll("nestedList", someValues.toArray(array)), // fails with exception




// new Update().set("nestedList", someValues.toArray()), // this works fine !




// new Update().set("myNested", new MyNested("my")), // this works fine !




	COLLECTION_NAME);






Using pushAll() will results in exception, and also i notice that the converter&amp;amp;apos;s debugging message is not displayed. And the error message seems to say that it can&amp;amp;apos;t serialize my custom class where it should be the dbObject that should be serialized.
Here&amp;amp;apos;s the exception trace :






Exception in thread "main" java.lang.RuntimeException: json can&amp;amp;apos;t serialize type : class kam.albert.domain.test.post.TestConverterThatFails$MyNested




	at com.mongodb.util.JSON.serialize(JSON.java:261)




	at com.mongodb.util.JSON.serialize(JSON.java:210)




	at com.mongodb.util.JSON.serialize(JSON.java:141)




	at com.mongodb.util.JSON.serialize(JSON.java:141)




	at com.mongodb.util.JSON.serialize(JSON.java:58)




	at com.mongodb.BasicDBObject.toString(BasicDBObject.java:84)




	at java.lang.String.valueOf(Unknown Source)




	at java.lang.StringBuilder.append(Unknown Source)




	at org.springframework.data.mongodb.core.MongoTemplate$12.doInCollection(MongoTemplate.java:840)




	at org.springframework.data.mongodb.core.MongoTemplate$12.doInCollection(MongoTemplate.java:826)




	at org.springframework.data.mongodb.core.MongoTemplate.execute(MongoTemplate.java:368)




	at org.springframework.data.mongodb.core.MongoTemplate.doUpdate(MongoTemplate.java:826)




	at org.springframework.data.mongodb.core.MongoTemplate.updateFirst(MongoTemplate.java:812)




	at kam.albert.domain.test.post.TestConverterThatFails.test(TestConverterThatFails.java:50)




	at kam.albert.domain.test.post.TestConverterThatFails.main(TestConverterThatFails.java:30)





</description>
			<version>1.0.1</version>
			<fixedVersion>1.4 GA (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.query.UpdateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.query.Update.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">410</link>
			<link type="Relate" description="is related to">812</link>
			<link type="Duplicate" description="duplicates">354</link>
		</links>
	</bug>
</bugrepository>