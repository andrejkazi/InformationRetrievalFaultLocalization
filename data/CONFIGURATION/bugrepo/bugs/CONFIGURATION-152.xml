<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sat Dec 03 15:31:40 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/CONFIGURATION-152/CONFIGURATION-152.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[CONFIGURATION-152] [configuration][PATCH]HierarchicalConfiguration and XMLReader</title>
                <link>https://issues.apache.org/jira/browse/CONFIGURATION-152</link>
                <project id="12310467" key="CONFIGURATION">Commons Configuration</project>
                    <description>&lt;p&gt;Index: conf/testHierarchicalDOM4JConfiguration.xml&lt;br/&gt;
===================================================================&lt;br/&gt;
RCS file: conf/testHierarchicalDOM4JConfiguration.xml&lt;br/&gt;
diff -N conf/testHierarchicalDOM4JConfiguration.xml&lt;br/&gt;
&amp;#8212; /dev/null	1 Jan 1970 00:00:00 -0000&lt;br/&gt;
+++ conf/testHierarchicalDOM4JConfiguration.xml	30 Oct 2003 17:27:04 -0000&lt;br/&gt;
@@ -0,0 +1,56 @@&lt;br/&gt;
+&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot; ?&amp;gt;&lt;br/&gt;
+&lt;br/&gt;
+&amp;lt;database&amp;gt;&lt;br/&gt;
+  &amp;lt;tables&amp;gt;&lt;br/&gt;
+    &amp;lt;table tableType=&quot;system&quot;&amp;gt;&lt;br/&gt;
+      &amp;lt;name&amp;gt;users&amp;lt;/name&amp;gt;&lt;br/&gt;
+      &amp;lt;fields&amp;gt;&lt;br/&gt;
+        &amp;lt;field&amp;gt;&lt;br/&gt;
+	  &amp;lt;name&amp;gt;uid&amp;lt;/name&amp;gt;&lt;br/&gt;
+	  &amp;lt;type&amp;gt;long&amp;lt;/type&amp;gt;&lt;br/&gt;
+	&amp;lt;/field&amp;gt;&lt;br/&gt;
+        &amp;lt;field&amp;gt;&lt;br/&gt;
+	  &amp;lt;name&amp;gt;uname&amp;lt;/name&amp;gt;&lt;br/&gt;
+	  &amp;lt;type&amp;gt;java.lang.String&amp;lt;/type&amp;gt;&lt;br/&gt;
+	&amp;lt;/field&amp;gt;&lt;br/&gt;
+        &amp;lt;field&amp;gt;&lt;br/&gt;
+	  &amp;lt;name&amp;gt;firstName&amp;lt;/name&amp;gt;&lt;br/&gt;
+	  &amp;lt;type&amp;gt;java.lang.String&amp;lt;/type&amp;gt;&lt;br/&gt;
+	&amp;lt;/field&amp;gt;&lt;br/&gt;
+        &amp;lt;field&amp;gt;&lt;br/&gt;
+	  &amp;lt;name&amp;gt;lastName&amp;lt;/name&amp;gt;&lt;br/&gt;
+	  &amp;lt;type&amp;gt;java.lang.String&amp;lt;/type&amp;gt;&lt;br/&gt;
+	&amp;lt;/field&amp;gt;&lt;br/&gt;
+        &amp;lt;field&amp;gt;&lt;br/&gt;
+	  &amp;lt;name&amp;gt;email&amp;lt;/name&amp;gt;&lt;br/&gt;
+	  &amp;lt;type&amp;gt;java.lang.String&amp;lt;/type&amp;gt;&lt;br/&gt;
+	&amp;lt;/field&amp;gt;&lt;br/&gt;
+      &amp;lt;/fields&amp;gt;&lt;br/&gt;
+    &amp;lt;/table&amp;gt;&lt;br/&gt;
+    &amp;lt;table tableType=&quot;application&quot;&amp;gt;&lt;br/&gt;
+      &amp;lt;name&amp;gt;documents&amp;lt;/name&amp;gt;&lt;br/&gt;
+      &amp;lt;fields&amp;gt;&lt;br/&gt;
+        &amp;lt;field&amp;gt;&lt;br/&gt;
+	  &amp;lt;name&amp;gt;docid&amp;lt;/name&amp;gt;&lt;br/&gt;
+	  &amp;lt;type&amp;gt;long&amp;lt;/type&amp;gt;&lt;br/&gt;
+	&amp;lt;/field&amp;gt;&lt;br/&gt;
+        &amp;lt;field&amp;gt;&lt;br/&gt;
+	  &amp;lt;name&amp;gt;name&amp;lt;/name&amp;gt;&lt;br/&gt;
+	  &amp;lt;type&amp;gt;java.lang.String&amp;lt;/type&amp;gt;&lt;br/&gt;
+	&amp;lt;/field&amp;gt;&lt;br/&gt;
+        &amp;lt;field&amp;gt;&lt;br/&gt;
+	  &amp;lt;name&amp;gt;creationDate&amp;lt;/name&amp;gt;&lt;br/&gt;
+	  &amp;lt;type&amp;gt;java.util.Date&amp;lt;/type&amp;gt;&lt;br/&gt;
+	&amp;lt;/field&amp;gt;&lt;br/&gt;
+        &amp;lt;field&amp;gt;&lt;br/&gt;
+	  &amp;lt;name&amp;gt;authorID&amp;lt;/name&amp;gt;&lt;br/&gt;
+	  &amp;lt;type&amp;gt;long&amp;lt;/type&amp;gt;&lt;br/&gt;
+	&amp;lt;/field&amp;gt;&lt;br/&gt;
+        &amp;lt;field&amp;gt;&lt;br/&gt;
+	  &amp;lt;name&amp;gt;version&amp;lt;/name&amp;gt;&lt;br/&gt;
+	  &amp;lt;type&amp;gt;int&amp;lt;/type&amp;gt;&lt;br/&gt;
+	&amp;lt;/field&amp;gt;&lt;br/&gt;
+      &amp;lt;/fields&amp;gt;&lt;br/&gt;
+    &amp;lt;/table&amp;gt;&lt;br/&gt;
+  &amp;lt;/tables&amp;gt;&lt;br/&gt;
+&amp;lt;/database&amp;gt;&lt;br/&gt;
Index: src/java/org/apache/commons/configuration/BaseConfigurationXMLReader.java&lt;br/&gt;
===================================================================&lt;br/&gt;
RCS file: src/java/org/apache/commons/configuration/BaseConfigurationXMLReader.java&lt;br/&gt;
diff -N src/java/org/apache/commons/configuration/BaseConfigurationXMLReader.java&lt;br/&gt;
&amp;#8212; /dev/null	1 Jan 1970 00:00:00 -0000&lt;br/&gt;
+++ src/java/org/apache/commons/configuration/BaseConfigurationXMLReader.java	30&lt;br/&gt;
Oct 2003 17:27:05 -0000&lt;br/&gt;
@@ -0,0 +1,168 @@&lt;br/&gt;
+package org.apache.commons.configuration;&lt;br/&gt;
+&lt;br/&gt;
+/* ====================================================================&lt;br/&gt;
+ * The Apache Software License, Version 1.1&lt;br/&gt;
+ *&lt;br/&gt;
+ * Copyright (c) 1999-2003 The Apache Software Foundation.  All rights&lt;br/&gt;
+ * reserved.&lt;br/&gt;
+ *&lt;br/&gt;
+ * Redistribution and use in source and binary forms, with or without&lt;br/&gt;
+ * modification, are permitted provided that the following conditions&lt;br/&gt;
+ * are met:&lt;br/&gt;
+ *&lt;br/&gt;
+ * 1. Redistributions of source code must retain the above copyright&lt;br/&gt;
+ *    notice, this list of conditions and the following disclaimer.&lt;br/&gt;
+ *&lt;br/&gt;
+ * 2. Redistributions in binary form must reproduce the above copyright&lt;br/&gt;
+ *    notice, this list of conditions and the following disclaimer in&lt;br/&gt;
+ *    the documentation and/or other materials provided with the&lt;br/&gt;
+ *    distribution.&lt;br/&gt;
+ *&lt;br/&gt;
+ * 3. The end-user documentation included with the redistribution, if&lt;br/&gt;
+ *    any, must include the following acknowledgement:&lt;br/&gt;
+ *       &quot;This product includes software developed by the&lt;br/&gt;
+ *        Apache Software Foundation (&lt;a href=&quot;http://www.apache.org/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.apache.org/&lt;/a&gt;).&quot;&lt;br/&gt;
+ *    Alternately, this acknowledgement may appear in the software itself,&lt;br/&gt;
+ *    if and wherever such third-party acknowledgements normally appear.&lt;br/&gt;
+ *&lt;br/&gt;
+ * 4. The names &quot;The Jakarta Project&quot;, &quot;Commons&quot;, and &quot;Apache Software&lt;br/&gt;
+ *    Foundation&quot; must not be used to endorse or promote products derived&lt;br/&gt;
+ *    from this software without prior written permission. For written&lt;br/&gt;
+ *    permission, please contact apache@apache.org.&lt;br/&gt;
+ *&lt;br/&gt;
+ * 5. Products derived from this software may not be called &quot;Apache&quot;&lt;br/&gt;
+ *    nor may &quot;Apache&quot; appear in their names without prior written&lt;br/&gt;
+ *    permission of the Apache Software Foundation.&lt;br/&gt;
+ *&lt;br/&gt;
+ * THIS SOFTWARE IS PROVIDED ``AS IS&apos;&apos; AND ANY EXPRESSED OR IMPLIED&lt;br/&gt;
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES&lt;br/&gt;
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE&lt;br/&gt;
+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR&lt;br/&gt;
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,&lt;br/&gt;
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT&lt;br/&gt;
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF&lt;br/&gt;
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND&lt;br/&gt;
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,&lt;br/&gt;
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT&lt;br/&gt;
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF&lt;br/&gt;
+ * SUCH DAMAGE.&lt;br/&gt;
+ * ====================================================================&lt;br/&gt;
+ *&lt;br/&gt;
+ * This software consists of voluntary contributions made by many&lt;br/&gt;
+ * individuals on behalf of the Apache Software Foundation.  For more&lt;br/&gt;
+ * information on the Apache Software Foundation, please see&lt;br/&gt;
+ * &amp;lt;&lt;a href=&quot;http://www.apache.org/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.apache.org/&lt;/a&gt;&amp;gt;.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+&lt;br/&gt;
+import org.xml.sax.SAXException;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * &amp;lt;p&amp;gt;A specialized SAX2 XML parser that processes configuration objects.&amp;lt;/p&amp;gt;&lt;br/&gt;
+ * &amp;lt;p&amp;gt;This class mimics to be a SAX compliant XML parser. It is able to iterate&lt;br/&gt;
+ * over the keys in a configuration object and to generate corresponding SAX&lt;br/&gt;
+ * events. By registering a &amp;lt;code&amp;gt;ContentHandler&amp;lt;/code&amp;gt; at an instance&lt;br/&gt;
+ * it is possible to perform XML processing on a configuration object.&amp;lt;/p&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * @author &amp;lt;a href=&quot;mailto:oliver.heger@t-online.de&quot;&amp;gt;Oliver Heger&amp;lt;/a&amp;gt;&lt;br/&gt;
+ * @version $Id: $&lt;br/&gt;
+ */&lt;br/&gt;
+public class BaseConfigurationXMLReader extends ConfigurationXMLReader&lt;br/&gt;
+{&lt;br/&gt;
+    /** Stores the actual configuration.*/&lt;br/&gt;
+    private Configuration config;&lt;br/&gt;
+    &lt;br/&gt;
+    /**&lt;br/&gt;
+     * Creates a new instance of &amp;lt;code&amp;gt;BaseConfigurationXMLReader&amp;lt;/code&amp;gt;.&lt;br/&gt;
+     */&lt;br/&gt;
+    public BaseConfigurationXMLReader()&lt;br/&gt;
+    &lt;/p&gt;
{
+        super();
+    }&lt;br/&gt;
+    &lt;br/&gt;
+    /**&lt;br/&gt;
+     * Creates a new instance of &amp;lt;code&amp;gt;BaseConfigurationXMLReader&amp;lt;/code&amp;gt; and&lt;br/&gt;
+     * sets the configuration object to be parsed.&lt;br/&gt;
+     * @param conf the configuration to be parsed&lt;br/&gt;
+     */&lt;br/&gt;
+    public BaseConfigurationXMLReader(Configuration conf)&lt;br/&gt;
+    {
+        this();
+        setConfiguration(conf);
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Returns the actual configuration to be processed.&lt;br/&gt;
+     * @return the actual configuration&lt;br/&gt;
+     */&lt;br/&gt;
+    public Configuration getConfiguration()&lt;br/&gt;
+    {
+        return config;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Sets the configuration to be processed.&lt;br/&gt;
+     * @param conf the configuration&lt;br/&gt;
+     */&lt;br/&gt;
+    public void setConfiguration(Configuration conf)&lt;br/&gt;
+    {
+        config = conf;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Returns the configuration to be processed.&lt;br/&gt;
+     * @return the actual configuration&lt;br/&gt;
+     */&lt;br/&gt;
+    public Configuration getParsedConfiguration()&lt;br/&gt;
+    {
+        return getConfiguration();
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The main SAX event generation method. This element uses an internal&lt;br/&gt;
+     * &amp;lt;code&amp;gt;HierarchicalConfigurationConverter&amp;lt;/code&amp;gt; object to iterate over&lt;br/&gt;
+     * all keys in the actual configuration and to generate corresponding SAX&lt;br/&gt;
+     * events.&lt;br/&gt;
+     * @throws IOException if no configuration object is specified&lt;br/&gt;
+     * @throws SAXException if a SAXException occurs during parsing&lt;br/&gt;
+     */&lt;br/&gt;
+    protected void processKeys() throws IOException, SAXException&lt;br/&gt;
+    {
+        fireElementStart(getRootName(), null);
+        new SAXConverter().process(getConfiguration());
+        fireElementEnd(getRootName());
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * An internally used helper class to iterate over all configuration keys&lt;br/&gt;
+     * ant to generate corresponding SAX events.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @author &amp;lt;a href=&quot;mailto:oliver.heger@t-online.de&quot;&amp;gt;Oliver Heger&amp;lt;/a&amp;gt;&lt;br/&gt;
+     */&lt;br/&gt;
+    class SAXConverter extends HierarchicalConfigurationConverter&lt;br/&gt;
+    {&lt;br/&gt;
+        /**&lt;br/&gt;
+         * Callback for the start of an element.&lt;br/&gt;
+         * @param name the element name&lt;br/&gt;
+         * @param value the element value&lt;br/&gt;
+         */&lt;br/&gt;
+        protected void elementStart(String name, Object value)&lt;br/&gt;
+        {&lt;br/&gt;
+            fireElementStart(name, null);&lt;br/&gt;
+            if(value != null)&lt;br/&gt;
+            {
+                fireCharacters(value.toString());
+            }  /* if */&lt;br/&gt;
+        }&lt;br/&gt;
+&lt;br/&gt;
+        /**&lt;br/&gt;
+         * Callback for the end of an element.&lt;br/&gt;
+         * @param name the element name&lt;br/&gt;
+         */&lt;br/&gt;
+        protected void elementEnd(String name)&lt;br/&gt;
+        {
+            fireElementEnd(name);
+        }&lt;br/&gt;
+    }&lt;br/&gt;
+}&lt;br/&gt;
Index: src/java/org/apache/commons/configuration/ConfigurationKey.java&lt;br/&gt;
===================================================================&lt;br/&gt;
RCS file: src/java/org/apache/commons/configuration/ConfigurationKey.java&lt;br/&gt;
diff -N src/java/org/apache/commons/configuration/ConfigurationKey.java&lt;br/&gt;
&amp;#8212; /dev/null	1 Jan 1970 00:00:00 -0000&lt;br/&gt;
+++ src/java/org/apache/commons/configuration/ConfigurationKey.java	30 Oct 2003&lt;br/&gt;
17:27:12 -0000&lt;br/&gt;
@@ -0,0 +1,635 @@&lt;br/&gt;
+package org.apache.commons.configuration;&lt;br/&gt;
+&lt;br/&gt;
+/* ====================================================================&lt;br/&gt;
+ * The Apache Software License, Version 1.1&lt;br/&gt;
+ *&lt;br/&gt;
+ * Copyright (c) 1999-2002 The Apache Software Foundation.  All rights&lt;br/&gt;
+ * reserved.&lt;br/&gt;
+ *&lt;br/&gt;
+ * Redistribution and use in source and binary forms, with or without&lt;br/&gt;
+ * modification, are permitted provided that the following conditions&lt;br/&gt;
+ * are met:&lt;br/&gt;
+ *&lt;br/&gt;
+ * 1. Redistributions of source code must retain the above copyright&lt;br/&gt;
+ *    notice, this list of conditions and the following disclaimer.&lt;br/&gt;
+ *&lt;br/&gt;
+ * 2. Redistributions in binary form must reproduce the above copyright&lt;br/&gt;
+ *    notice, this list of conditions and the following disclaimer in&lt;br/&gt;
+ *    the documentation and/or other materials provided with the&lt;br/&gt;
+ *    distribution.&lt;br/&gt;
+ *&lt;br/&gt;
+ * 3. The end-user documentation included with the redistribution, if&lt;br/&gt;
+ *    any, must include the following acknowlegement:&lt;br/&gt;
+ *       &quot;This product includes software developed by the&lt;br/&gt;
+ *        Apache Software Foundation (&lt;a href=&quot;http://www.apache.org/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.apache.org/&lt;/a&gt;).&quot;&lt;br/&gt;
+ *    Alternately, this acknowlegement may appear in the software itself,&lt;br/&gt;
+ *    if and wherever such third-party acknowlegements normally appear.&lt;br/&gt;
+ *&lt;br/&gt;
+ * 4. The names &quot;The Jakarta Project&quot;, &quot;Commons&quot;, and &quot;Apache Software&lt;br/&gt;
+ *    Foundation&quot; must not be used to endorse or promote products derived&lt;br/&gt;
+ *    from this software without prior written permission. For written&lt;br/&gt;
+ *    permission, please contact apache@apache.org.&lt;br/&gt;
+ *&lt;br/&gt;
+ * 5. Products derived from this software may not be called &quot;Apache&quot;&lt;br/&gt;
+ *    nor may &quot;Apache&quot; appear in their names without prior written&lt;br/&gt;
+ *    permission of the Apache Group.&lt;br/&gt;
+ *&lt;br/&gt;
+ * THIS SOFTWARE IS PROVIDED ``AS IS&apos;&apos; AND ANY EXPRESSED OR IMPLIED&lt;br/&gt;
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES&lt;br/&gt;
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE&lt;br/&gt;
+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR&lt;br/&gt;
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,&lt;br/&gt;
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT&lt;br/&gt;
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF&lt;br/&gt;
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND&lt;br/&gt;
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,&lt;br/&gt;
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT&lt;br/&gt;
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF&lt;br/&gt;
+ * SUCH DAMAGE.&lt;br/&gt;
+ * ====================================================================&lt;br/&gt;
+ *&lt;br/&gt;
+ * This software consists of voluntary contributions made by many&lt;br/&gt;
+ * individuals on behalf of the Apache Software Foundation.  For more&lt;br/&gt;
+ * information on the Apache Software Foundation, please see&lt;br/&gt;
+ * &amp;lt;&lt;a href=&quot;http://www.apache.org/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.apache.org/&lt;/a&gt;&amp;gt;.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+import java.io.Serializable;&lt;br/&gt;
+import java.util.Iterator;&lt;br/&gt;
+import java.util.NoSuchElementException;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * &amp;lt;p&amp;gt;A simple class that supports creation of and iteration on complex&lt;br/&gt;
+ * configuration keys.&amp;lt;/p&amp;gt;&lt;br/&gt;
+ * &amp;lt;p&amp;gt;For key creation the class works similar to a StringBuffer: There are&lt;br/&gt;
+ * several &amp;lt;code&amp;gt;appendXXXX()&amp;lt;/code&amp;gt; methods with which single parts&lt;br/&gt;
+ * of a key can be constructed. All these methods return a reference to the&lt;br/&gt;
+ * actual object so they can be written in a chain. When using this methods&lt;br/&gt;
+ * the exact syntax for keys need not be known.&amp;lt;/p&amp;gt;&lt;br/&gt;
+ * &amp;lt;p&amp;gt;This class also defines a specialized iterator for configuration keys.&lt;br/&gt;
+ * With such an iterator a key can be tokenized into its single parts. For&lt;br/&gt;
+ * each part it can be checked whether it has an associated index.&amp;lt;/p&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * @author &amp;lt;a href=&quot;mailto:oliver.heger@t-online.de&quot;&amp;gt;Oliver Heger&amp;lt;/a&amp;gt;&lt;br/&gt;
+ * @version $Id: $&lt;br/&gt;
+ */&lt;br/&gt;
+public class ConfigurationKey implements Serializable&lt;br/&gt;
+{&lt;br/&gt;
+    /** Constant for an attribute start marker.*/&lt;br/&gt;
+    private static final String ATTRIBUTE_START = &quot;[@&quot;;&lt;br/&gt;
+&lt;br/&gt;
+    /** Constant for an attribute end marker.*/&lt;br/&gt;
+    private static final String ATTRIBUTE_END = &quot;]&quot;;&lt;br/&gt;
+&lt;br/&gt;
+    /** Constant for a property delimiter.*/&lt;br/&gt;
+    private static final char PROPERTY_DELIMITER = &apos;.&apos;;&lt;br/&gt;
+&lt;br/&gt;
+    /** Constant for an index start marker.*/&lt;br/&gt;
+    private static final char INDEX_START = &apos;(&apos;;&lt;br/&gt;
+&lt;br/&gt;
+    /** Constant for an index end marker.*/&lt;br/&gt;
+    private static final char INDEX_END = &apos;)&apos;;&lt;br/&gt;
+&lt;br/&gt;
+    /** Constant for the initial StringBuffer size.*/&lt;br/&gt;
+    private static final int INITIAL_SIZE = 32;&lt;br/&gt;
+&lt;br/&gt;
+    /** Holds a buffer with the so far created key.*/&lt;br/&gt;
+    private StringBuffer keyBuffer;&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Creates a new, empty instance of &amp;lt;code&amp;gt;ConfigurationKey&amp;lt;/code&amp;gt;.&lt;br/&gt;
+     */&lt;br/&gt;
+    public ConfigurationKey()&lt;br/&gt;
+    {
+        keyBuffer = new StringBuffer(INITIAL_SIZE);
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Creates a new instance of &amp;lt;code&amp;gt;ConfigurationKey&amp;lt;/code&amp;gt; and&lt;br/&gt;
+     * initializes it with the given key.&lt;br/&gt;
+     * @param key the key as a string&lt;br/&gt;
+     */&lt;br/&gt;
+    public ConfigurationKey(String key)&lt;br/&gt;
+    {
+        keyBuffer = new StringBuffer(key);
+        removeTrailingDelimiter();
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Appends the name of a property to this key. If necessary, a&lt;br/&gt;
+     * property delimiter will be added.&lt;br/&gt;
+     * @param property the name of the property to be added&lt;br/&gt;
+     * @return a reference to this object&lt;br/&gt;
+     */&lt;br/&gt;
+    public ConfigurationKey append(String property)&lt;br/&gt;
+    {&lt;br/&gt;
+        if(keyBuffer.length() &amp;gt; 0 &amp;amp;&amp;amp; !hasDelimiter()&lt;br/&gt;
+        &amp;amp;&amp;amp; !isAttributeKey(property))&lt;br/&gt;
+        {
+            keyBuffer.append(PROPERTY_DELIMITER);
+        }  /* if */&lt;br/&gt;
+&lt;br/&gt;
+        keyBuffer.append(property);&lt;br/&gt;
+        removeTrailingDelimiter();&lt;br/&gt;
+        return this;&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Appends an index to this configuration key.&lt;br/&gt;
+     * @param index the index to be appended&lt;br/&gt;
+     * @return a reference to this object&lt;br/&gt;
+     */&lt;br/&gt;
+    public ConfigurationKey appendIndex(int index)&lt;br/&gt;
+    {
+        keyBuffer.append(INDEX_START).append(index);
+        keyBuffer.append(INDEX_END);
+        return this;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Appends an attribute to this configuration key.&lt;br/&gt;
+     * @param attr the name of the attribute to be appended&lt;br/&gt;
+     * @return a reference to this object&lt;br/&gt;
+     */&lt;br/&gt;
+    public ConfigurationKey appendAttribute(String attr)&lt;br/&gt;
+    {
+        keyBuffer.append(constructAttributeKey(attr));
+        return this;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Checks if the passed in key is an attribute key. Such attribute keys&lt;br/&gt;
+     * start and end with certain marker strings. In some cases they must be&lt;br/&gt;
+     * treated slightly different.&lt;br/&gt;
+     * @param key the key (part) to be checked&lt;br/&gt;
+     * @return a flag if this key is an attribute key&lt;br/&gt;
+     */&lt;br/&gt;
+    public static boolean isAttributeKey(String key)&lt;br/&gt;
+    {
+        return key != null
+        &amp;amp;&amp;amp; key.startsWith(ATTRIBUTE_START) 
+        &amp;amp;&amp;amp; key.endsWith(ATTRIBUTE_END);
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Decorates the given key so that it represents an attribute. Adds&lt;br/&gt;
+     * special start and end markers.&lt;br/&gt;
+     * @param key the key to be decorated&lt;br/&gt;
+     * @return the decorated attribute key&lt;br/&gt;
+     */&lt;br/&gt;
+    public static String constructAttributeKey(String key)&lt;br/&gt;
+    {
+        StringBuffer buf = new StringBuffer();
+        buf.append(ATTRIBUTE_START).append(key).append(ATTRIBUTE_END);
+        return buf.toString();
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Extracts the name of the attribute from the given attribute key.&lt;br/&gt;
+     * This method removes the attribute markers - if any - from the&lt;br/&gt;
+     * specified key.&lt;br/&gt;
+     * @param key the attribute key&lt;br/&gt;
+     * @return the name of the corresponding attribute&lt;br/&gt;
+     */&lt;br/&gt;
+    public static String attributeName(String key)&lt;br/&gt;
+    {
+        return (isAttributeKey(key)) ?
+        removeAttributeMarkers(key) : key;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Helper method for removing attribute markers from a key.&lt;br/&gt;
+     * @param key the key&lt;br/&gt;
+     * @return the key with removed attribute markers&lt;br/&gt;
+     */&lt;br/&gt;
+    private static String removeAttributeMarkers(String key)&lt;br/&gt;
+    {
+        return key.substring(ATTRIBUTE_START.length(),
+        key.length() - ATTRIBUTE_END.length());
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Helper method that checks if the actual buffer ends with a property&lt;br/&gt;
+     * delimiter.&lt;br/&gt;
+     * @return a flag if there is a trailing delimiter&lt;br/&gt;
+     */&lt;br/&gt;
+    private boolean hasDelimiter()&lt;br/&gt;
+    {
+        return keyBuffer.length() &amp;gt; 0
+        &amp;amp;&amp;amp; keyBuffer.charAt(keyBuffer.length()-1) == PROPERTY_DELIMITER;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Removes a trailing delimiter if there is any.&lt;br/&gt;
+     */&lt;br/&gt;
+    private void removeTrailingDelimiter()&lt;br/&gt;
+    {&lt;br/&gt;
+        while(hasDelimiter())&lt;br/&gt;
+        {
+            keyBuffer.deleteCharAt(keyBuffer.length()-1);
+        }  /* while */&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Returns a string representation of this object. This is the&lt;br/&gt;
+     * configuration key as a plain string.&lt;br/&gt;
+     * @return a string for this object&lt;br/&gt;
+     */&lt;br/&gt;
+    public String toString()&lt;br/&gt;
+    {
+        return keyBuffer.toString();
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Returns an iterator for iterating over the single components of&lt;br/&gt;
+     * this configuration key.&lt;br/&gt;
+     * @return an iterator for this key&lt;br/&gt;
+     */&lt;br/&gt;
+    public KeyIterator iterator()&lt;br/&gt;
+    {
+        return new KeyIterator();
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Returns the actual length of this configuration key.&lt;br/&gt;
+     * @return the length of this key&lt;br/&gt;
+     */&lt;br/&gt;
+    public int length()&lt;br/&gt;
+    {
+        return keyBuffer.length();
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Sets the new length of this configuration key. With this method it is&lt;br/&gt;
+     * possible to truncate the key, e.g. to return to a state prior calling&lt;br/&gt;
+     * some &amp;lt;code&amp;gt;append()&amp;lt;/code&amp;gt; methods. The semantic is the same as&lt;br/&gt;
+     * the &amp;lt;code&amp;gt;setLength()&amp;lt;/code&amp;gt; method of &amp;lt;code&amp;gt;StringBuffer&amp;lt;/code&amp;gt;.&lt;br/&gt;
+     * @param len the new length of the key&lt;br/&gt;
+     */&lt;br/&gt;
+    public void setLength(int len)&lt;br/&gt;
+    {
+        keyBuffer.setLength(len);
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Checks if two &amp;lt;code&amp;gt;ConfigurationKey&amp;lt;/code&amp;gt; objects are equal. The&lt;br/&gt;
+     * method can be called with strings or other objects, too.&lt;br/&gt;
+     * @param c the object to compare&lt;br/&gt;
+     * @return a flag if both objects are equal&lt;br/&gt;
+     */&lt;br/&gt;
+    public boolean equals(Object c)&lt;br/&gt;
+    {&lt;br/&gt;
+        if(c == null)&lt;br/&gt;
+        {
+            return false;
+        }  /* if */&lt;br/&gt;
+&lt;br/&gt;
+        return keyBuffer.toString().equals(c.toString());&lt;br/&gt;
+    }&lt;br/&gt;
+    &lt;br/&gt;
+    /**&lt;br/&gt;
+     * Returns the hash code for this object.&lt;br/&gt;
+     * @return the hash code&lt;br/&gt;
+     */&lt;br/&gt;
+    public int hashCode()&lt;br/&gt;
+    {
+        return keyBuffer.hashCode();
+    }&lt;br/&gt;
+    &lt;br/&gt;
+    /**&lt;br/&gt;
+     * Returns a configuration key object that is initialized with the part&lt;br/&gt;
+     * of the key that is common to this key and the passed in key.&lt;br/&gt;
+     * @param other the other key&lt;br/&gt;
+     * @return a key object with the common key part&lt;br/&gt;
+     */&lt;br/&gt;
+    public ConfigurationKey commonKey(ConfigurationKey other)&lt;br/&gt;
+    {&lt;br/&gt;
+        if(other == null)&lt;br/&gt;
+        {
+            throw new IllegalArgumentException(&quot;Other key must no be null!&quot;);
+        }  /* if */&lt;br/&gt;
+        &lt;br/&gt;
+        ConfigurationKey result = new ConfigurationKey();&lt;br/&gt;
+        KeyIterator it1 = iterator();&lt;br/&gt;
+        KeyIterator it2 = other.iterator();&lt;br/&gt;
+        &lt;br/&gt;
+        while(it1.hasNext() &amp;amp;&amp;amp; it2.hasNext()&lt;br/&gt;
+        &amp;amp;&amp;amp; partsEqual(it1, it2))&lt;br/&gt;
+        {&lt;br/&gt;
+            if(it1.isAttribute())&lt;br/&gt;
+            {
+                result.appendAttribute(it1.currentKey());
+            }  /* if */&lt;br/&gt;
+            else&lt;br/&gt;
+            {&lt;br/&gt;
+                result.append(it1.currentKey());&lt;br/&gt;
+                if(it1.hasIndex)&lt;br/&gt;
+                {
+                    result.appendIndex(it1.getIndex());
+                }  /* if */&lt;br/&gt;
+            }  /* else */&lt;br/&gt;
+        }  /* while */&lt;br/&gt;
+        &lt;br/&gt;
+        return result;&lt;br/&gt;
+    }&lt;br/&gt;
+    &lt;br/&gt;
+    /**&lt;br/&gt;
+     * Returns the &amp;quot;difference key&amp;quot; to a given key. This value&lt;br/&gt;
+     * is the part of the passed in key that differs from this key. There is&lt;br/&gt;
+     * the following relation:&lt;br/&gt;
+     * &amp;lt;code&amp;gt;other = key.commonKey(other) + key.differenceKey(other)&amp;lt;/code&amp;gt;&lt;br/&gt;
+     * for an arbitrary configuration key &amp;lt;code&amp;gt;key&amp;lt;/code&amp;gt;.&lt;br/&gt;
+     * @param other the key for which the difference is to be calculated&lt;br/&gt;
+     * @return the difference key&lt;br/&gt;
+     */&lt;br/&gt;
+    public ConfigurationKey differenceKey(ConfigurationKey other)&lt;br/&gt;
+    {&lt;br/&gt;
+        ConfigurationKey common = commonKey(other);&lt;br/&gt;
+        ConfigurationKey result = new ConfigurationKey();&lt;br/&gt;
+        &lt;br/&gt;
+        if(common.length() &amp;lt; other.length())&lt;br/&gt;
+        {&lt;br/&gt;
+            String k = other.toString().substring(common.length());&lt;br/&gt;
+            // skip trailing delimiters&lt;br/&gt;
+            int i = 0;&lt;br/&gt;
+            while(i &amp;lt; k.length() &amp;amp;&amp;amp; k.charAt&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; == PROPERTY_DELIMITER)&lt;br/&gt;
+            {
+                i++;
+            }  /* while */&lt;br/&gt;
+            &lt;br/&gt;
+            if(i &amp;lt; k.length())&lt;br/&gt;
+            {
+                result.append(k.substring(i));
+            }  /* if */&lt;br/&gt;
+        }  /* if */&lt;br/&gt;
+        &lt;br/&gt;
+        return result;&lt;br/&gt;
+    }&lt;br/&gt;
+    &lt;br/&gt;
+    /**&lt;br/&gt;
+     * Helper method for comparing two key parts.&lt;br/&gt;
+     * @param it1 the iterator with the first part&lt;br/&gt;
+     * @param it2 the iterator with the second part&lt;br/&gt;
+     * @return a flag if both parts are equal&lt;br/&gt;
+     */&lt;br/&gt;
+    private static boolean partsEqual(KeyIterator it1, KeyIterator it2)&lt;br/&gt;
+    {
+        return it1.nextKey().equals(it2.nextKey())
+        &amp;amp;&amp;amp; it1.getIndex() == it2.getIndex()
+        &amp;amp;&amp;amp; it1.isAttribute() == it2.isAttribute();
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * A specialized iterator class for tokenizing a configuration key.&lt;br/&gt;
+     * This class implements the normal iterator interface. In addition it&lt;br/&gt;
+     * provides some specific methods for configuration keys.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @author &amp;lt;a href=&quot;mailto:oliver.heger@t-online.de&quot;&amp;gt;Oliver Heger&amp;lt;/a&amp;gt;&lt;br/&gt;
+     */&lt;br/&gt;
+    public class KeyIterator implements Iterator, Cloneable&lt;br/&gt;
+    {&lt;br/&gt;
+        /** Stores the current key name.*/&lt;br/&gt;
+        private String current;&lt;br/&gt;
+&lt;br/&gt;
+        /** Stores the start index of the actual token.*/&lt;br/&gt;
+        private int startIndex;&lt;br/&gt;
+&lt;br/&gt;
+        /** Stores the end index of the actual token.*/&lt;br/&gt;
+        private int endIndex;&lt;br/&gt;
+&lt;br/&gt;
+        /** Stores the index of the actual property if there is one.*/&lt;br/&gt;
+        private int indexValue;&lt;br/&gt;
+&lt;br/&gt;
+        /** Stores a flag if the actual property has an index.*/&lt;br/&gt;
+        private boolean hasIndex;&lt;br/&gt;
+&lt;br/&gt;
+        /** Stores a flag if the actual property is an attribute.*/&lt;br/&gt;
+        private boolean attribute;&lt;br/&gt;
+&lt;br/&gt;
+        /**&lt;br/&gt;
+         * Helper method for determining the next indices.&lt;br/&gt;
+         */&lt;br/&gt;
+        private void findNextIndices()&lt;br/&gt;
+        {&lt;br/&gt;
+            startIndex = endIndex;&lt;br/&gt;
+            // skip empty names&lt;br/&gt;
+            while(startIndex &amp;lt; keyBuffer.length()&lt;br/&gt;
+            &amp;amp;&amp;amp; keyBuffer.charAt(startIndex) == PROPERTY_DELIMITER)&lt;br/&gt;
+            {
+                startIndex++;
+            }  /* while */&lt;br/&gt;
+&lt;br/&gt;
+            // Key ends with a delimiter?&lt;br/&gt;
+            if(startIndex &amp;gt;= keyBuffer.length())&lt;br/&gt;
+            {
+                endIndex = keyBuffer.length();
+                startIndex = endIndex - 1;
+            }  /* if */&lt;br/&gt;
+&lt;br/&gt;
+            else&lt;br/&gt;
+            {&lt;br/&gt;
+                endIndex = keyBuffer.indexOf(&lt;br/&gt;
+                String.valueOf(PROPERTY_DELIMITER), startIndex);&lt;br/&gt;
+                if(endIndex &amp;lt; 0)&lt;br/&gt;
+                {&lt;br/&gt;
+                    endIndex = keyBuffer.indexOf(ATTRIBUTE_START, startIndex);&lt;br/&gt;
+                    if(endIndex &amp;lt; 0 || endIndex == startIndex)&lt;br/&gt;
+                    {
+                        endIndex = keyBuffer.length(); 
+                    }  /* if */&lt;br/&gt;
+                }  /* if */&lt;br/&gt;
+            }&lt;br/&gt;
+        }&lt;br/&gt;
+&lt;br/&gt;
+        /**&lt;br/&gt;
+         * Returns the next key part of this configuration key. This is a short&lt;br/&gt;
+         * form of &amp;lt;code&amp;gt;nextKey(false)&amp;lt;/code&amp;gt;.&lt;br/&gt;
+         * @return the next key part&lt;br/&gt;
+         */&lt;br/&gt;
+        public String nextKey()&lt;br/&gt;
+        {
+            return nextKey(false);
+        }&lt;br/&gt;
+&lt;br/&gt;
+        /**&lt;br/&gt;
+         * Returns the next key part of this configuration key. The boolean&lt;br/&gt;
+         * parameter indicates wheter a decorated key should be returned. This&lt;br/&gt;
+         * affects only attribute keys: if the parameter is &amp;lt;b&amp;gt;false&amp;lt;/b&amp;gt;, the&lt;br/&gt;
+         * attribute markers are stripped from the key; if it is &amp;lt;b&amp;gt;true&amp;lt;/b&amp;gt;,&lt;br/&gt;
+         * they remain.&lt;br/&gt;
+         * @param decorated a flag if the decorated key is to be returned&lt;br/&gt;
+         * @return the next key part&lt;br/&gt;
+         */&lt;br/&gt;
+        public String nextKey(boolean decorated)&lt;br/&gt;
+        {&lt;br/&gt;
+            if(!hasNext())&lt;br/&gt;
+            {
+                throw new NoSuchElementException(&quot;No more key parts!&quot;);
+            }  /* if */&lt;br/&gt;
+&lt;br/&gt;
+            hasIndex = false;&lt;br/&gt;
+            indexValue = -1;&lt;br/&gt;
+            findNextIndices();&lt;br/&gt;
+            String key = keyBuffer.substring(startIndex, endIndex).toString();&lt;br/&gt;
+&lt;br/&gt;
+            attribute = checkAttribute(key);&lt;br/&gt;
+            if(!attribute)&lt;br/&gt;
+            {&lt;br/&gt;
+                hasIndex = checkIndex(key);&lt;br/&gt;
+                if(!hasIndex)&lt;br/&gt;
+                {
+                    current = key;
+                }  /* if */&lt;br/&gt;
+            }  /* if */&lt;br/&gt;
+&lt;br/&gt;
+            return currentKey(decorated);&lt;br/&gt;
+        }&lt;br/&gt;
+&lt;br/&gt;
+        /**&lt;br/&gt;
+         * Helper method for checking if the passed key is an attribute.&lt;br/&gt;
+         * If this is the case, the internal fields will be set.&lt;br/&gt;
+         * @param key the key to be checked&lt;br/&gt;
+         * @return a flag if the key is an attribute&lt;br/&gt;
+         */&lt;br/&gt;
+        private boolean checkAttribute(String key)&lt;br/&gt;
+        {&lt;br/&gt;
+            if(isAttributeKey(key))&lt;br/&gt;
+            {
+                current = removeAttributeMarkers(key);
+                return true;
+            }  /* if */&lt;br/&gt;
+            else&lt;br/&gt;
+            {
+                return false;
+            }  /* else */&lt;br/&gt;
+        }&lt;br/&gt;
+&lt;br/&gt;
+        /**&lt;br/&gt;
+         * Helper method for checking if the passed key contains an index.&lt;br/&gt;
+         * If this is the case, internal fields will be set.&lt;br/&gt;
+         * @param key the key to be checked&lt;br/&gt;
+         * @return a flag if an index is defined&lt;br/&gt;
+         */&lt;br/&gt;
+        private boolean checkIndex(String key)&lt;br/&gt;
+        {&lt;br/&gt;
+            boolean result = false;&lt;br/&gt;
+&lt;br/&gt;
+            int idx = key.indexOf(INDEX_START);&lt;br/&gt;
+            if(idx &amp;gt; 0)&lt;br/&gt;
+            {&lt;br/&gt;
+                int endidx = key.indexOf(INDEX_END, idx);&lt;br/&gt;
+                &lt;br/&gt;
+                if(endidx &amp;gt; idx + 1)&lt;br/&gt;
+                {
+                    indexValue = Integer.parseInt(key.substring(idx+1, endidx));
+                    current = key.substring(0, idx);
+                    result = true;
+                }  /* if */&lt;br/&gt;
+            }  /* if */&lt;br/&gt;
+&lt;br/&gt;
+            return result;&lt;br/&gt;
+        }&lt;br/&gt;
+&lt;br/&gt;
+        /**&lt;br/&gt;
+         * Checks if there is a next element.&lt;br/&gt;
+         * @return a flag if there is a next element&lt;br/&gt;
+         */&lt;br/&gt;
+        public boolean hasNext()&lt;br/&gt;
+        {
+            return endIndex &amp;lt; keyBuffer.length();
+        }&lt;br/&gt;
+&lt;br/&gt;
+        /**&lt;br/&gt;
+         * Returns the next object in the iteration.&lt;br/&gt;
+         * @return the next object&lt;br/&gt;
+         */&lt;br/&gt;
+        public Object next()&lt;br/&gt;
+        {
+            return nextKey();
+        }&lt;br/&gt;
+&lt;br/&gt;
+        /**&lt;br/&gt;
+         * Removes the current object in the iteration. This method is not&lt;br/&gt;
+         * supported by this iterator type, so an exception is thrown.&lt;br/&gt;
+         */&lt;br/&gt;
+        public void remove()&lt;br/&gt;
+        {
+            throw new UnsupportedOperationException(&quot;Remove not supported!&quot;);
+        }&lt;br/&gt;
+&lt;br/&gt;
+        /**&lt;br/&gt;
+         * Returns the current key of the iteration (without skipping to the&lt;br/&gt;
+         * next element). This is the same key the previous &amp;lt;code&amp;gt;next()&amp;lt;/code&amp;gt;&lt;br/&gt;
+         * call had returned. (Short form of &amp;lt;code&amp;gt;currentKey(false)&amp;lt;/code&amp;gt;.&lt;br/&gt;
+         * @return the current key&lt;br/&gt;
+         */&lt;br/&gt;
+        public String currentKey()&lt;br/&gt;
+        {
+            return currentKey(false);
+        }&lt;br/&gt;
+&lt;br/&gt;
+        /**&lt;br/&gt;
+         * Returns the current key of the iteration (without skipping to the&lt;br/&gt;
+         * next element). The boolean parameter indicates wheter a decorated&lt;br/&gt;
+         * key should be returned. This affects only attribute keys: if the&lt;br/&gt;
+         * parameter is &amp;lt;b&amp;gt;false&amp;lt;/b&amp;gt;, the attribute markers are stripped from&lt;br/&gt;
+         * the key; if it is &amp;lt;b&amp;gt;true&amp;lt;/b&amp;gt;, they remain.&lt;br/&gt;
+         * @param decorated a flag if the decorated key is to be returned&lt;br/&gt;
+         * @return the current key&lt;br/&gt;
+         */&lt;br/&gt;
+        public String currentKey(boolean decorated)&lt;br/&gt;
+        {
+            return (decorated &amp;amp;&amp;amp; isAttribute()) ?
+            constructAttributeKey(current) : current;
+        }&lt;br/&gt;
+&lt;br/&gt;
+        /**&lt;br/&gt;
+         * Returns a flag if the current key is an attribute. This method can&lt;br/&gt;
+         * be called after &amp;lt;code&amp;gt;next()&amp;lt;/code&amp;gt;.&lt;br/&gt;
+         * @return a flag if the current key is an attribute&lt;br/&gt;
+         */&lt;br/&gt;
+        public boolean isAttribute()&lt;br/&gt;
+        {
+            return attribute;
+        }&lt;br/&gt;
+&lt;br/&gt;
+        /**&lt;br/&gt;
+         * Returns the index value of the current key. If the current key does&lt;br/&gt;
+         * not have an index, return value is -1. This method can be called&lt;br/&gt;
+         * after &amp;lt;code&amp;gt;next()&amp;lt;/code&amp;gt;.&lt;br/&gt;
+         * @return the index value of the current key&lt;br/&gt;
+         */&lt;br/&gt;
+        public int getIndex()&lt;br/&gt;
+        {
+            return indexValue;
+        }&lt;br/&gt;
+&lt;br/&gt;
+        /**&lt;br/&gt;
+         * Returns a flag if the current key has an associated index.&lt;br/&gt;
+         * This method can be called after &amp;lt;code&amp;gt;next()&amp;lt;/code&amp;gt;.&lt;br/&gt;
+         * @return a flag if the current key has an index&lt;br/&gt;
+         */&lt;br/&gt;
+        public boolean hasIndex()&lt;br/&gt;
+        {
+            return hasIndex;
+        }&lt;br/&gt;
+&lt;br/&gt;
+        /**&lt;br/&gt;
+         * Creates a clone of this object.&lt;br/&gt;
+         * @return a clone of this object&lt;br/&gt;
+         */&lt;br/&gt;
+        protected Object clone()&lt;br/&gt;
+        {&lt;br/&gt;
+            try&lt;br/&gt;
+            {
+                return super.clone();
+            }  /* try */&lt;br/&gt;
+            catch(CloneNotSupportedException cex)&lt;br/&gt;
+             {
+                 // should not happen
+                 return null;
+             }  /* catch */&lt;br/&gt;
+        }&lt;br/&gt;
+&lt;br/&gt;
+    }&lt;br/&gt;
+}&lt;br/&gt;
Index: src/java/org/apache/commons/configuration/ConfigurationXMLReader.java&lt;br/&gt;
===================================================================&lt;br/&gt;
RCS file: src/java/org/apache/commons/configuration/ConfigurationXMLReader.java&lt;br/&gt;
diff -N src/java/org/apache/commons/configuration/ConfigurationXMLReader.java&lt;br/&gt;
&amp;#8212; /dev/null	1 Jan 1970 00:00:00 -0000&lt;br/&gt;
+++ src/java/org/apache/commons/configuration/ConfigurationXMLReader.java	30 Oct&lt;br/&gt;
2003 17:27:15 -0000&lt;br/&gt;
@@ -0,0 +1,377 @@&lt;br/&gt;
+package org.apache.commons.configuration;&lt;br/&gt;
+&lt;br/&gt;
+/* ====================================================================&lt;br/&gt;
+ * The Apache Software License, Version 1.1&lt;br/&gt;
+ *&lt;br/&gt;
+ * Copyright (c) 1999-2003 The Apache Software Foundation.  All rights&lt;br/&gt;
+ * reserved.&lt;br/&gt;
+ *&lt;br/&gt;
+ * Redistribution and use in source and binary forms, with or without&lt;br/&gt;
+ * modification, are permitted provided that the following conditions&lt;br/&gt;
+ * are met:&lt;br/&gt;
+ *&lt;br/&gt;
+ * 1. Redistributions of source code must retain the above copyright&lt;br/&gt;
+ *    notice, this list of conditions and the following disclaimer.&lt;br/&gt;
+ *&lt;br/&gt;
+ * 2. Redistributions in binary form must reproduce the above copyright&lt;br/&gt;
+ *    notice, this list of conditions and the following disclaimer in&lt;br/&gt;
+ *    the documentation and/or other materials provided with the&lt;br/&gt;
+ *    distribution.&lt;br/&gt;
+ *&lt;br/&gt;
+ * 3. The end-user documentation included with the redistribution, if&lt;br/&gt;
+ *    any, must include the following acknowledgement:&lt;br/&gt;
+ *       &quot;This product includes software developed by the&lt;br/&gt;
+ *        Apache Software Foundation (&lt;a href=&quot;http://www.apache.org/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.apache.org/&lt;/a&gt;).&quot;&lt;br/&gt;
+ *    Alternately, this acknowledgement may appear in the software itself,&lt;br/&gt;
+ *    if and wherever such third-party acknowledgements normally appear.&lt;br/&gt;
+ *&lt;br/&gt;
+ * 4. The names &quot;The Jakarta Project&quot;, &quot;Commons&quot;, and &quot;Apache Software&lt;br/&gt;
+ *    Foundation&quot; must not be used to endorse or promote products derived&lt;br/&gt;
+ *    from this software without prior written permission. For written&lt;br/&gt;
+ *    permission, please contact apache@apache.org.&lt;br/&gt;
+ *&lt;br/&gt;
+ * 5. Products derived from this software may not be called &quot;Apache&quot;&lt;br/&gt;
+ *    nor may &quot;Apache&quot; appear in their names without prior written&lt;br/&gt;
+ *    permission of the Apache Software Foundation.&lt;br/&gt;
+ *&lt;br/&gt;
+ * THIS SOFTWARE IS PROVIDED ``AS IS&apos;&apos; AND ANY EXPRESSED OR IMPLIED&lt;br/&gt;
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES&lt;br/&gt;
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE&lt;br/&gt;
+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR&lt;br/&gt;
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,&lt;br/&gt;
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT&lt;br/&gt;
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF&lt;br/&gt;
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND&lt;br/&gt;
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,&lt;br/&gt;
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT&lt;br/&gt;
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF&lt;br/&gt;
+ * SUCH DAMAGE.&lt;br/&gt;
+ * ====================================================================&lt;br/&gt;
+ *&lt;br/&gt;
+ * This software consists of voluntary contributions made by many&lt;br/&gt;
+ * individuals on behalf of the Apache Software Foundation.  For more&lt;br/&gt;
+ * information on the Apache Software Foundation, please see&lt;br/&gt;
+ * &amp;lt;&lt;a href=&quot;http://www.apache.org/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.apache.org/&lt;/a&gt;&amp;gt;.&lt;br/&gt;
+ */&lt;br/&gt;
+ &lt;br/&gt;
+ import java.io.IOException;&lt;br/&gt;
+ &lt;br/&gt;
+import org.xml.sax.Attributes;&lt;br/&gt;
+import org.xml.sax.ContentHandler;&lt;br/&gt;
+import org.xml.sax.DTDHandler;&lt;br/&gt;
+import org.xml.sax.EntityResolver;&lt;br/&gt;
+import org.xml.sax.ErrorHandler;&lt;br/&gt;
+import org.xml.sax.InputSource;&lt;br/&gt;
+import org.xml.sax.SAXException;&lt;br/&gt;
+import org.xml.sax.XMLReader;&lt;br/&gt;
+import org.xml.sax.helpers.AttributesImpl;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * &amp;lt;p&amp;gt;A base class for &amp;quot;faked&amp;quot; &amp;lt;code&amp;gt;XMLReader&amp;lt;/code&amp;gt; classes&lt;br/&gt;
+ * that transform a configuration object in a set of SAX parsing events.&amp;lt;/p&amp;gt;&lt;br/&gt;
+ * &amp;lt;p&amp;gt;This class provides dummy implementations for most of the methods&lt;br/&gt;
+ * defined in the &amp;lt;code&amp;gt;XMLReader&amp;lt;/code&amp;gt; interface that are not used for this&lt;br/&gt;
+ * special purpose. There will be concrete sub classes that process specific&lt;br/&gt;
+ * configuration classes.&amp;lt;/p&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * @author &amp;lt;a href=&quot;mailto:oliver.heger@t-online.de&quot;&amp;gt;Oliver Heger&amp;lt;/a&amp;gt;&lt;br/&gt;
+ * @version $Id: $&lt;br/&gt;
+ */&lt;br/&gt;
+public abstract class ConfigurationXMLReader implements XMLReader&lt;br/&gt;
+{    &lt;br/&gt;
+    /** Constant for the namespace URI.*/&lt;br/&gt;
+    protected static final String NS_URI = &quot;&quot;;&lt;br/&gt;
+    &lt;br/&gt;
+    /** Constant for the default name of the root element.*/&lt;br/&gt;
+    private static final String DEFAULT_ROOT_NAME = &quot;config&quot;;&lt;br/&gt;
+    &lt;br/&gt;
+    /** An empty attributes object.*/&lt;br/&gt;
+    private static final Attributes EMPTY_ATTRS = new AttributesImpl();&lt;br/&gt;
+&lt;br/&gt;
+    /** Stores the content handler.*/&lt;br/&gt;
+    private ContentHandler contentHandler;&lt;br/&gt;
+&lt;br/&gt;
+    /** Stores an exception that occurred during parsing.*/&lt;br/&gt;
+    private SAXException exception;&lt;br/&gt;
+&lt;br/&gt;
+    /** Stores the name for the root element.*/&lt;br/&gt;
+    private String rootName;&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Creates a new instance of &amp;lt;code&amp;gt;ConfigurationXMLReader&amp;lt;/code&amp;gt;.&lt;br/&gt;
+     */&lt;br/&gt;
+    protected ConfigurationXMLReader()&lt;br/&gt;
+    {
+        super();
+        setRootName(DEFAULT_ROOT_NAME);
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Parses the acutal configuration object. The passed system ID will be&lt;br/&gt;
+     * ignored.&lt;br/&gt;
+     * @param systemId the system ID (ignored)&lt;br/&gt;
+     * @throws IOException if no configuration was specified&lt;br/&gt;
+     * @throws SAXException if an error occurs during parsing&lt;br/&gt;
+     */&lt;br/&gt;
+    public void parse(String systemId) throws IOException, SAXException&lt;br/&gt;
+    {
+        parseConfiguration();
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Parses the acutal configuration object. The passed input source will be&lt;br/&gt;
+     * ignored.&lt;br/&gt;
+     * @param input the input source (ignored)&lt;br/&gt;
+     * @throws IOException if no configuration was specified&lt;br/&gt;
+     * @throws SAXException if an error occurs during parsing&lt;br/&gt;
+     */&lt;br/&gt;
+    public void parse(InputSource input) throws IOException, SAXException&lt;br/&gt;
+    {+        parseConfiguration();+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Dummy implementation of the interface method.&lt;br/&gt;
+     * @param name the name of the feature&lt;br/&gt;
+     * @return always &amp;lt;b&amp;gt;false&amp;lt;/b&amp;gt; (no features are supported)&lt;br/&gt;
+     */&lt;br/&gt;
+    public boolean getFeature(String name)&lt;br/&gt;
+    {
+        return false;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Dummy implementation of the interface method.&lt;br/&gt;
+     * @param name the name of the feature to be set&lt;br/&gt;
+     * @param value the value of the feature&lt;br/&gt;
+     */&lt;br/&gt;
+    public void setFeature(String name, boolean value)&lt;br/&gt;
+    {
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Returns the actually set content handler.&lt;br/&gt;
+     * @return the content handler&lt;br/&gt;
+     */&lt;br/&gt;
+    public ContentHandler getContentHandler()&lt;br/&gt;
+    {
+        return contentHandler;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Sets the content handler. The object specified here will receive SAX&lt;br/&gt;
+     * events during parsing.&lt;br/&gt;
+     * @param handler the content handler&lt;br/&gt;
+     */&lt;br/&gt;
+    public void setContentHandler(ContentHandler handler)&lt;br/&gt;
+    {
+        contentHandler = handler;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Returns the DTD handler. This class does not support DTD handlers,&lt;br/&gt;
+     * so this method always returns &amp;lt;b&amp;gt;null&amp;lt;/b&amp;gt;.&lt;br/&gt;
+     * @return the DTD handler&lt;br/&gt;
+     */&lt;br/&gt;
+    public DTDHandler getDTDHandler()&lt;br/&gt;
+    {
+        return null;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Sets the DTD handler. The passed value is ignored.&lt;br/&gt;
+     * @param handler the handler to be set&lt;br/&gt;
+     */&lt;br/&gt;
+    public void setDTDHandler(DTDHandler handler)&lt;br/&gt;
+    {+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Returns the entity resolver. This class does not support an entity&lt;br/&gt;
+     * resolver, so this method always returns &amp;lt;b&amp;gt;null&amp;lt;/b&amp;gt;.&lt;br/&gt;
+     * @return the entity resolver&lt;br/&gt;
+     */&lt;br/&gt;
+    public EntityResolver getEntityResolver()&lt;br/&gt;
+    {
+        return null;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Sets the entity resolver. The passed value is ignored.&lt;br/&gt;
+     * @param resolver the entity resolver&lt;br/&gt;
+     */&lt;br/&gt;
+    public void setEntityResolver(EntityResolver resolver)&lt;br/&gt;
+    {
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Returns the error handler. This class does not support an error handler,&lt;br/&gt;
+     * so this method always returns &amp;lt;b&amp;gt;null&amp;lt;/b&amp;gt;.&lt;br/&gt;
+     * @return the error handler&lt;br/&gt;
+     */&lt;br/&gt;
+    public ErrorHandler getErrorHandler()&lt;br/&gt;
+    {+        return null;+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Sets the error handler. The passed value is ignored.&lt;br/&gt;
+     * @param handler the error handler&lt;br/&gt;
+     */&lt;br/&gt;
+    public void setErrorHandler(ErrorHandler handler)&lt;br/&gt;
+    {
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Dummy implementation of the interface method. No properties are&lt;br/&gt;
+     * supported, so this method always returns &amp;lt;b&amp;gt;null&amp;lt;/b&amp;gt;.&lt;br/&gt;
+     * @param name the name of the requested property&lt;br/&gt;
+     * @return the property value&lt;br/&gt;
+     */&lt;br/&gt;
+    public Object getProperty(String name)&lt;br/&gt;
+    {
+        return null;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Dummy implementation of the interface method. No properties are&lt;br/&gt;
+     * supported, so a call of this method just has no effect.&lt;br/&gt;
+     * @param name the property name&lt;br/&gt;
+     * @param value the property value&lt;br/&gt;
+     */&lt;br/&gt;
+    public void setProperty(String name, Object value)&lt;br/&gt;
+    {+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Returns the name to be used for the root element.&lt;br/&gt;
+     * @return the name for the root element&lt;br/&gt;
+     */&lt;br/&gt;
+    public String getRootName()&lt;br/&gt;
+    {
+        return rootName;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Sets the name for the root element.&lt;br/&gt;
+     * @param string the name for the root element.&lt;br/&gt;
+     */&lt;br/&gt;
+    public void setRootName(String string)&lt;br/&gt;
+    {
+        rootName = string;
+    }&lt;br/&gt;
+    &lt;br/&gt;
+    /**&lt;br/&gt;
+     * Fires a SAX element start event.&lt;br/&gt;
+     * @param name the name of the actual element&lt;br/&gt;
+     * @param attribs the attributes of this element (can be &amp;lt;b&amp;gt;null&amp;lt;/b&amp;gt;)&lt;br/&gt;
+     */&lt;br/&gt;
+    protected void fireElementStart(String name, Attributes attribs)&lt;br/&gt;
+    {&lt;br/&gt;
+        if(getException() == null)&lt;br/&gt;
+        {&lt;br/&gt;
+            try&lt;br/&gt;
+            {
+                Attributes at = (attribs == null) ? EMPTY_ATTRS : attribs;
+                getContentHandler().startElement(NS_URI, name, name, at);
+            }  /* try */&lt;br/&gt;
+            catch(SAXException ex)&lt;br/&gt;
+            {
+                exception = ex;
+            }  /* catch */&lt;br/&gt;
+        }  /* if */&lt;br/&gt;
+    }&lt;br/&gt;
+    &lt;br/&gt;
+    /**&lt;br/&gt;
+     * Fires a SAX element end event.&lt;br/&gt;
+     * @param name the name of the affected element&lt;br/&gt;
+     */&lt;br/&gt;
+    protected void fireElementEnd(String name)&lt;br/&gt;
+    {&lt;br/&gt;
+        if(getException() == null)&lt;br/&gt;
+        {&lt;br/&gt;
+            try&lt;br/&gt;
+            {
+                getContentHandler().endElement(NS_URI, name, name);
+            }  /* try */&lt;br/&gt;
+            catch(SAXException ex)&lt;br/&gt;
+            {+                exception = ex;+            }  /* catch */&lt;br/&gt;
+        }  /* if */&lt;br/&gt;
+    }&lt;br/&gt;
+    &lt;br/&gt;
+    /**&lt;br/&gt;
+     * Fires a SAX characters event.&lt;br/&gt;
+     * @param text the text&lt;br/&gt;
+     */&lt;br/&gt;
+    protected void fireCharacters(String text)&lt;br/&gt;
+    {&lt;br/&gt;
+        if(getException() == null)&lt;br/&gt;
+        {&lt;br/&gt;
+            try&lt;br/&gt;
+            {
+                char[] ch = text.toCharArray();
+                getContentHandler().characters(ch, 0, ch.length);
+            }  /* try */&lt;br/&gt;
+            catch(SAXException ex)&lt;br/&gt;
+            {
+                exception = ex;
+            }  /* catch */&lt;br/&gt;
+        }  /* if */&lt;br/&gt;
+    }&lt;br/&gt;
+    &lt;br/&gt;
+    /**&lt;br/&gt;
+     * Returns a reference to an exception that occurred during parsing.&lt;br/&gt;
+     * @return a SAXExcpetion or &amp;lt;b&amp;gt;null&amp;lt;/b&amp;gt; if none occurred&lt;br/&gt;
+     */&lt;br/&gt;
+    public SAXException getException()&lt;br/&gt;
+    {
+        return exception;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Parses the configuration object and generates SAX events. This is the&lt;br/&gt;
+     * main processing method.&lt;br/&gt;
+     * @throws IOException if no configuration has been specified&lt;br/&gt;
+     * @throws SAXException if an error occurs during parsing&lt;br/&gt;
+     */&lt;br/&gt;
+    protected void parseConfiguration() throws IOException, SAXException&lt;br/&gt;
+    {&lt;br/&gt;
+        if(getParsedConfiguration() == null)&lt;br/&gt;
+        {
+            throw new IOException(&quot;No configuration specified!&quot;);
+        }  /* if */&lt;br/&gt;
+&lt;br/&gt;
+        if(getContentHandler() != null)&lt;br/&gt;
+        {&lt;br/&gt;
+            exception = null;&lt;br/&gt;
+            getContentHandler().startDocument();&lt;br/&gt;
+            processKeys();&lt;br/&gt;
+            if(getException() != null)&lt;br/&gt;
+            {
+                throw getException();
+            }  /* if */&lt;br/&gt;
+            getContentHandler().endDocument();&lt;br/&gt;
+        }  /* if */&lt;br/&gt;
+    }&lt;br/&gt;
+    &lt;br/&gt;
+    /**&lt;br/&gt;
+     * Returns a reference to the configuration that is parsed by this object.&lt;br/&gt;
+     * @return the parsed configuration&lt;br/&gt;
+     */&lt;br/&gt;
+    public abstract Configuration getParsedConfiguration();&lt;br/&gt;
+    &lt;br/&gt;
+    /**&lt;br/&gt;
+     * Processes all keys stored in the actual configuration. This method is&lt;br/&gt;
+     * called by &amp;lt;code&amp;gt;parseConfiguration()&amp;lt;/code&amp;gt; to start the main parsing&lt;br/&gt;
+     * process. &amp;lt;code&amp;gt;parseConfiguration()&amp;lt;/code&amp;gt; calls the content handler&apos;s&lt;br/&gt;
+     * &amp;lt;code&amp;gt;startDocument()&amp;lt;/code&amp;gt; and &amp;lt;code&amp;gt;endElement()&amp;lt;/code&amp;gt; methods&lt;br/&gt;
+     * and cares for exception handling. The remaining actions are left to this&lt;br/&gt;
+     * method that must be implemented in a concrete sub class.&lt;br/&gt;
+     * @throws IOException if an IO error occurs&lt;br/&gt;
+     * @throws SAXException if a SAX error occurs &lt;br/&gt;
+     */&lt;br/&gt;
+    protected abstract void processKeys()&lt;br/&gt;
+    throws IOException, SAXException;&lt;br/&gt;
+}&lt;br/&gt;
Index: src/java/org/apache/commons/configuration/HierarchicalConfiguration.java&lt;br/&gt;
===================================================================&lt;br/&gt;
RCS file: src/java/org/apache/commons/configuration/HierarchicalConfiguration.java&lt;br/&gt;
diff -N src/java/org/apache/commons/configuration/HierarchicalConfiguration.java&lt;br/&gt;
&amp;#8212; /dev/null	1 Jan 1970 00:00:00 -0000&lt;br/&gt;
+++ src/java/org/apache/commons/configuration/HierarchicalConfiguration.java	30&lt;br/&gt;
Oct 2003 17:27:26 -0000&lt;br/&gt;
@@ -0,0 +1,1032 @@&lt;br/&gt;
+package org.apache.commons.configuration;&lt;br/&gt;
+&lt;br/&gt;
+/* ====================================================================&lt;br/&gt;
+ * The Apache Software License, Version 1.1&lt;br/&gt;
+ *&lt;br/&gt;
+ * Copyright (c) 1999-2002 The Apache Software Foundation.  All rights&lt;br/&gt;
+ * reserved.&lt;br/&gt;
+ *&lt;br/&gt;
+ * Redistribution and use in source and binary forms, with or without&lt;br/&gt;
+ * modification, are permitted provided that the following conditions&lt;br/&gt;
+ * are met:&lt;br/&gt;
+ *&lt;br/&gt;
+ * 1. Redistributions of source code must retain the above copyright&lt;br/&gt;
+ *    notice, this list of conditions and the following disclaimer.&lt;br/&gt;
+ *&lt;br/&gt;
+ * 2. Redistributions in binary form must reproduce the above copyright&lt;br/&gt;
+ *    notice, this list of conditions and the following disclaimer in&lt;br/&gt;
+ *    the documentation and/or other materials provided with the&lt;br/&gt;
+ *    distribution.&lt;br/&gt;
+ *&lt;br/&gt;
+ * 3. The end-user documentation included with the redistribution, if&lt;br/&gt;
+ *    any, must include the following acknowledgement:&lt;br/&gt;
+ *       &quot;This product includes software developed by the&lt;br/&gt;
+ *        Apache Software Foundation (&lt;a href=&quot;http://www.apache.org/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.apache.org/&lt;/a&gt;).&quot;&lt;br/&gt;
+ *    Alternately, this acknowledgement may appear in the software itself,&lt;br/&gt;
+ *    if and wherever such third-party acknowledgements normally appear.&lt;br/&gt;
+ *&lt;br/&gt;
+ * 4. The names &quot;The Jakarta Project&quot;, &quot;Commons&quot;, and &quot;Apache Software&lt;br/&gt;
+ *    Foundation&quot; must not be used to endorse or promote products derived&lt;br/&gt;
+ *    from this software without prior written permission. For written&lt;br/&gt;
+ *    permission, please contact apache@apache.org.&lt;br/&gt;
+ *&lt;br/&gt;
+ * 5. Products derived from this software may not be called &quot;Apache&quot;&lt;br/&gt;
+ *    nor may &quot;Apache&quot; appear in their names without prior written&lt;br/&gt;
+ *    permission of the Apache Software Foundation.&lt;br/&gt;
+ *&lt;br/&gt;
+ * THIS SOFTWARE IS PROVIDED ``AS IS&apos;&apos; AND ANY EXPRESSED OR IMPLIED&lt;br/&gt;
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES&lt;br/&gt;
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE&lt;br/&gt;
+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR&lt;br/&gt;
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,&lt;br/&gt;
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT&lt;br/&gt;
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF&lt;br/&gt;
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND&lt;br/&gt;
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,&lt;br/&gt;
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT&lt;br/&gt;
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF&lt;br/&gt;
+ * SUCH DAMAGE.&lt;br/&gt;
+ * ====================================================================&lt;br/&gt;
+ *&lt;br/&gt;
+ * This software consists of voluntary contributions made by many&lt;br/&gt;
+ * individuals on behalf of the Apache Software Foundation.  For more&lt;br/&gt;
+ * information on the Apache Software Foundation, please see&lt;br/&gt;
+ * &amp;lt;&lt;a href=&quot;http://www.apache.org/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.apache.org/&lt;/a&gt;&amp;gt;.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+import java.io.Serializable;&lt;br/&gt;
+import java.util.ArrayList;&lt;br/&gt;
+import java.util.Collection;&lt;br/&gt;
+import java.util.HashSet;&lt;br/&gt;
+import java.util.Iterator;&lt;br/&gt;
+import java.util.LinkedList;&lt;br/&gt;
+import java.util.List;&lt;br/&gt;
+import java.util.Map;&lt;br/&gt;
+import java.util.Set;&lt;br/&gt;
+import java.util.Stack;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.commons.collections.SequencedHashMap;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * &amp;lt;p&amp;gt;A specialized configuration class that extends its base class by the&lt;br/&gt;
+ * ability of keeping more structure in the stored properties.&amp;lt;/p&amp;gt;&lt;br/&gt;
+ * &amp;lt;p&amp;gt;There are some sources of configuration data that cannot be stored&lt;br/&gt;
+ * very well in a &amp;lt;code&amp;gt;BaseConfiguration&amp;lt;/code&amp;gt; object because then their&lt;br/&gt;
+ * structure is lost. This is especially true for XML documents. This class&lt;br/&gt;
+ * can deal with such structured configuration sources by storing the&lt;br/&gt;
+ * properties in a tree-like organization.&amp;lt;/p&amp;gt;&lt;br/&gt;
+ * &amp;lt;p&amp;gt;The internal used storage form allows for a more sophisticated access to&lt;br/&gt;
+ * single properties. As an example consider the following XML document:&amp;lt;/p&amp;gt;&lt;br/&gt;
+ * &amp;lt;p&amp;gt;&amp;lt;pre&amp;gt;&lt;br/&gt;
+ * &amp;lt;database&amp;gt;&lt;br/&gt;
+ *   &amp;lt;tables&amp;gt;&lt;br/&gt;
+ *     &amp;lt;table&amp;gt;&lt;br/&gt;
+ *       &amp;lt;name&amp;gt;users&amp;lt;/name&amp;gt;&lt;br/&gt;
+ *       &amp;lt;fields&amp;gt;&lt;br/&gt;
+ *         &amp;lt;field&amp;gt;&lt;br/&gt;
+ *           &amp;lt;name&amp;gt;lid&amp;lt;/name&amp;gt;&lt;br/&gt;
+ *           &amp;lt;type&amp;gt;long&amp;lt;/name&amp;gt;&lt;br/&gt;
+ *         &amp;lt;/field&amp;gt;&lt;br/&gt;
+ *         &amp;lt;field&amp;gt;&lt;br/&gt;
+ *           &amp;lt;name&amp;gt;usrName&amp;lt;/name&amp;gt;&lt;br/&gt;
+ *           &amp;lt;type&amp;gt;java.lang.String&amp;lt;/type&amp;gt;&lt;br/&gt;
+ *         &amp;lt;/field&amp;gt;&lt;br/&gt;
+ *        ...&lt;br/&gt;
+ *       &amp;lt;/fields&amp;gt;&lt;br/&gt;
+ *     &amp;lt;/table&amp;gt;&lt;br/&gt;
+ *     &amp;lt;table&amp;gt;&lt;br/&gt;
+ *       &amp;lt;name&amp;gt;documents&amp;lt;/name&amp;gt;&lt;br/&gt;
+ *       &amp;lt;fields&amp;gt;&lt;br/&gt;
+ *         &amp;lt;field&amp;gt;&lt;br/&gt;
+ *           &amp;lt;name&amp;gt;docid&amp;lt;/name&amp;gt;&lt;br/&gt;
+ *           &amp;lt;type&amp;gt;long&amp;lt;/type&amp;gt;&lt;br/&gt;
+ *         &amp;lt;/field&amp;gt;&lt;br/&gt;
+ *         ...&lt;br/&gt;
+ *       &amp;lt;/fields&amp;gt;&lt;br/&gt;
+ *     &amp;lt;/table&amp;gt;&lt;br/&gt;
+ *     ...&lt;br/&gt;
+ *   &amp;lt;/tables&amp;gt;&lt;br/&gt;
+ * &amp;lt;/database&amp;gt;&lt;br/&gt;
+ * &amp;lt;/pre&amp;gt;&amp;lt;/p&amp;gt;&lt;br/&gt;
+ * &amp;lt;p&amp;gt;If this document is parsed and stored in a&lt;br/&gt;
+ * &amp;lt;code&amp;gt;HierarchicalConfiguration&amp;lt;/code&amp;gt; object (which can be done by one of&lt;br/&gt;
+ * the sub classes), there are enhanced possibilities of accessing properties.&lt;br/&gt;
+ * The keys for querying information can contain indices that select a certain&lt;br/&gt;
+ * element if there are multiple hits.&amp;lt;/p&amp;gt;&lt;br/&gt;
+ * &amp;lt;p&amp;gt;For instance the key &amp;lt;code&amp;gt;tables.table(0).name&amp;lt;/code&amp;gt; can be used to&lt;br/&gt;
+ * find out the name of the first table. In opposite&lt;br/&gt;
+ * &amp;lt;code&amp;gt;tables.table.name&amp;lt;/code&amp;gt; would return a collection with the names of&lt;br/&gt;
+ * all available tables. Similarily the key&lt;br/&gt;
+ * &amp;lt;code&amp;gt;tables.table(1).fields.field.name&amp;lt;/code&amp;gt; returns a collection with the&lt;br/&gt;
+ * names of all fields of the second table. If another index is added after the&lt;br/&gt;
+ * &amp;lt;code&amp;gt;field&amp;lt;/code&amp;gt; element, a single field can be accessed:&lt;br/&gt;
+ * &amp;lt;code&amp;gt;tables.table(1).fields.field(0).name&amp;lt;/code&amp;gt;.&amp;lt;/p&amp;gt;&lt;br/&gt;
+ * &amp;lt;p&amp;gt;There is a &amp;lt;code&amp;gt;getMaxIndex()&amp;lt;/code&amp;gt; method that returns the maximum&lt;br/&gt;
+ * allowed index that can be added to a given property key. This method can be&lt;br/&gt;
+ * used to iterate over all values defined for a certain property.&amp;lt;/p&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * @author &amp;lt;a href=&quot;mailto:oliver.heger@t-online.de&quot;&amp;gt;Oliver Heger&amp;lt;/a&amp;gt;&lt;br/&gt;
+ * @version $Id: $&lt;br/&gt;
+ */&lt;br/&gt;
+public class HierarchicalConfiguration extends AbstractConfiguration&lt;br/&gt;
+{&lt;br/&gt;
+    /** Stores the root node of this configuration.*/&lt;br/&gt;
+    private Node root = new Node();&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Creates a new instance of &amp;lt;code&amp;gt;HierarchicalConfiguration&amp;lt;/code&amp;gt;.&lt;br/&gt;
+     */&lt;br/&gt;
+    public HierarchicalConfiguration()&lt;br/&gt;
+    {+        super();+    }
&lt;p&gt;+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Creates a new instance of &amp;lt;code&amp;gt;HierarchicalConfiguration&amp;lt;/code&amp;gt;&lt;br/&gt;
+     * and initializes it with default properties.&lt;br/&gt;
+     * @param defaults default properties to be used&lt;br/&gt;
+     */&lt;br/&gt;
+    public HierarchicalConfiguration(Configuration defaults)&lt;br/&gt;
+    &lt;/p&gt;
{
+        super(defaults);
+    }
&lt;p&gt;+    &lt;br/&gt;
+    /**&lt;br/&gt;
+     * Returns the root node of this hierarchical configuration.&lt;br/&gt;
+     * @return the root node&lt;br/&gt;
+     */&lt;br/&gt;
+    public Node getRoot()&lt;br/&gt;
+    &lt;/p&gt;
{
+        return root;
+    }
&lt;p&gt;+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Sets the root node of this hierarchical configuration.&lt;br/&gt;
+     * @param node the root node&lt;br/&gt;
+     */&lt;br/&gt;
+    public void setRoot(Node node)&lt;br/&gt;
+    {&lt;br/&gt;
+        if(node == null)&lt;br/&gt;
+        &lt;/p&gt;
{
+            throw new IllegalArgumentException(&quot;Root node must not be null!&quot;);
+        }
&lt;p&gt;  /* if */&lt;br/&gt;
+        root = node;&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Fetches the specified property. Performs a recursive lookup in the&lt;br/&gt;
+     * tree with the configuration properties.&lt;br/&gt;
+     * @param key the key to be looked up&lt;br/&gt;
+     * @return the found value&lt;br/&gt;
+     */&lt;br/&gt;
+    protected Object getPropertyDirect(String key)&lt;br/&gt;
+    {&lt;br/&gt;
+        List nodes = fetchNodeList(key);&lt;br/&gt;
+&lt;br/&gt;
+        if(nodes.size() == 0)&lt;br/&gt;
+        &lt;/p&gt;
{
+            return null;
+        }  /* if */&lt;br/&gt;
+        else&lt;br/&gt;
+        {&lt;br/&gt;
+            Container cont = new Container();&lt;br/&gt;
+            for(Iterator it = nodes.iterator(); it.hasNext()&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
+            {&lt;br/&gt;
+                Node nd = (Node) it.next();&lt;br/&gt;
+                if(nd.getValue() != null)&lt;br/&gt;
+                {
+                    cont.add(nd.getValue());
+                }  /* if */&lt;br/&gt;
+            }  /* for */&lt;br/&gt;
+            &lt;br/&gt;
+            if(cont.size() &amp;lt; 1)&lt;br/&gt;
+            {
+                return null;
+            }  /* if */&lt;br/&gt;
+            else&lt;br/&gt;
+            {
+                return (cont.size() == 1) ? cont.get(0) : cont;
+            }  /* else */&lt;br/&gt;
+        }  /* else */&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * &amp;lt;p&amp;gt;Adds the property with the specified key.&amp;lt;/p&amp;gt;&lt;br/&gt;
+     * &amp;lt;p&amp;gt;To be able to deal with the structure supported by this configuration&lt;br/&gt;
+     * implementation the passed in key is of importance, especially the&lt;br/&gt;
+     * indices it might contain. The following example should clearify this:&lt;br/&gt;
+     * Suppose the actual configuration contains the following elements:&amp;lt;/p&amp;gt;&lt;br/&gt;
+     * &amp;lt;p&amp;gt;&amp;lt;pre&amp;gt;&lt;br/&gt;
+     * tables&lt;br/&gt;
+     *    +-- table&lt;br/&gt;
+     *            +-- name = user&lt;br/&gt;
+     *            +-- fields&lt;br/&gt;
+     *                    +-- field&lt;br/&gt;
+     *                            +-- name = uid&lt;br/&gt;
+     *                    +-- field&lt;br/&gt;
+     *                            +-- name = firstName&lt;br/&gt;
+     *                    ...&lt;br/&gt;
+     *    +-- table&lt;br/&gt;
+     *            +-- name = documents&lt;br/&gt;
+     *            +-- fields&lt;br/&gt;
+     *                   ...&lt;br/&gt;
+     * &amp;lt;/pre&amp;gt;&amp;lt;/p&amp;gt;&lt;br/&gt;
+     * &amp;lt;p&amp;gt;In this example a database structure is defined, e.g. all fields of&lt;br/&gt;
+     * the first table could be accessed using the key&lt;br/&gt;
+     * &amp;lt;code&amp;gt;tables.table(0).fields.field.name&amp;lt;/code&amp;gt;. If now properties are&lt;br/&gt;
+     * to be added, it must be exactly specified at which position in the&lt;br/&gt;
+     * hierarchy the new property is to be inserted. So to add a new field name&lt;br/&gt;
+     * to a table it is not enough to say just&amp;lt;/p&amp;gt;&lt;br/&gt;
+     * &amp;lt;p&amp;gt;&amp;lt;pre&amp;gt;&lt;br/&gt;
+     * config.addProperty(&quot;tables.table.fields.field.name&quot;, &quot;newField&quot;);&lt;br/&gt;
+     * &amp;lt;/pre&amp;gt;&amp;lt;/p&amp;gt;&lt;br/&gt;
+     * &amp;lt;p&amp;gt;The statement given above contains some ambiguity. For instance&lt;br/&gt;
+     * it is not clear, to which table the new field should be added. If this&lt;br/&gt;
+     * method finds such an ambiguity, it is resolved by following the last&lt;br/&gt;
+     * valid path. Here this would be the last table. The same is true for the&lt;br/&gt;
+     * &amp;lt;code&amp;gt;field&amp;lt;/code&amp;gt;; because there are multiple fields and no explicit&lt;br/&gt;
+     * index is provided, a new &amp;lt;code&amp;gt;name&amp;lt;/code&amp;gt; property would be&lt;br/&gt;
+     * added to the last field - which is propably not what was desired.&amp;lt;/p&amp;gt;&lt;br/&gt;
+     * &amp;lt;p&amp;gt;To make things clear explicit indices should be provided whenever&lt;br/&gt;
+     * possible. In the example above the exact table could be specified by&lt;br/&gt;
+     * providing an index for the &amp;lt;code&amp;gt;table&amp;lt;/code&amp;gt; element as in&lt;br/&gt;
+     * &amp;lt;code&amp;gt;tables.table(1).fields&amp;lt;/code&amp;gt;. By specifying an index it can also&lt;br/&gt;
+     * be expressed that at a given position in the configuration tree a new&lt;br/&gt;
+     * branch should be added. In the example above we did not want to add&lt;br/&gt;
+     * an additional &amp;lt;code&amp;gt;name&amp;lt;/code&amp;gt; element to the last field of the table,&lt;br/&gt;
+     * but we want a complete new &amp;lt;code&amp;gt;field&amp;lt;/code&amp;gt; element. This can be&lt;br/&gt;
+     * achieved by specifying an invalid index (like -1) after the element&lt;br/&gt;
+     * where a new branch should be created. Given this our example would run:&lt;br/&gt;
+     * &amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;&amp;lt;pre&amp;gt;&lt;br/&gt;
+     * config.addProperty(&quot;tables.table(1).fields.field(-1).name&quot;, &quot;newField&quot;);&lt;br/&gt;
+     * &amp;lt;/pre&amp;gt;&amp;lt;/p&amp;gt;&lt;br/&gt;
+     * &amp;lt;p&amp;gt;With this notation it is possible to add new branches everywhere.&lt;br/&gt;
+     * We could for instance create a new &amp;lt;code&amp;gt;table&amp;lt;/code&amp;gt; element by&lt;br/&gt;
+     * specifying&amp;lt;/p&amp;gt;&lt;br/&gt;
+     * &amp;lt;p&amp;gt;&amp;lt;pre&amp;gt;&lt;br/&gt;
+     * config.addProperty(&quot;tables.table(-1).fields.field.name&quot;, &quot;newField2&quot;);&lt;br/&gt;
+     * &amp;lt;/pre&amp;gt;&amp;lt;/p&amp;gt;&lt;br/&gt;
+     * &amp;lt;p&amp;gt;(Note that because after the &amp;lt;code&amp;gt;table&amp;lt;/code&amp;gt; element a new&lt;br/&gt;
+     * branch is created indices in following elements are not relevant; the&lt;br/&gt;
+     * branch is new so there cannot be any ambiguities.)&amp;lt;/p&amp;gt;&lt;br/&gt;
+     * @param key the key of the new property&lt;br/&gt;
+     * @param obj the value of the new property&lt;br/&gt;
+     */&lt;br/&gt;
+    protected void addPropertyDirect(String key, Object obj)&lt;br/&gt;
+    {&lt;br/&gt;
+        ConfigurationKey ckey = new ConfigurationKey(key);&lt;br/&gt;
+        ConfigurationKey.KeyIterator it = ckey.iterator();&lt;br/&gt;
+        if(!it.hasNext())&lt;br/&gt;
+        {
+            throw new IllegalArgumentException(&quot;Key must be defined!&quot;);
+        }  /* if */&lt;br/&gt;
+&lt;br/&gt;
+        Node parent = createAddPath(it, findNodeToAdd(it, getRoot()));&lt;br/&gt;
+        Node child = new Node(it.currentKey(true));&lt;br/&gt;
+        child.setValue(obj);&lt;br/&gt;
+        parent.addChild(child);&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Checks if this configuration is empty. Empty means that there are&lt;br/&gt;
+     * no keys with any values, though there can be some (empty) nodes.&lt;br/&gt;
+     * @return a flag if this configuration is empty&lt;br/&gt;
+     */&lt;br/&gt;
+    public boolean isEmpty()&lt;br/&gt;
+    {
+        return !nodeDefined(getRoot());
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Checks if the specified key is contained in this configuration.&lt;br/&gt;
+     * Note that for this configuration the term &amp;quot;contained&amp;quot; means&lt;br/&gt;
+     * that the key has an associated value. If there is a node for this key&lt;br/&gt;
+     * that has no value but children (either defined or undefined), this&lt;br/&gt;
+     * method will still return &amp;lt;b&amp;gt;false&amp;lt;/b&amp;gt;.&lt;br/&gt;
+     * @param key the key to be chekced&lt;br/&gt;
+     * @return a flag if this key is contained in this configuration&lt;br/&gt;
+     */&lt;br/&gt;
+    public boolean containsKey(String key)&lt;br/&gt;
+    {
+        return getPropertyDirect(key) != null;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Removes all values of the property with the given name.&lt;br/&gt;
+     * @param key the key of the property to be removed&lt;br/&gt;
+     */&lt;br/&gt;
+    public void clearProperty(String key)&lt;br/&gt;
+    {&lt;br/&gt;
+        List nodes = fetchNodeList(key);&lt;br/&gt;
+&lt;br/&gt;
+        for(Iterator it = nodes.iterator(); it.hasNext()&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
+        {
+            removeNode((Node) it.next());
+        }  /* for */&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * &amp;lt;p&amp;gt;Returns an iterator with all keys defined in this configuration.&amp;lt;/p&amp;gt;&lt;br/&gt;
+     * &amp;lt;p&amp;gt;Note that the keys returned by this method will not contain&lt;br/&gt;
+     * any indices. This means that some structure will be lost.&amp;lt;/p&amp;gt;&lt;br/&gt;
+     * @return an iterator with the defined keys in this configuration&lt;br/&gt;
+     */&lt;br/&gt;
+    public Iterator getKeys()&lt;br/&gt;
+    {
+        DefinedKeysVisitor visitor = new DefinedKeysVisitor();
+        getRoot().visit(visitor, new ConfigurationKey());
+        return visitor.getKeyList().iterator();
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Creates a new &amp;lt;code&amp;gt;Configuration&amp;lt;/code&amp;gt; object containing all keys&lt;br/&gt;
+     * that start with the specified prefix. This implementation will return&lt;br/&gt;
+     * a &amp;lt;code&amp;gt;HierarchicalConfiguration&amp;lt;/code&amp;gt; object so that the structure&lt;br/&gt;
+     * of the keys will be saved.&lt;br/&gt;
+     * @param prefix the prefix of the keys for the subset&lt;br/&gt;
+     * @return a new configuration object representing the selected subset&lt;br/&gt;
+     */&lt;br/&gt;
+    public Configuration subset(String prefix)&lt;br/&gt;
+    {&lt;br/&gt;
+        Collection nodes = fetchNodeList(prefix);&lt;br/&gt;
+        if(nodes.isEmpty())&lt;br/&gt;
+        {+            return null;+        }
&lt;p&gt;  /* if */&lt;br/&gt;
+&lt;br/&gt;
+        HierarchicalConfiguration result = new HierarchicalConfiguration();&lt;br/&gt;
+        CloneVisitor visitor = new CloneVisitor();&lt;br/&gt;
+&lt;br/&gt;
+        for(Iterator it = nodes.iterator(); it.hasNext()&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
+        {&lt;br/&gt;
+            Node nd = (Node) it.next();&lt;br/&gt;
+            nd.visit(visitor, null);&lt;br/&gt;
+&lt;br/&gt;
+            Container children = visitor.getClone().getChildren();&lt;br/&gt;
+            if(children.size() &amp;gt; 0)&lt;br/&gt;
+            {&lt;br/&gt;
+                for(int i = 0; i &amp;lt; children.size(); i++)&lt;br/&gt;
+                &lt;/p&gt;
{
+                    result.getRoot().addChild((Node) children.get(i));
+                }
&lt;p&gt;  /* for */&lt;br/&gt;
+            }  /* if */&lt;br/&gt;
+            else&lt;br/&gt;
+            &lt;/p&gt;
{
+                // In this case we cannot shorten the key because only
+                // values are found without further child nodes.
+                result.getRoot().addChild(visitor.getClone());
+            }
&lt;p&gt;  /* else */&lt;br/&gt;
+        }  /* for */&lt;br/&gt;
+&lt;br/&gt;
+        return (result.isEmpty()) ? null : result;&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Returns the maximum defined index for the given key. This is&lt;br/&gt;
+     * useful if there are multiple values for this key. They can then be&lt;br/&gt;
+     * addressed separately by specifying indices from 0 to the return value&lt;br/&gt;
+     * of this method.&lt;br/&gt;
+     * @param key the key to be checked&lt;br/&gt;
+     * @return the maximum defined index for this key&lt;br/&gt;
+     */&lt;br/&gt;
+    public int getMaxIndex(String key)&lt;br/&gt;
+    &lt;/p&gt;
{
+        return fetchNodeList(key).size() - 1;
+    }
&lt;p&gt;+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Helper method for fetching a list of all nodes that are addressed by&lt;br/&gt;
+     * the specified key.&lt;br/&gt;
+     * @param key the key&lt;br/&gt;
+     * @return a list with all affected nodes (never &amp;lt;b&amp;gt;null&amp;lt;/b&amp;gt;)&lt;br/&gt;
+     */&lt;br/&gt;
+    protected List fetchNodeList(String key)&lt;br/&gt;
+    &lt;/p&gt;
{
+        List nodes = new LinkedList();
+        findPropertyNodes(new ConfigurationKey(key).iterator(),
+        getRoot(), nodes);
+        return nodes;
+    }
&lt;p&gt;+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Recursive helper method for fetching a property. This method&lt;br/&gt;
+     * processes all facets of a configuration key, traverses the tree of&lt;br/&gt;
+     * properties and fetches the the nodes of all matching properties.&lt;br/&gt;
+     * @param keyPart the configuration key iterator&lt;br/&gt;
+     * @param node the actual node&lt;br/&gt;
+     * @param data here the found nodes are stored&lt;br/&gt;
+     */&lt;br/&gt;
+    protected void findPropertyNodes(ConfigurationKey.KeyIterator keyPart,&lt;br/&gt;
+    Node node, Collection data)&lt;br/&gt;
+    {&lt;br/&gt;
+        if(!keyPart.hasNext())&lt;br/&gt;
+        &lt;/p&gt;
{
+            data.add(node);
+        }
&lt;p&gt;  /* if */&lt;br/&gt;
+&lt;br/&gt;
+        else&lt;br/&gt;
+        {&lt;br/&gt;
+            String key = keyPart.nextKey(true);&lt;br/&gt;
+            Container children = node.getChildren(key);&lt;br/&gt;
+            if(keyPart.hasIndex())&lt;br/&gt;
+            {&lt;br/&gt;
+                if(keyPart.getIndex() &amp;lt; children.size()&lt;br/&gt;
+                &amp;amp;&amp;amp; keyPart.getIndex() &amp;gt;= 0)&lt;br/&gt;
+                &lt;/p&gt;
{
+                    findPropertyNodes(
+                    (ConfigurationKey.KeyIterator) keyPart.clone(),
+                    (Node) children.get(keyPart.getIndex()), data);
+                }
&lt;p&gt;  /* if */&lt;br/&gt;
+            }  /* if */&lt;br/&gt;
+&lt;br/&gt;
+            else&lt;br/&gt;
+            {&lt;br/&gt;
+                for(Iterator it = children.iterator(); it.hasNext()&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
+                &lt;/p&gt;
{
+                    findPropertyNodes(
+                    (ConfigurationKey.KeyIterator) keyPart.clone(),
+                    (Node) it.next(), data);
+                }
&lt;p&gt;  /* for */&lt;br/&gt;
+            }  /* else */&lt;br/&gt;
+        }&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Checks if the specified node is defined.&lt;br/&gt;
+     * @param node the node to be checked&lt;br/&gt;
+     * @return a flag if this node is defined&lt;br/&gt;
+     */&lt;br/&gt;
+    protected boolean nodeDefined(Node node)&lt;br/&gt;
+    &lt;/p&gt;
{
+        DefinedVisitor visitor = new DefinedVisitor();
+        node.visit(visitor, null);
+        return visitor.isDefined();
+    }
&lt;p&gt;+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Removes the specified node from this configuration. This method&lt;br/&gt;
+     * ensures that parent nodes that become undefined by this operation&lt;br/&gt;
+     * are also removed.&lt;br/&gt;
+     * @param node the node to be removed&lt;br/&gt;
+     */&lt;br/&gt;
+    protected void removeNode(Node node)&lt;br/&gt;
+    {&lt;br/&gt;
+        Node parent = node.getParent();&lt;br/&gt;
+        if(parent != null)&lt;br/&gt;
+        {&lt;br/&gt;
+            parent.remove(node);&lt;br/&gt;
+            if(!nodeDefined(parent))&lt;br/&gt;
+            &lt;/p&gt;
{
+                removeNode(parent);
+            }
&lt;p&gt;  /* if */&lt;br/&gt;
+        }  /* if */&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Finds the last existing node for an add operation. This method&lt;br/&gt;
+     * traverses the configuration tree along the specified key. The last&lt;br/&gt;
+     * existing node on this path is returned.&lt;br/&gt;
+     * @param keyIt the key iterator&lt;br/&gt;
+     * @param node the actual node&lt;br/&gt;
+     * @return the last existing node on the given path&lt;br/&gt;
+     */&lt;br/&gt;
+    protected Node findNodeToAdd(ConfigurationKey.KeyIterator keyIt,&lt;br/&gt;
+    Node node)&lt;br/&gt;
+    {&lt;br/&gt;
+        String keyPart = keyIt.nextKey(true);&lt;br/&gt;
+&lt;br/&gt;
+        if(keyIt.hasNext())&lt;br/&gt;
+        {&lt;br/&gt;
+            Container c = node.getChildren(keyPart);&lt;br/&gt;
+            int idx = (keyIt.hasIndex()) ? keyIt.getIndex() : c.size() - 1;&lt;br/&gt;
+            if(idx &amp;lt; 0 || idx &amp;gt;= c.size())&lt;br/&gt;
+            &lt;/p&gt;
{
+                return node;
+            }
&lt;p&gt;  /* if */&lt;br/&gt;
+            else&lt;br/&gt;
+            &lt;/p&gt;
{
+                return findNodeToAdd(keyIt, (Node) c.get(idx));
+            }
&lt;p&gt;  /* else */&lt;br/&gt;
+        }  /* if */&lt;br/&gt;
+&lt;br/&gt;
+        else&lt;br/&gt;
+        &lt;/p&gt;
{
+            return node;
+        }
&lt;p&gt;  /* else */&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Creates the missing nodes for adding a new property. This method&lt;br/&gt;
+     * ensures that there are corresponding nodes for all components of the&lt;br/&gt;
+     * specified configuration key.&lt;br/&gt;
+     * @param keyIt the key iterator&lt;br/&gt;
+     * @param root the base node of the path to be created&lt;br/&gt;
+     * @return the last node of the path&lt;br/&gt;
+     */&lt;br/&gt;
+    protected Node createAddPath(ConfigurationKey.KeyIterator keyIt,&lt;br/&gt;
+    Node root)&lt;br/&gt;
+    {&lt;br/&gt;
+        if(keyIt.hasNext())&lt;br/&gt;
+        &lt;/p&gt;
{
+            Node child = new Node(keyIt.currentKey(true));
+            root.addChild(child);
+            keyIt.next();
+            return createAddPath(keyIt, child);
+        }
&lt;p&gt;  /* if */&lt;br/&gt;
+        else&lt;br/&gt;
+        &lt;/p&gt;
{
+            return root;
+        }
&lt;p&gt;  /* else */&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Helper method for adding all elements of a collection to a&lt;br/&gt;
+     * container.&lt;br/&gt;
+     * @param cont the container&lt;br/&gt;
+     * @param items the collection to be added&lt;br/&gt;
+     */&lt;br/&gt;
+    private static void addContainer(Container cont, Collection items)&lt;br/&gt;
+    {&lt;br/&gt;
+        for(Iterator it = items.iterator(); it.hasNext()&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
+        &lt;/p&gt;
{
+            cont.add(it.next());
+        }
&lt;p&gt;  /* for */&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * A data class for storing (hierarchical) property information. A property&lt;br/&gt;
+     * can have a value and an arbitrary number of child properties.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @author &amp;lt;a href=&quot;mailto:oliver.heger@t-online.de&quot;&amp;gt;Oliver Heger&amp;lt;/a&amp;gt;&lt;br/&gt;
+     */&lt;br/&gt;
+    public static class Node implements Serializable, Cloneable&lt;br/&gt;
+    {&lt;br/&gt;
+        /** Stores a reference to this node&apos;s parent.*/&lt;br/&gt;
+        private Node parent;&lt;br/&gt;
+&lt;br/&gt;
+        /** Stores the name of this node.*/&lt;br/&gt;
+        private String name;&lt;br/&gt;
+&lt;br/&gt;
+        /** Stores the value of this node.*/&lt;br/&gt;
+        private Object value;&lt;br/&gt;
+&lt;br/&gt;
+        /** Stores the children of this node.*/&lt;br/&gt;
+        private Map children;&lt;br/&gt;
+&lt;br/&gt;
+        /**&lt;br/&gt;
+         * Creates a new instance of &amp;lt;code&amp;gt;Node&amp;lt;/code&amp;gt;.&lt;br/&gt;
+         */&lt;br/&gt;
+        public Node()&lt;br/&gt;
+        &lt;/p&gt;
{
+            this(null);
+        }
&lt;p&gt;+&lt;br/&gt;
+        /**&lt;br/&gt;
+         * Creates a new instance of &amp;lt;code&amp;gt;Node&amp;lt;/code&amp;gt; and sets the name.&lt;br/&gt;
+         * @param name the node&apos;s name&lt;br/&gt;
+         */&lt;br/&gt;
+        public Node(String name)&lt;br/&gt;
+        &lt;/p&gt;
{
+            setName(name);
+        }
&lt;p&gt;+&lt;br/&gt;
+        /**&lt;br/&gt;
+         * Returns the name of this node.&lt;br/&gt;
+         * @return the node name&lt;br/&gt;
+         */&lt;br/&gt;
+        public String getName()&lt;br/&gt;
+        &lt;/p&gt;
{
+            return name;
+        }
&lt;p&gt;+&lt;br/&gt;
+        /**&lt;br/&gt;
+         * Returns the value of this node.&lt;br/&gt;
+         * @return the node value (may be &amp;lt;b&amp;gt;null&amp;lt;/b&amp;gt;)&lt;br/&gt;
+         */&lt;br/&gt;
+        public Object getValue()&lt;br/&gt;
+        &lt;/p&gt;
{
+            return value;
+        }
&lt;p&gt;+&lt;br/&gt;
+        /**&lt;br/&gt;
+         * Returns the parent of this node.&lt;br/&gt;
+         * @return this node&apos;s parent (can be &amp;lt;b&amp;gt;null&amp;lt;/b&amp;gt;)&lt;br/&gt;
+         */&lt;br/&gt;
+        public Node getParent()&lt;br/&gt;
+        &lt;/p&gt;
{
+            return parent;
+        }</description>
                <environment>&lt;p&gt;Operating System: other&lt;br/&gt;
Platform: Other&lt;/p&gt;</environment>
        <key id="12341064">CONFIGURATION-152</key>
            <summary>[configuration][PATCH]HierarchicalConfiguration and XMLReader</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="3">Duplicate</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="oliver.heger@t-online.de">Oliver Heger</reporter>
                        <labels>
                    </labels>
                <created>Fri, 31 Oct 2003 01:39:08 +0000</created>
                <updated>Tue, 16 May 2006 11:24:15 +0000</updated>
                            <resolved>Tue, 16 May 2006 11:24:15 +0000</resolved>
                                                                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12405365" author="oliver.heger@t-online.de" created="Sat, 15 Nov 2003 02:45:48 +0000"  >&lt;p&gt;Becomes obsolete by &lt;a href=&quot;https://issues.apache.org/jira/browse/CONFIGURATION-158&quot; title=&quot;[configuration][PATCH]Load from URLs and union configuration&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CONFIGURATION-158&quot;&gt;&lt;del&gt;COM-925&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;
	&lt;ul&gt;
		&lt;li&gt;
		&lt;ul&gt;
			&lt;li&gt;This bug has been marked as a duplicate of 24472 ***&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_10010" key="com.atlassian.jira.plugin.system.customfieldtypes:importid">
                        <customfieldname>Bugzilla Id</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>24262</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>110722</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            13 years, 5 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0then:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>170129</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>