<?xml version = "1.0" encoding = "UTF-8" ?>
<bugrepository name="SEC">
	<bug id="2096" opendate="2012-12-13 06:37:32" fixdate="2012-12-18 13:17:54" resolution="Fixed">
		<buginformation>
			<summary>Dependency on spring-*-SNAPSHOT</summary>
			<description>The 3.2 release&amp;amp;apos;s poms point to spring-*SNAPSHOT jars</description>
			<version>3.2.0.M1</version>
			<fixedVersion>3.2.0.M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.core.SpringSecurityCoreVersion.java</file>
		</fixedFiles>
	</bug>
	<bug id="2111" opendate="2013-01-02 07:32:35" fixdate="2013-01-28 11:56:27" resolution="Fixed">
		<buginformation>
			<summary>Disable auto save of SecurityContext when response committed after startAsync invoked</summary>
			<description>Updated Description
Previously Spring Security would disable automatically saving the SecurityContext when the Thread was different than the Thread that created the SaveContextOnUpdateOrErrorResponseWrapper. This worked for many cases, but could cause issues when a timeout occurred. The problem is that a Thread can be reused to process the timeout since the Threads are pooled. This means that a timeout of a request trigger an apparent logout as described in the following workflow:

The SecurityContext was established on the SecurityContextHolder
An Async request was made
The SecurityContextHolder would be cleared out
The Async request times out
The Async request would be dispatched back to the container upon
        timing out. If the container reused the same Thread to process the
        timeout as the original request, Spring Security would attempt to
        save the SecurityContext when the response was committed. Since the
        SecurityContextHolder was still cleared out it removes the
        SecurityContext from the HttpSession

Spring Security should prevent the SecurityContext from automatically being saved when the response is committed as soon as ServletRequest#startAsync() or   ServletRequest#startAsync(ServletRequest,ServletResponse) is called as apposed to looking at the Thread equality.
Original Description
I still see the same behavior on DeferredResult controllers. (after some time there is an auto logout)
It doesn&amp;amp;apos;t always happen as it used to before 3.2.0.M1 .
Logs are just before logging out occurs and are related to an AJAX call to a deferredResult method.











Logs:




2013-01-01 16:20:08,019 DEBUG yContextPersistenceFilter:97 - SecurityContextHolder now cleared, as request processing completed




...




2013-01-01 16:21:32,649 DEBUG eToSessionResponseWrapper:140 - Skip saving SecurityContext since processing the HttpServletResponse on a different Thread than the original HttpServletRequest




...




2013-01-01 16:22:01,650 DEBUG SecurityContextRepository:269 - SecurityContext is empty or contents are anonymous - context will not be stored in HttpSession.




...




2013-01-01 16:22:03,660 DEBUG AntPathRequestMatcher :116 - Checking match of request : &amp;amp;apos;/deferred&amp;amp;apos;; against &amp;amp;apos;/resources/**&amp;amp;apos;




...




2013-01-01 16:22:03,661 DEBUG SecurityContextRepository:139 - HttpSession returned null object for SPRING_SECURITY_CONTEXT




2013-01-01 16:22:03,661 DEBUG SecurityContextRepository:85 - No SecurityContext was available from the HttpSession: org.apache.catalina.session.StandardSessionFacade@5b3cc94b. A new one will be created.




...




2013-01-01 16:22:03,664 DEBUG ymousAuthenticationFilter:102 - Populated SecurityContextHolder with anonymous token: &amp;amp;apos;org.springframework.security.authentication.AnonymousAuthenticationToken@90541710: Principal: anonymousUser; Credentials: [PROTECTED]; Authenticated: true; Details: org.springframework.security.web.authentication.WebAuthenticationDetails@166c8: RemoteIpAddress: 0:0:0:0:0:0:0:1; SessionId: 6D46ACB5AEA101C58A838529A3F6ED1D; Granted Authorities: ROLE_ANONYMOUS&amp;amp;apos;




...




2013-01-01 16:22:03,667 DEBUG FilterSecurityInterceptor:310 - Previously Authenticated: org.springframework.security.authentication.AnonymousAuthenticationToken@90541710: Principal: anonymousUser; Credentials: [PROTECTED]; Authenticated: true; Details: org.springframework.security.web.authentication.WebAuthenticationDetails@166c8: RemoteIpAddress: 0:0:0:0:0:0:0:1; SessionId: 6D46ACB5AEA101C58A838529A3F6ED1D; Granted Authorities: ROLE_ANONYMOUS




...




2013-01-01 16:22:03,668 DEBUG AffirmativeBased :65 - Voter: org.springframework.security.web.access.expression.WebExpressionVoter@52d9eb97, returned: -1




...




2013-01-01 16:22:03,668 DEBUG xceptionTranslationFilter:165 - Access is denied (user is anonymous); redirecting to authentication entry point




org.springframework.security.access.AccessDeniedException: Access is denied





</description>
			<version>3.2.0.M1</version>
			<fixedVersion>3.2.0.M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.context.HttpSessionSecurityContextRepositoryTests.java</file>
			<file type="M">org.springframework.security.web.context.SaveContextOnUpdateOrErrorResponseWrapper.java</file>
			<file type="M">org.springframework.security.web.context.HttpSessionSecurityContextRepository.java</file>
			<file type="M">org.springframework.security.web.context.SaveContextOnUpdateOrErrorResponseWrapperTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">1998</link>
		</links>
	</bug>
	<bug id="2143" opendate="2013-03-05 05:00:19" fixdate="2013-03-06 09:01:57" resolution="Fixed">
		<buginformation>
			<summary>Error message still mentioning version 3.1</summary>
			<description>The error message in the SecurityNamespaceHandler.parse() method still mentions Spring Security Version 3.1 if an old xsd is used.</description>
			<version>3.2.0.M1</version>
			<fixedVersion>3.2.0.M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.SecurityNamespaceHandler.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">2145</link>
		</links>
	</bug>
	<bug id="2191" opendate="2013-07-02 10:30:53" fixdate="2013-07-05 11:11:30" resolution="Complete">
		<buginformation>
			<summary>AuthenticationManagerBuilder requires a ObjectPostProcessor</summary>
			<description>In order to function properly, AuthenticationManagerBuilder requires an ObjectPostProcessor other than QUIESCENT_POSTPROCESSOR. We should provide a way to make use of AuthenticationManagerBuilder easier.
For example instead of:






@Configuration




@EnableGlobalMethodSecurity(prePostEnabled=true)




public class SampleWebSecurityConfig {









  @Bean




  public AuthenticationManager authenticationManager() throws Exception {




    return new AuthenticationManagerBuilder()




        .inMemoryAuthentication()




          .withUser("user").password("password").roles("USER").and()




        .build();




  }




}






We should support:






@Configuration




@EnableGlobalMethodSecurity(prePostEnabled=true)




public class SampleWebSecurityConfig {









  @Autowired




  public void authenticationManager(AuthenticationManagerBuilder auth) throws Exception {




    auth




        .inMemoryAuthentication()




          .withUser("user").password("password").roles("USER");




  }




}





</description>
			<version>3.2.0.M2</version>
			<fixedVersion>3.2.0.RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.AbstractConfiguredSecurityBuilder.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configuration.EnableWebSecurity.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter.java</file>
			<file type="M">org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity.java</file>
			<file type="M">org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder.java</file>
			<file type="M">org.springframework.security.config.annotation.method.configuration.GlobalMethodSecurityConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="2215" opendate="2013-07-16 04:51:40" fixdate="2013-07-16 20:47:48" resolution="Fixed">
		<buginformation>
			<summary>Injecting AuthenticationManager to SecurityContextHolderAwareRequestFilter</summary>
			<description>I am trying to use servletApi() of Spring Security 3.2 M2 at my embedded Jetty 9.x application but could not be successful. AuthenticationManager seems null at SecurityContextHolderAwareRequestFilter. And because of this HttpServlet3RequestFactory is created with null authenticationManager. 
Here is the implementation of my Security Config:






@Configuration




@EnableWebSecurity




public class SecurityConfig extends WebSecurityConfigurerAdapter {














   @Override




   protected void registerAuthentication(AuthenticationManagerBuilder auth) throws Exception {




      auth




         .inMemoryAuthentication()




         .withUser("user").password("password").roles("USER")




         .and();




   }









   @Bean




   @Override




   public AuthenticationManager authenticationManagerBean()  throws Exception {




      return super.authenticationManagerBean();




   }














   @Override




   protected void configure(HttpSecurity http) throws Exception {




      http




//         .exceptionHandling().and()




         .sessionManagement()




            .sessionCreationPolicy(SessionCreationPolicy.ifRequired)




            .sessionRegistry(new StarSessionRegistry()).and().and()




         .securityContext().and()




//         .requestCache().and()




//         .anonymous().and()




         .servletApi().and()




//         .apply(new DefaultLoginPageConfigurer&amp;lt;HttpSecurity&amp;gt;()).and()




//         .logout()




//         .and()




         .authorizeUrls()




         .antMatchers("/login").permitAll()




         .antMatchers("/**").authenticated();




   }




}






As a workaround I have implemented a custom beanpostprocessor which is injecting an authenticationManager. 
I am very new to Spring Security but I have checked test cases and sample applications but could not find something useful. </description>
			<version>3.2.0.M2</version>
			<fixedVersion>3.2.0.RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.configurers.LogoutConfigurer.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configurers.ServletApiConfigurer.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configurers.ExceptionHandlingConfigurer.java</file>
		</fixedFiles>
	</bug>
	<bug id="2198" opendate="2013-07-10 06:14:37" fixdate="2013-07-19 14:36:12" resolution="Complete">
		<buginformation>
			<summary>http.httpBasic() does not properly default the AuthenticationEntryPoint</summary>
			<description>The following code should use BasicAuthenticationEntryPoint






@Override




protected void configure(HttpSecurity http) throws Exception {




    http




        .authorizeUrls()




            .anyRequest().authenticated()




            .and()




        .httpBasic();       




}






A workaround for now is:











@Bean




public BasicAuthenticationEntryPoint entryPoint() {




    BasicAuthenticationEntryPoint basicAuthEntryPoint = new BasicAuthenticationEntryPoint();




    basicAuthEntryPoint.setRealmName("My Realm");




    return basicAuthEntryPoint;




}









@Override




protected void configure(HttpSecurity http) throws Exception {









    http




        .exceptionHandling()




            .authenticationEntryPoint(entryPoint())




            .and()




        .authorizeUrls()




            .anyRequest().authenticated()




            .and()




        .httpBasic();       




}










</description>
			<version>3.2.0.M2</version>
			<fixedVersion>3.2.0.RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.configurers.HttpBasicConfigurer.java</file>
		</fixedFiles>
	</bug>
	<bug id="2222" opendate="2013-07-19 23:43:50" fixdate="2013-07-20 05:50:12" resolution="Fixed">
		<buginformation>
			<summary>Javadoc error - WebSecurityConfigurerAdapter.registerAuthentication &amp; EnableWebSecurity refer to wrong parameter</summary>
			<description>The example for WebSecurityConfigurerAdapter.registerAuthentication and EnableWebSecurity refer to &amp;amp;apos;registry&amp;amp;apos; rather than &amp;amp;apos;auth&amp;amp;apos;.</description>
			<version>3.2.0.M2</version>
			<fixedVersion>3.2.0.RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configuration.EnableWebSecurity.java</file>
		</fixedFiles>
	</bug>
	<bug id="2205" opendate="2013-07-15 13:16:31" fixdate="2013-07-22 14:39:54" resolution="Complete">
		<buginformation>
			<summary>Create UserDetailsServiceDelegator</summary>
			<description>Ordering issues can cause the UserDetailsService to be null. To resolve this, a UserDetailsServiceDelegator should be created. An example workaround can be found below:






@Configuration




@EnableWebSecurity




public class SecurityConfig extends WebSecurityConfigurerAdapter {




    private UserDetailsServiceDelegator userDetailsService = new UserDetailsServiceDelegator();









    @Bean




    @Override




    public UserDetailsService userDetailsServiceBean() throws Exception {




        return userDetailsService;




    }














    @Override




    protected void registerAuthentication(




            AuthenticationManagerBuilder auth) throws Exception {




        userDetailsService.setBuilder(auth);




        ...




    }




    




    static final class UserDetailsServiceDelegator implements UserDetailsService {




        private AuthenticationManagerBuilder delegateBuilder;




        private UserDetailsService delegate;




        private final Object delegateMonitor = new Object();









        private void setBuilder(AuthenticationManagerBuilder authentication) {




            this.delegateBuilder = authentication;




        }









        public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { 




            if(delegate != null) {




                return delegate.loadUserByUsername(username);




            }









            synchronized(delegateMonitor) {




                if (delegate == null) {




                    delegate = this.delegateBuilder.getDefaultUserDetailsService();




                    this.delegateBuilder = null;




                }




            }









            return delegate.loadUserByUsername(username);




        }




    }




}





</description>
			<version>3.2.0.M2</version>
			<fixedVersion>3.2.0.RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter.java</file>
		</fixedFiles>
	</bug>
	<bug id="2237" opendate="2013-07-30 07:13:08" fixdate="2013-07-30 07:26:22" resolution="Duplicate">
		<buginformation>
			<summary>API documentation for FirewalledRequest.reset() incomplete</summary>
			<description>The API documentation of the method FirewalledRequest.reset is incomplete and ends immendiately before giving the most important piece of information:
Right now, the last setence reads like this:
"An implementation can thus choose to modify the state of the request for the security infrastructure, while still maintaining the [!]"
The important information is what is still maintained. This is missing right now.</description>
			<version>3.2.0.M2</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.firewall.FirewalledRequest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">2223</link>
		</links>
	</bug>
	<bug id="2280" opendate="2013-08-24 21:24:59" fixdate="2013-08-24 21:31:25" resolution="Complete">
		<buginformation>
			<summary>Fix SessionFixationConfigurer#changeSessionId Javadoc</summary>
			<description>The Javadoc for SessionFixationConfigurer#changeSessionId() was copied and pasted from SessionFixationConfigurer#none() and never updated. It is incorrect. This commit fixes that. It also adds a newline at the end of the file, which the file was missing, causing Git to complain.
Pull request https://github.com/SpringSource/spring-security/pull/42</description>
			<version>3.2.0.RC1</version>
			<fixedVersion>3.2.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.configurers.SessionManagementConfigurer.java</file>
		</fixedFiles>
	</bug>
	<bug id="2276" opendate="2013-08-22 06:47:55" fixdate="2013-08-24 21:32:23" resolution="Complete">
		<buginformation>
			<summary>Delay storing the CsrfToken until the CsrfToken is accessed</summary>
			<description>Rather than adding the CsrfToken to the HttpSession immediately, we can delay adding the CsrfToken until the token is accessed on the servlet request. This ensures that only a request that is just prior to CSRF will create the session.</description>
			<version>3.2.0.RC1</version>
			<fixedVersion>3.2.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.servlet.support.csrf.CsrfRequestDataValueProcessorTests.java</file>
			<file type="M">org.springframework.security.web.csrf.CsrfToken.java</file>
			<file type="D">org.springframework.security.web.csrf.CsrfTokenTests.java</file>
			<file type="M">org.springframework.security.web.csrf.CsrfTokenRepository.java</file>
			<file type="M">org.springframework.security.web.csrf.CsrfFilterTests.java</file>
			<file type="M">org.springframework.security.web.csrf.HttpSessionCsrfTokenRepository.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configurers.SessionManagementConfigurerServlet31Tests.java</file>
			<file type="M">org.springframework.security.web.csrf.HttpSessionCsrfTokenRepositoryTests.java</file>
			<file type="M">org.springframework.security.web.csrf.CsrfFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">2376</link>
		</links>
	</bug>
	<bug id="2272" opendate="2013-08-21 05:10:58" fixdate="2013-08-27 14:47:18" resolution="Fixed">
		<buginformation>
			<summary>CsrfRequestDataValueProcessor should support Spring 4.2.0M2+</summary>
			<description>RequestDataValueProcessor was changed non-passively in Spring 4.0.0.M2 so we should make changes to CsrfRequestDataValueProcessor to support both versions. See https://jira.springsource.org/browse/SPR-10041</description>
			<version>3.2.0.RC1</version>
			<fixedVersion>3.2.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.CsrfBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configuration.CsrfWebMvcConfiguration.java</file>
			<file type="M">org.springframework.security.web.servlet.support.csrf.CsrfRequestDataValueProcessorTests.java</file>
			<file type="M">org.springframework.security.web.servlet.support.csrf.CsrfRequestDataValueProcessor.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">10041</link>
		</links>
	</bug>
	<bug id="2296" opendate="2013-08-30 08:56:00" fixdate="2013-08-31 10:06:39" resolution="Fixed">
		<buginformation>
			<summary>HttpServletRequest.login should throw ServletException if already authenticated</summary>
			<description>http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#login%28java.lang.String,%20java.lang.String%29</description>
			<version>3.2.0.RC1</version>
			<fixedVersion>3.2.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.servletapi.HttpServlet3RequestFactory.java</file>
			<file type="M">org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilterTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="2301" opendate="2013-09-03 06:30:17" fixdate="2013-09-20 14:06:07" resolution="Complete">
		<buginformation>
			<summary>GlobalMethodSecurityConfiguration&amp;apos;s DefaultWebSecurityExpressionHandler has null BeanResolver</summary>
			<description>
this blog post got me started with java config, and everything worked fine until i tried to use @PreAuthorize annotation that uses my custom authentication service (via @myCustomService) expression. I get an error that
No bean resolver registered in the context to resolve access to bean myCustomService
Looking at M2 and RC1 source code, it seems that when WebSecurity is created in WebSecurityConfiguration and the default DefaultWebSecurityExpressionHandler is used and it has no BeanResolver set (from AbstractSecurityExpressionHandler).
Might this be a bug in the java based configuration?</description>
			<version>3.2.0.RC1</version>
			<fixedVersion>3.2.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.method.configuration.GlobalMethodSecurityConfiguration.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">2303</link>
		</links>
	</bug>
	<bug id="2304" opendate="2013-09-03 07:55:08" fixdate="2013-09-20 14:06:08" resolution="Complete">
		<buginformation>
			<summary>GlobalMethodSecurityConfiguration has two methods for the Expression Handler</summary>
			<description></description>
			<version>3.2.0.RC1</version>
			<fixedVersion>3.2.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.method.configuration.GlobalMethodSecurityConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="2328" opendate="2013-09-15 14:22:07" fixdate="2013-09-24 09:37:27" resolution="Complete">
		<buginformation>
			<summary>Java configuration missing hasAnyRole</summary>
			<description>Java configuration for restricting access to a URI has methods hasAuthority, hasAnyAuthority, and hasRole. It is missing hasAnyRole. This is not a big deal since you can work around it with hasAnyAuthority, but it&amp;amp;apos;s still not consistent with using string expressions in access or annotations.</description>
			<version>3.2.0.RC1</version>
			<fixedVersion>3.2.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.configurers.ExpressionUrlAuthorizationConfigurer.java</file>
		</fixedFiles>
	</bug>
	<bug id="2302" opendate="2013-09-03 06:46:16" fixdate="2013-09-25 15:32:34" resolution="Complete">
		<buginformation>
			<summary>Allow filters to register in front of SpringSecurityFilterChain</summary>
			<description>With an AbstractSecurityWebApplicationInitializer in place its imposible to register an other filter in front of SpringSecurityFilterChain.</description>
			<version>3.2.0.RC1</version>
			<fixedVersion>3.2.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.context.AbstractSecurityWebApplicationInitializer.java</file>
		</fixedFiles>
	</bug>
	<bug id="2336" opendate="2013-09-19 22:54:04" fixdate="2013-09-26 07:08:30" resolution="Complete">
		<buginformation>
			<summary>WebSecurityConfigurerAdapter#registerAuthentication incorrectly states exposed Beans</summary>
			<description>Updated
I was fooled by this java doc in WebSecurityConfigurerAdapter#registerAuthentication:
"The resulting
{@link AuthenticationManager}
will be exposed as a Bean as will the last populated 
{@link UserDetailsService}
that is created with the
{@link AuthenticationManagerBuilder}

Original
This issue links to SEC-2205, I have simple @Configuration like this:






SecurityConfig.java











@Configuration




@EnableWebSecurity




@EnableGlobalMethodSecurity(prePostEnabled = true)




public class SecurityConfig extends WebSecurityConfigurerAdapter {









    @Override




    public void configure(WebSecurity web) throws Exception {




        web




                .ignoring()




                .antMatchers("/resources/**", "/favicon.ico");




    }









    @Override




    protected void registerAuthentication(AuthenticationManagerBuilder auth) throws Exception {




        auth




                .inMemoryAuthentication()




                .withUser("user").password("password").roles("USER").and()




                .withUser("admin").password("password").roles("USER", "ADMIN");









    }









    @Bean




    @Override




    public AuthenticationManager authenticationManagerBean()




            throws Exception {




        return super.authenticationManagerBean();




    }









    @Override




    protected void configure(HttpSecurity http) throws Exception {




        http




                .authorizeRequests()




                .antMatchers("/admin**").hasRole("ADMIN")




                .anyRequest().authenticated()




                .and()




                .formLogin()




                .loginPage("/signin")




                .permitAll()




                .and()




                .logout()




                .logoutUrl("/signout");




    }









}






And then simple Junit test, which actually uses SecurityRequestPostProcessors approach from (SEC-2015), but here for demonstration puroposes I have only autowired UserDetailsService:






SecurityFilterTest.java






@RunWith(SpringJUnit4ClassRunner.class)




@WebAppConfiguration




@ContextConfiguration(classes = SecurityConfig.class)




public class SecurityFilterTest {









    @Autowired




    private FilterChainProxy springSecurityFilterChain;









    @Autowired




    private WebApplicationContext wac;









    private MockMvc mockMvc;









    @Autowired




    private UserDetailsService userDetailsService;









    @Before




    public void setup() {




        this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac)




                .addFilters(this.springSecurityFilterChain).build();




    }









    @Test




    public void requiresAuthentication() throws Exception {




        mockMvc.perform(get("/hello"))




                .andExpect(status().isMovedTemporarily())




                .andExpect(redirectedUrl("http://localhost/signin"));




    }




}






This results:






stacktrace






Caused by: org.springframework.beans.factory.BeanCreationException: Could not autowire field: private org.springframework.security.core.userdetails.UserDetailsService




....




SecurityFilterTest.userDetailsService; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [org.springframework.security.core.userdetails.UserDetailsService] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)}






</description>
			<version>3.2.0.RC1</version>
			<fixedVersion>3.2.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter.java</file>
		</fixedFiles>
	</bug>
	<bug id="2303" opendate="2013-09-03 07:53:51" fixdate="2013-10-06 15:35:06" resolution="Complete">
		<buginformation>
			<summary>WebSecurity&amp;apos;s default expression handler does not have the bean resolver set</summary>
			<description>Similar to SEC-2301</description>
			<version>3.2.0.RC1</version>
			<fixedVersion>3.2.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.builders.WebSecurity.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configurers.ExpressionUrlAuthorizationConfigurer.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">2301</link>
		</links>
	</bug>
	<bug id="2376" opendate="2013-10-23 16:47:58" fixdate="2013-10-24 10:51:19" resolution="Duplicate">
		<buginformation>
			<summary>Document/Fix CSRF behavior with pre-auth</summary>
			<description>3.2.0.RC1 with &amp;lt;http auto-config="true"&amp;gt;  with &amp;lt;csrf/&amp;gt; and a preauth filter
When a user first accesses a pre-authed site
1. the CSRF token is added to the session.
2. The pre-auth filter creates the Authentication and related security context
3. The SessionManagementFilter then runs, and since its a new auth and session it calls &amp;amp;apos;CsrfAuthenticationStrategy&amp;amp;apos; which removes the CSRF token from the session.
4. The return view now has an invalid CSRF token in any forms.
A 2nd GET creates a new CSRF token, and then everything works normally.
--------------------------------
I posted my workaround in the forum, but it would nice to:
1. Document the behavior/workaround in
http://docs.spring.io/spring-security/site/docs/3.2.x-SNAPSHOT/reference/html/csrf.html
so that others don&amp;amp;apos;t have the same issue.
2. Offer a better way (or workaround) to remove the CsrfAuthenticationStrategy from the session management.
Is defining my own custom CSRF filter and repository a "cleaner" workaround to defining my own session management filter?
Or is updating the xsd, and doing something like &amp;lt;csrf auth-strategy="disable"/&amp;gt; a possibility?
</description>
			<version>3.2.0.RC1</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.servlet.support.csrf.CsrfRequestDataValueProcessorTests.java</file>
			<file type="M">org.springframework.security.web.csrf.CsrfToken.java</file>
			<file type="D">org.springframework.security.web.csrf.CsrfTokenTests.java</file>
			<file type="M">org.springframework.security.web.csrf.CsrfTokenRepository.java</file>
			<file type="M">org.springframework.security.web.csrf.CsrfFilterTests.java</file>
			<file type="M">org.springframework.security.web.csrf.HttpSessionCsrfTokenRepository.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configurers.SessionManagementConfigurerServlet31Tests.java</file>
			<file type="M">org.springframework.security.web.csrf.HttpSessionCsrfTokenRepositoryTests.java</file>
			<file type="M">org.springframework.security.web.csrf.CsrfFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">2276</link>
		</links>
	</bug>
	<bug id="2382" opendate="2013-10-30 09:16:58" fixdate="2013-10-30 10:12:31" resolution="Complete">
		<buginformation>
			<summary>AutowireBeanFactoryObjectPostProcessor does not work with BeanNameAutoProxyCreator</summary>
			<description>When using Spring Security with BeanNameAutoProxyCreator the following error is produced because the beanName passed in by AutowireBeanFactoryObjectPostProcessor is null.






SEVERE: Exception sending context initialized event to listener instance of class org.springframework.web.context.ContextLoaderListener




org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;springSecurityFilterChain&amp;amp;apos; defined in class org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration: Instantiation of bean failed; nested exception is org.springframework.beans.factory.BeanDefinitionStoreException: Factory method [public javax.servlet.Filter org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration.springSecurityFilterChain() throws java.lang.Exception] threw exception; nested exception is java.lang.IllegalArgumentException: &amp;amp;apos;name&amp;amp;apos; must not be null




    at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:581)




    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1025)




    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:921)




    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:487)




    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:458)




    at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:295)




    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:223)




    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:292)




    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:194)




    at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:628)




    at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:932)




    at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:479)




    at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:389)




    at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:294)




    at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:112)




    at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:4887)




    at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5381)




    at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)




    at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1559)




    at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1549)




    at java.util.concurrent.FutureTask.run(FutureTask.java:262)




    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)




    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)




    at java.lang.Thread.run(Thread.java:744)




Caused by: org.springframework.beans.factory.BeanDefinitionStoreException: Factory method [public javax.servlet.Filter org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration.springSecurityFilterChain() throws java.lang.Exception] threw exception; nested exception is java.lang.IllegalArgumentException: &amp;amp;apos;name&amp;amp;apos; must not be null




    at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:181)




    at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:570)




    ... 23 more




Caused by: java.lang.IllegalArgumentException: &amp;amp;apos;name&amp;amp;apos; must not be null




    at org.springframework.util.Assert.notNull(Assert.java:112)




    at org.springframework.beans.factory.BeanFactoryUtils.transformedBeanName(BeanFactoryUtils.java:72)




    at org.springframework.beans.factory.support.AbstractBeanFactory.transformedBeanName(AbstractBeanFactory.java:1018)




    at org.springframework.beans.factory.support.AbstractBeanFactory.getAliases(AbstractBeanFactory.java:602)




    at org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator.getAdvicesAndAdvisorsForBean(BeanNameAutoProxyCreator.java:90)




    at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.wrapIfNecessary(AbstractAutoProxyCreator.java:359)




    at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.postProcessAfterInitialization(AbstractAutoProxyCreator.java:322)




    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization(AbstractAutowireCapableBeanFactory.java:409)




    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1488)




    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:388)




    at org.springframework.security.config.annotation.configuration.AutowireBeanFactoryObjectPostProcessor.postProcess(AutowireBeanFactoryObjectPostProcessor.java:56)




    at org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter.getHttp(WebSecurityConfigurerAdapter.java:141)




    at org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter.init(WebSecurityConfigurerAdapter.java:247)




    at org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter.init(WebSecurityConfigurerAdapter.java:49)




    at intouchapp.config.SecurityConfig$$EnhancerByCGLIB$$7c2e17f3.init(&amp;lt;generated&amp;gt;)




    at org.springframework.security.config.annotation.AbstractConfiguredSecurityBuilder.init(AbstractConfiguredSecurityBuilder.java:352)




    at org.springframework.security.config.annotation.AbstractConfiguredSecurityBuilder.doBuild(AbstractConfiguredSecurityBuilder.java:305)




    at org.springframework.security.config.annotation.AbstractSecurityBuilder.build(AbstractSecurityBuilder.java:40)




    at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration.springSecurityFilterChain(WebSecurityConfiguration.java:85)




    at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$$EnhancerByCGLIB$$4da93da.CGLIB$springSecurityFilterChain$0(&amp;lt;generated&amp;gt;)




    at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$$EnhancerByCGLIB$$4da93da$$FastClassByCGLIB$$841a1210.invoke(&amp;lt;generated&amp;gt;)




    at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:228)




    at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:286)




    at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$$EnhancerByCGLIB$$4da93da.springSecurityFilterChain(&amp;lt;generated&amp;gt;)




    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)




    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




    at java.lang.reflect.Method.invoke(Method.java:606)




    at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:160)




    ... 24 more





</description>
			<version>3.2.0.RC1</version>
			<fixedVersion>3.2.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.configuration.AutowireBeanFactoryObjectPostProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="2350" opendate="2013-10-04 10:23:43" fixdate="2013-11-15 11:44:03" resolution="Fixed">
		<buginformation>
			<summary>Warning when using 3.2.0.RC2 with Spring Framework 4.0</summary>
			<description>When starting an application running Spring Framework 4.0 and Spring Security 3.2.0.RC2, the following message is logged:
12:19:08.129 [localhost-startStop-1]   WARN  org.springframework.security.core.SpringSecurityCoreVersion org.springframework.security.core.SpringSecurityCoreVersion.performVersionChecks(SpringSecurityCoreVersion.java:53): *** Spring Major version &amp;amp;apos;3&amp;amp;apos; expected, but you are running with version: 4.0.0.BUILD-SNAPSHOT. Please check your classpath for unwanted jar files.
Spring Security should certainly warn if Spring Framework is older than supported, but it should not warn if Spring Framework is newer that expected. At the very least, 3.2.0 should support Spring Framework 4.</description>
			<version>3.2.0.RC1</version>
			<fixedVersion>3.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.core.SpringSecurityCoreVersionTests.java</file>
			<file type="M">org.springframework.security.core.SpringSecurityCoreVersion.java</file>
		</fixedFiles>
	</bug>
	<bug id="2418" opendate="2013-11-27 13:10:41" fixdate="2013-12-02 10:02:10" resolution="Complete">
		<buginformation>
			<summary>[patch] toString method in LdapUserDetailsImpl never prints "Not granted any authorities"</summary>
			<description>In my application, my LDAP users have zero granted authorities, but the toString method does not print "Not granted any authorities", this is because the authorities collection is a non-null empty collection.</description>
			<version>3.2.0.RC2</version>
			<fixedVersion>3.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ldap.userdetails.LdapUserDetailsImpl.java</file>
		</fixedFiles>
	</bug>
	<bug id="2386" opendate="2013-11-04 07:00:26" fixdate="2013-12-04 13:53:49" resolution="Fixed">
		<buginformation>
			<summary>DEBUG statement with Failed to perform build and stacktrace should be stated as OK</summary>
			<description>Seems to me though that if this really is ignorable, an exception should be logged later, when there really is a problem






2013-11-04 14:51:57.631 DEBUG 13456 --- [ost-startStop-1] s.s.c.a.a.b.AuthenticationManagerBuilder : Failed to perform build. Returning null









java.lang.IllegalArgumentException: A parent AuthenticationManager or a list of AuthenticationProviders is required




at org.springframework.security.authentication.ProviderManager.checkState(ProviderManager.java:117)




at org.springframework.security.authentication.ProviderManager.&amp;lt;init&amp;gt;(ProviderManager.java:106)




at org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder.performBuild(AuthenticationManagerBuilder.java:221)





</description>
			<version>3.2.0.RC2</version>
			<fixedVersion>3.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="2367" opendate="2013-10-17 09:50:04" fixdate="2013-12-04 14:19:52" resolution="Fixed">
		<buginformation>
			<summary>ProviderManager doesn&amp;apos;t report InternalAuthenticationServiceExceptions</summary>
			<description>If the ProviderManager has multiple AuthenticationProviders and one of the earlier providers throws an InternalAuthenticationServiceException then it will not be reported if a later provider throws any kind of AuthenticationException.
I experienced this when the errors that were occurring from a misconfigured LDAP provider were masked by the UsernameNotFoundException from the subsequent dao provider.
Given the javadocs for InternalAuthenticationServiceException it sounds like these errors should be logged even if a subsequent authentication provider succeeds (or fails).  Perhaps ProviderManager.authenticate() should have a special case for handling IASEs like it does for {{AccountStatusException}}s.</description>
			<version>3.2.0.RC1</version>
			<fixedVersion>3.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.authentication.ProviderManager.java</file>
			<file type="M">org.springframework.security.authentication.ProviderManagerTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="2422" opendate="2013-12-02 03:02:25" fixdate="2013-12-11 15:54:56" resolution="Complete">
		<buginformation>
			<summary>Session timeout not detected when enable CSRF protection</summary>
			<description>settings is following:






    &amp;lt;sec:http auto-config="true" use-expressions="true"&amp;gt;




        &amp;lt;sec:session-management 




            invalid-session-url="/error/sessionError"




            session-authentication-strategy-ref="sessionAuthenticationStrategy" /&amp;gt;




    &amp;lt;/sec:http&amp;gt;






Detected the session time-out when called GET method, but not detected session time-out  when called POST method.
When called POST method, occurred the CSRF token error.
This behavior are best practice in the spring security?
Also When called POST method, i wanted to detect the session time-out.
If wanted to detect the session timeout when called POST method, what should I do?</description>
			<version>3.2.0.RC2</version>
			<fixedVersion>3.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.configurers.CsrfConfigurer.java</file>
			<file type="M">org.springframework.security.config.http.HttpConfigurationBuilder.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configurers.SessionManagementConfigurer.java</file>
			<file type="M">org.springframework.security.web.csrf.InvalidCsrfTokenException.java</file>
			<file type="M">org.springframework.security.config.http.CsrfBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.web.csrf.CsrfFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="2439" opendate="2013-12-12 13:45:14" fixdate="2013-12-13 13:48:37" resolution="Complete">
		<buginformation>
			<summary>HttpSessionCsrfTokenRepository setHeaderName uses parameterName</summary>
			<description>In HttpSessionCsrfTokenRepository, setHeaderName should use headerName, not parameterName (probably a copy/paste bug):






    /**




     * Sets the header name that the {@link CsrfToken} is expected to appear on




     * and the header that the response will contain the {@link CsrfToken}.




     *




     * @param parameterName




     *            the new parameter name to use




     */




    public void setHeaderName(String parameterName) {




        Assert.hasLength(parameterName, "parameterName cannot be null or empty");




        this.parameterName = parameterName;




    }





</description>
			<version>3.2.0.RC2</version>
			<fixedVersion>3.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.csrf.HttpSessionCsrfTokenRepositoryTests.java</file>
			<file type="M">org.springframework.security.web.csrf.HttpSessionCsrfTokenRepository.java</file>
		</fixedFiles>
	</bug>
	<bug id="2457" opendate="2013-12-21 12:12:42" fixdate="2014-01-29 12:38:32" resolution="Duplicate">
		<buginformation>
			<summary>Warning "Method &amp;apos;setFilterProcessesUrl&amp;apos; is marked deprecated" on http-login and http-logout tag</summary>
			<description>&amp;lt;security:form-login login-page=&amp;amp;apos;/login&amp;amp;apos; default-target-url="/" authentication-failure-url="/loginfailed" /&amp;gt;
&amp;lt;security:logout logout-success-url="/" invalidate-session="true" logout-url="/logout" /&amp;gt;
Warning appear on each line : "Method &amp;amp;apos;setFilterProcessesUrl&amp;amp;apos; is marked deprecated"
Is there now a new recommended way to do this?
I have not seen anything in the documentation about it.</description>
			<version>3.2.0</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.AuthenticationConfigBuilder.java</file>
			<file type="M">org.springframework.security.config.http.FormLoginBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.web.authentication.logout.LogoutFilter.java</file>
			<file type="M">org.springframework.security.config.http.LogoutBeanDefinitionParser.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">2455</link>
		</links>
	</bug>
	<bug id="2455" opendate="2013-12-18 01:35:17" fixdate="2014-01-29 13:36:10" resolution="Fixed">
		<buginformation>
			<summary>form@login-processing-url and logout@logout-url produce warnings</summary>
			<description>On upgrading to 3.2.0 RELEASE, we encountered this warning in the &amp;lt;http&amp;gt; block in the namespace configuration. 
&amp;lt;form-login&amp;gt; and &amp;lt;logout&amp;gt;
The warning says that setFilterProcessesUrl (which is inherited from AbstractAuthenticationProcessingFilter whose subclass be used by http@form-login and http@logout) is deprecated. Did we miss on replacing the deprecated method with the new method to be used? Can we remove this method altogether? Or is this warning here to stay? What does this warning mean?</description>
			<version>3.2.0</version>
			<fixedVersion>3.2.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.AuthenticationConfigBuilder.java</file>
			<file type="M">org.springframework.security.config.http.FormLoginBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.web.authentication.logout.LogoutFilter.java</file>
			<file type="M">org.springframework.security.config.http.LogoutBeanDefinitionParser.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">2457</link>
		</links>
	</bug>
	<bug id="2461" opendate="2014-01-09 09:09:34" fixdate="2014-02-09 19:48:46" resolution="Fixed">
		<buginformation>
			<summary>Multiple WebSecurityConfiguration instances cause null springSecurityFilterChain</summary>
			<description>See SpringApplicationHierarchyTests within https://github.com/rwinch/spring-boot/tree/SEC-2461</description>
			<version>3.2.0</version>
			<fixedVersion>3.2.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configuration.sec2377.b.Sec2377BConfig.java</file>
		</fixedFiles>
	</bug>
	<bug id="2392" opendate="2013-11-08 08:31:06" fixdate="2014-02-13 13:41:15" resolution="Fixed">
		<buginformation>
			<summary>Unexpectedly long key created by KeyBasedPersistenceTokenService.allocateToken()</summary>
			<description>The method allocateToken in KeyBasedPersistenceTokenService creates a token with an unexpectedly long key.
The reason for this is that the attribute pseudoRandomNumberBits (default = 256) is not converted to a number of bytes in the method generatePseudoRandomNumber() :






    private String generatePseudoRandomNumber() {




        byte[] randomizedBits = new byte[pseudoRandomNumberBits];




        secureRandom.nextBytes(randomizedBits);




        return new String(Hex.encode(randomizedBits));




    }






This string is then concatenated to others to create the final key of the Token :






        String content = Long.toString(creationTime) + ":" + pseudoRandomNumber + ":" + extendedInformation;









        // Compute key




        String sha512Hex = Sha512DigestUtils.shaHex(content + ":" + serverSecret);




        String keyPayload = content + ":" + sha512Hex;




        String key = Utf8.decode(Base64.encode(Utf8.encode(keyPayload)));





</description>
			<version>3.2.0</version>
			<fixedVersion>3.2.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.core.token.KeyBasedPersistenceTokenService.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">2491</link>
		</links>
	</bug>
	<bug id="2492" opendate="2014-02-15 11:00:29" fixdate="2014-02-15 12:42:10" resolution="Complete">
		<buginformation>
			<summary>ExpressionUrlAuthorizationConfigurer.interceptUrl Javadoc incorrect</summary>
			<description>Looks like refactoring garbage. As stated in javadoc comment method could be chained, but now it is private.</description>
			<version>3.2.0</version>
			<fixedVersion>3.2.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.configurers.ExpressionUrlAuthorizationConfigurer.java</file>
		</fixedFiles>
	</bug>
	<bug id="2472" opendate="2014-01-28 10:08:41" fixdate="2014-05-21 15:03:04" resolution="Complete">
		<buginformation>
			<summary>Can&amp;apos;t use recommended BCryptPasswordEncoder for PasswordComparisonAuthenticator on a Ldap Authenticator</summary>
			<description>According to the Spring Security Reference for version 3.2, we should use BCryptPasswordEncoder for encrypting passwords.  The class org.springframework.security.ldap.authentication.AbstractLdapAuthenticator has a method setPasswordEncoder that takes a single parameter of type org.springframework.security.authentication.encoding.PasswordEncoder, which is an interface that is deprecated.  All known classes that implement that interface are deprecated and represent various encryption algorithms that are no longer recommended.  org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder (the recommended encoder) does not implement that deprecated interface, it implements org.springframework.security.crypto.password.PasswordEncoder (tricky because the interface name is the same, but belongs to a different package as the deprecated interface).  The parameter type on the method setPasswordEncoder in the class org.springframework.security.ldap.authentication.AbstractLdapAuthenticator needs to be changed to org.springframework.security.crypto.password.PasswordEncoder.</description>
			<version>3.2.0</version>
			<fixedVersion>3.2.4, 4.0.0.M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.authentication.configurers.ldap.LdapAuthenticationProviderConfigurer.java</file>
			<file type="M">org.springframework.security.ldap.authentication.PasswordComparisonAuthenticator.java</file>
			<file type="M">org.springframework.security.ldap.authentication.PasswordComparisonAuthenticatorTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="2683" opendate="2014-07-15 08:05:10" fixdate="2014-07-18 11:58:00" resolution="Complete">
		<buginformation>
			<summary>Spelling Mistake in AuthenticationPrincipalArgumentResolver</summary>
			<description>In AuthenticationPrincipalArgumentResolver, line 109, assignable is misspelled as "assiable" in the Exception reason.</description>
			<version>3.2.0</version>
			<fixedVersion>3.2.5, 4.0.0.M2</fixedVersion>
			<type>Defect</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.bind.support.AuthenticationPrincipalArgumentResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="2574" opendate="2014-04-23 09:38:33" fixdate="2014-11-19 14:50:57" resolution="Fixed">
		<buginformation>
			<summary>Default JavaConfig SessionRegistryImpl does not receive SessionDestroyedEvents</summary>
			<description>SessionManagementConfigurer creates a default SessionRegistryImpl directly, without wiring it as a Spring bean. So, the SessionRegistryImpl does not receive SessionDestroyedEvents and does not maintain an accurate list of current sessions.
Once consequence of this is that concurrency control will work off inaccurate data, and in the worst case prevents users from ever logging in a second time with maximumSessions(1) and maxSessionPreventsLogin(true).
A workaround is for an application to define its own @Bean sessionRegistry(), and use it with "ConcurrencyControlConfigurer.sessionRegistry(sessionRegistry())". But this shouldn&amp;amp;apos;t be necessary.</description>
			<version>3.2.0</version>
			<fixedVersion>3.2.6, 4.0.0.RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.configurers.SessionManagementConfigurer.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="2497" opendate="2014-02-23 14:04:01" fixdate="2014-12-16 07:46:58" resolution="Duplicate">
		<buginformation>
			<summary>checkForPrincipalChanges limited to String Principal</summary>
			<description>In AbstractPreAuthenticatedProcessingFilter,
method requiresAuthentication , Principal are assumed to be String 
 if (currentUser.getName().equals(principal)) 
should be
  if (currentUser.getPrincipal().equals(principal)) </description>
			<version>3.2.0</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilterTests.java</file>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">2078</link>
		</links>
	</bug>
	<bug id="2493" opendate="2014-02-19 08:11:40" fixdate="2015-07-14 11:37:14" resolution="Complete">
		<buginformation>
			<summary>Javadoc for DefaultLdapAuthoritiesPopulator lists wrong class name &amp; incorrect property</summary>
			<description>http://docs.spring.io/spring-security/site/docs/3.2.0.RELEASE/apidocs/org/springframework/security/ldap/userdetails/DefaultLdapAuthoritiesPopulator.html
shows






&amp;lt;bean id="ldapAuthoritiesPopulator"




       class="org.springframework.security.authentication.ldap.populator.DefaultLdapAuthoritiesPopulator"&amp;gt;




   &amp;lt;constructor-arg ref="contextSource"/&amp;gt;




   &amp;lt;constructor-arg value="ou=groups"/&amp;gt;




   &amp;lt;property name="groupRoleAttribute" value="ou"/&amp;gt;




 &amp;lt;!-- the following properties are shown with their default values --&amp;gt;




   &amp;lt;property name="searchSubTree" value="false"/&amp;gt;




   &amp;lt;property name="rolePrefix" value="ROLE_"/&amp;gt;




   &amp;lt;property name="convertToUpperCase" value="true"/&amp;gt;




 &amp;lt;/bean&amp;gt;






but should be






&amp;lt;bean id="ldapAuthoritiesPopulator"




       class="org.springframework.security.ldap.userdetails.DefaultLdapAuthoritiesPopulator"&amp;gt;




   &amp;lt;constructor-arg ref="contextSource"/&amp;gt;




   &amp;lt;constructor-arg value="ou=groups"/&amp;gt;




   &amp;lt;property name="groupRoleAttribute" value="ou"/&amp;gt;




 &amp;lt;!-- the following properties are shown with their default values --&amp;gt;




   &amp;lt;property name="searchSubTree" value="false"/&amp;gt;




   &amp;lt;property name="rolePrefix" value="ROLE_"/&amp;gt;




   &amp;lt;property name="convertToUpperCase" value="true"/&amp;gt;




 &amp;lt;/bean&amp;gt;






</description>
			<version>3.2.0</version>
			<fixedVersion>3.2.8, 4.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ldap.userdetails.DefaultLdapAuthoritiesPopulator.java</file>
		</fixedFiles>
	</bug>
	<bug id="2190" opendate="2013-07-02 05:02:45" fixdate="2015-10-29 16:31:03" resolution="Complete">
		<buginformation>
			<summary>Support WebApplicationContext in any ServletContext attribute</summary>
			<description>When using the new way of configuring the DispatcherServlet in the web.xml without the ContextLoaderListener (3.2.0 core), the AbstractAuthorizeTag cannot find the configured WebContext because it is not associated with the default contextAttribute WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE.
The SpringSecurityFilterChain solved this problem by adding a contextAttribute init-param.
web.xml :






  &amp;lt;filter&amp;gt;




    &amp;lt;filter-name&amp;gt;springSecurityFilterChain&amp;lt;/filter-name&amp;gt;




    &amp;lt;filter-class&amp;gt;org.springframework.web.filter.DelegatingFilterProxy&amp;lt;/filter-class&amp;gt;




    &amp;lt;init-param&amp;gt;




      &amp;lt;param-name&amp;gt;contextAttribute&amp;lt;/param-name&amp;gt;




      &amp;lt;param-value&amp;gt;org.springframework.web.servlet.FrameworkServlet.CONTEXT.springapp&amp;lt;/param-value&amp;gt;




    &amp;lt;/init-param&amp;gt;




  &amp;lt;/filter&amp;gt;









  &amp;lt;servlet&amp;gt;




    &amp;lt;servlet-name&amp;gt;springapp&amp;lt;/servlet-name&amp;gt;




    &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;




    &amp;lt;init-param&amp;gt;




      &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;




      &amp;lt;param-value&amp;gt;




        /WEB-INF/springapp-security-config.xml




        /WEB-INF/springapp-servlet-config.xml




      &amp;lt;/param-value&amp;gt;




    &amp;lt;/init-param&amp;gt;




    &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;




  &amp;lt;/servlet&amp;gt;




  &amp;lt;servlet-mapping&amp;gt;




    &amp;lt;servlet-name&amp;gt;springapp&amp;lt;/servlet-name&amp;gt;




    &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;




  &amp;lt;/servlet-mapping&amp;gt;






Error on a jsp acces :






javax.servlet.jsp.JspException: java.lang.IllegalStateException: No WebApplicationContext found: no ContextLoaderListener registered?] with root cause




java.lang.IllegalStateException: No WebApplicationContext found: no ContextLoaderListener registered?




	at org.springframework.web.context.support.WebApplicationContextUtils.getRequiredWebApplicationContext(WebApplicationContextUtils.java:90)




	at org.springframework.security.taglibs.authz.AbstractAuthorizeTag.getExpressionHandler(AbstractAuthorizeTag.java:315)




	at org.springframework.security.taglibs.authz.AbstractAuthorizeTag.authorizeUsingAccessExpression(AbstractAuthorizeTag.java:172)




	at org.springframework.security.taglibs.authz.AbstractAuthorizeTag.authorize(AbstractAuthorizeTag.java:105)




	at org.springframework.security.taglibs.authz.JspAuthorizeTag.doStartTag(JspAuthorizeTag.java:54)




	at org.apache.jsp.WEB_002dINF.jsp.home.home_jsp._jspx_meth_sec_005fauthorize_005f0(home_jsp.java:187)




	at org.apache.jsp.WEB_002dINF.jsp.home.home_jsp.access$3(home_jsp.java:177)




	at org.apache.jsp.WEB_002dINF.jsp.home.home_jsp$Helper.invoke0(home_jsp.java:254)




	at org.apache.jsp.WEB_002dINF.jsp.home.home_jsp$Helper.invoke(home_jsp.java:278)




	at org.apache.jsp.tag.webtemplate.default_tag.doTag(default_tag.java:206)




	at org.apache.jsp.WEB_002dINF.jsp.home.home_jsp._jspx_meth_template_005fdefault_005f0(home_jsp.java:115)




	at org.apache.jsp.WEB_002dINF.jsp.home.home_jsp._jspService(home_jsp.java:86)




	at org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:70)




	at javax.servlet.http.HttpServlet.service(HttpServlet.java:728)




	at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:432)




	at org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:390)




	at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:334)




	at javax.servlet.http.HttpServlet.service(HttpServlet.java:728)




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:305)




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210)




	at org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:749)




	at org.apache.catalina.core.ApplicationDispatcher.processRequest(ApplicationDispatcher.java:487)




	at org.apache.catalina.core.ApplicationDispatcher.doForward(ApplicationDispatcher.java:412)




	at org.apache.catalina.core.ApplicationDispatcher.forward(ApplicationDispatcher.java:339)




	at org.springframework.web.servlet.view.InternalResourceView.renderMergedOutputModel(InternalResourceView.java:238)




	at org.springframework.web.servlet.view.AbstractView.render(AbstractView.java:264)




	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1208)




	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:992)




	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:939)




	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:856)




	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:936)




	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:827)




	at javax.servlet.http.HttpServlet.service(HttpServlet.java:621)




	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:812)




	at javax.servlet.http.HttpServlet.service(HttpServlet.java:728)




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:305)




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210)




	at com.somesofts.bookmyevent.web.common.filter.SessionDebugFilter.doFilter(SessionDebugFilter.java:108)




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:243)




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330)




	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:118)




	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:84)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:113)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:103)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:113)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilter.doFilter(RememberMeAuthenticationFilter.java:139)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:150)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:45)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:184)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:105)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:50)




	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.session.ConcurrentSessionFilter.doFilter(ConcurrentSessionFilter.java:125)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:87)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.access.channel.ChannelProcessingFilter.doFilter(ChannelProcessingFilter.java:144)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:192)




	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:160)




	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:346)




	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:259)




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:243)




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210)




	at com.somesofts.bookmyevent.web.common.filter.CacheDebugFilter.doFilter(CacheDebugFilter.java:54)




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:243)




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210)




	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:222)




	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:123)




	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:472)




	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:171)




	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:99)




	at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:936)




	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:118)




	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:407)




	at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1004)




	at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:589)




	at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:312)




	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)




	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)




	at java.lang.Thread.run(Thread.java:722)





</description>
			<version>3.2.0.RC1</version>
			<fixedVersion>3.2.9, 4.0.3, 4.1.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.context.support.SecurityWebApplicationContextUtils.java</file>
			<file type="M">org.springframework.security.taglibs.authz.AbstractAuthorizeTagTests.java</file>
			<file type="M">org.springframework.security.web.session.HttpSessionEventPublisher.java</file>
			<file type="M">org.springframework.security.web.session.HttpSessionEventPublisherTests.java</file>
			<file type="M">org.springframework.security.taglibs.authz.AccessControlListTagTests.java</file>
			<file type="M">org.springframework.security.taglibs.authz.AccessControlListTag.java</file>
			<file type="M">org.springframework.security.taglibs.authz.AbstractAuthorizeTag.java</file>
		</fixedFiles>
	</bug>
</bugrepository>