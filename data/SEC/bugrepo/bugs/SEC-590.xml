<!-- 
RSS generated by JIRA (6.4.11#64026-sha1:78f6ec473a3f058bd5d6c30e9319c7ab376bdb9c) at Fri Dec 23 11:02:55 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://jira.spring.io/si/jira.issueviews:issue-xml/SEC-590/SEC-590.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>Spring JIRA</title>
    <link>https://jira.spring.io</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.4.11</version>
        <build-number>64026</build-number>
        <build-date>25-08-2015</build-date>
    </build-info>

<item>
            <title>[SEC-590] BasicLookupStrategy#readAclsById(ObjectIdentity[], Sid[]) has a loop that sometimes terminates prematurely</title>
                <link>https://jira.spring.io/browse/SEC-590</link>
                <project id="10040" key="SEC">Spring Security</project>
                    <description>&lt;p&gt;The main for loop in &lt;br/&gt;
org.acegisecurity.acls.jdbc.BasicLookupStrategy#readAclsById(ObjectIdentity[], Sid[])  &lt;br/&gt;
uses &apos;continue;&apos; when an Acl is either found to be already in the results, or is found in the cache.  But the section of code that looks up batches Acls from the database is in the loop, so if the last ObjectIdentity in the in the objects array is found in the results or cache, the loop will terminate without looking up the last batch of Acls from the database.&lt;/p&gt;

&lt;p&gt;I&apos;ve written a unit test to prove this, it should be added to org.acegisecurity.acls.jdbc.LookupStrategyTest&lt;/p&gt;

&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;A test specifically for a bug, where if the LAST 
{@link ObjectIdentity} in &lt;br/&gt;
   * the array of of Oids we are getting ACL&apos;s for is in the cache, the &lt;br/&gt;
   * collection of {@link ObjectIdentity}
&lt;p&gt; being collected for a bulk database&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;lookup will not be processed due to some inapropriate &amp;lt;code&amp;gt;Continue&amp;lt;/code&amp;gt;&lt;/li&gt;
	&lt;li&gt;statements in the loop.&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;@throws Exception&lt;br/&gt;
   */&lt;br/&gt;
  public void testReadLastIsCachedBugFix() throws Exception&lt;br/&gt;
  {&lt;br/&gt;
    ObjectIdentity grandParentOid = new ObjectIdentityImpl(&quot;org.acegisecurity.TargetObject&quot;, new Long(104));&lt;br/&gt;
    ObjectIdentity parent1Oid = new ObjectIdentityImpl(&quot;org.acegisecurity.TargetObject&quot;, new Long(105));&lt;br/&gt;
    ObjectIdentity parent2Oid = new ObjectIdentityImpl(&quot;org.acegisecurity.TargetObject&quot;, new Long(106));&lt;br/&gt;
    ObjectIdentity childOid = new ObjectIdentityImpl(&quot;org.acegisecurity.TargetObject&quot;, new Long(107));&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    MutableAcl grandParentAcl = jdbcMutableAclService.createAcl(grandParentOid);&lt;br/&gt;
    MutableAcl parent1Acl = jdbcMutableAclService.createAcl(parent1Oid);&lt;br/&gt;
    MutableAcl parent2Acl = jdbcMutableAclService.createAcl(parent2Oid);&lt;br/&gt;
    MutableAcl childAcl = jdbcMutableAclService.createAcl(childOid);&lt;/p&gt;

&lt;p&gt;    // Specify the inheritence hierarchy&lt;br/&gt;
    parent1Acl.setParent(grandParentAcl);&lt;br/&gt;
    parent2Acl.setParent(grandParentAcl);&lt;br/&gt;
    childAcl.setParent(parent1Acl);&lt;/p&gt;

&lt;p&gt;    // Now let&apos;s add a couple of permissions&lt;br/&gt;
    grandParentAcl.insertAce(null, BasePermission.READ, new PrincipalSid(auth), true);&lt;/p&gt;

&lt;p&gt;    // Explictly save the changed ACL&lt;br/&gt;
    jdbcMutableAclService.updateAcl(grandParentAcl);&lt;br/&gt;
    jdbcMutableAclService.updateAcl(parent1Acl);&lt;br/&gt;
    jdbcMutableAclService.updateAcl(parent2Acl);&lt;br/&gt;
    jdbcMutableAclService.updateAcl(childAcl);&lt;/p&gt;

&lt;p&gt;    // fluch cache to make sure we they are retieved from DB&lt;br/&gt;
    cache.removeAll();&lt;/p&gt;

&lt;p&gt;    // first lookup only child&lt;br/&gt;
    Permission[] checkPermision = new Permission[] &lt;/p&gt;
{BasePermission.READ}
&lt;p&gt;;&lt;br/&gt;
    Sid[] sids = new Sid[] &lt;/p&gt;
{ new PrincipalSid(auth)}
&lt;p&gt;;&lt;br/&gt;
    ObjectIdentity[] childOids = new ObjectIdentity[] &lt;/p&gt;
{childOid}
&lt;p&gt;;&lt;br/&gt;
    Map foundAcls = lookupStrategy.readAclsById(childOids, sids);&lt;/p&gt;

&lt;p&gt;    Acl foundChildAcl = (Acl) foundAcls.get(childOid);&lt;br/&gt;
    assertNotNull(foundChildAcl);&lt;br/&gt;
    assertTrue(foundChildAcl.isGranted(checkPermision, sids, false));&lt;/p&gt;

&lt;p&gt;    // we now expect that the acls for child, parent1 and grandparent are cached&lt;br/&gt;
    // if the bug is present and we now search for all for acls, and make sure&lt;br/&gt;
    // that batchsize is greater than 4, and that parent2 is not the last in the &lt;br/&gt;
    // oid array (it&apos;s the only one not cached), then having an aleady cached&lt;br/&gt;
    // ACL as the last in the oid array to lookup, will cause the BUG we are &lt;br/&gt;
    // for testing to skip the DB lookup when the last entry to check is &lt;br/&gt;
    // retireved from the cache.&lt;br/&gt;
    ObjectIdentity[] allOids = new ObjectIdentity[] &lt;/p&gt;
{grandParentOid, parent1Oid, parent2Oid, childOid}
&lt;p&gt;;&lt;br/&gt;
    foundAcls = lookupStrategy.readAclsById(allOids, sids);&lt;/p&gt;

&lt;p&gt;    Acl foundParent2Acl = (Acl) foundAcls.get(parent2Oid);&lt;br/&gt;
    assertNotNull(foundParent2Acl);&lt;br/&gt;
    assertTrue(foundParent2Acl.isGranted(checkPermision, sids, false));&lt;br/&gt;
 }&lt;/p&gt;


&lt;p&gt;And rewritten org.acegisecurity.acls.jdbc.BasicLookupStrategy#readAclsById(ObjectIdentity[], Sid[])  to fix it&lt;/p&gt;

&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;The main method.&amp;lt;p&amp;gt;WARNING: This implementation completely disregards the &quot;sids&quot; parameter! Every item&lt;/li&gt;
	&lt;li&gt;in the cache is expected to contain all SIDs. If you have serious performance needs (eg a very large number of&lt;/li&gt;
	&lt;li&gt;SIDs per object identity), you&apos;ll probably want to develop a custom 
{@link LookupStrategy}
&lt;p&gt; implementation&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;instead.&amp;lt;/p&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;p&amp;gt;The implementation works in batch sizes specfied by 
{@link #batchSize}
&lt;p&gt;.&amp;lt;/p&amp;gt;&lt;br/&gt;
     *&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@param objects DOCUMENT ME!&lt;/li&gt;
	&lt;li&gt;@param sids DOCUMENT ME!&lt;br/&gt;
     *&lt;/li&gt;
	&lt;li&gt;@return DOCUMENT ME!&lt;br/&gt;
     *&lt;/li&gt;
	&lt;li&gt;@throws NotFoundException DOCUMENT ME!&lt;/li&gt;
	&lt;li&gt;@throws IllegalStateException DOCUMENT ME!&lt;br/&gt;
     */&lt;br/&gt;
    public Map readAclsById(ObjectIdentity[] objects, Sid[] sids)&lt;br/&gt;
        throws NotFoundException {&lt;br/&gt;
        Assert.isTrue(batchSize &amp;gt;= 1, &quot;BatchSize must be &amp;gt;= 1&quot;);&lt;br/&gt;
        Assert.notEmpty(objects, &quot;Objects to lookup required&quot;);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;        // Map&amp;lt;ObjectIdentity,Acl&amp;gt;&lt;br/&gt;
        Map result = new HashMap(); // contains FULLY loaded Acl objects&lt;/p&gt;

&lt;p&gt;        Set currentBatchToLoad = new HashSet(); // contains ObjectIdentitys&lt;/p&gt;

&lt;p&gt;        for (int i = 0; i &amp;lt; objects.length; i++) {&lt;/p&gt;

&lt;p&gt;            // flag to record if we have found the acl for this iteration&lt;br/&gt;
            boolean aclFound = false;&lt;/p&gt;

&lt;p&gt;            // 1.) Check we don&apos;t already have this ACL in the results&lt;br/&gt;
            if (result.containsKey(objects&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt;)) &lt;/p&gt;
{
                aclFound = true; // flag as found
            }

&lt;p&gt;            // 2.) Check cache for the present ACL entry&lt;br/&gt;
            if (!aclFound) {&lt;br/&gt;
              Acl acl = aclCache.getFromCache(objects&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt;);&lt;/p&gt;

&lt;p&gt;              // Ensure any cached element supports all the requested SIDs&lt;br/&gt;
              // (they should always, as our base impl doesn&apos;t filter on SID)&lt;br/&gt;
              if (acl != null) {&lt;br/&gt;
                  if (acl.isSidLoaded(sids)) &lt;/p&gt;
{
                      result.put(acl.getObjectIdentity(), acl);
                      aclFound = true; // flag as found
                  }
&lt;p&gt; else &lt;/p&gt;
{
                      throw new IllegalStateException(
                          &quot;Error: SID-filtered element detected when implementation does not perform SID filtering - have you added something to the cache manually?&quot;);
                  }
&lt;p&gt;              }&lt;br/&gt;
            }&lt;/p&gt;

&lt;p&gt;            // 3. Load the Acl from the database&lt;br/&gt;
            if (!aclFound) &lt;/p&gt;
{
              currentBatchToLoad.add(objects[i]);
            }

&lt;p&gt;            // Is it time to load from JDBC the currentBatchToLoad?&lt;br/&gt;
            if ((currentBatchToLoad.size() == this.batchSize) || ((i + 1) == objects.length)) {&lt;/p&gt;

&lt;p&gt;                if (currentBatchToLoad.size() &amp;gt; 0) {&lt;/p&gt;

&lt;p&gt;                    Map loadedBatch = lookupObjectIdentities((ObjectIdentity[]) currentBatchToLoad.toArray(&lt;br/&gt;
                                new ObjectIdentity[] {}), sids);&lt;/p&gt;

&lt;p&gt;                    // Add loaded batch (all elements 100% initialized) to results&lt;br/&gt;
                    result.putAll(loadedBatch);&lt;/p&gt;

&lt;p&gt;                    // Add the loaded batch to the cache&lt;br/&gt;
                    Iterator loadedAclIterator = loadedBatch.values().iterator();&lt;/p&gt;

&lt;p&gt;                    while (loadedAclIterator.hasNext()) &lt;/p&gt;
{
                        aclCache.putInCache((AclImpl) loadedAclIterator.next());
                    }
&lt;p&gt;                }&lt;br/&gt;
                currentBatchToLoad.clear();&lt;br/&gt;
            }&lt;br/&gt;
        }&lt;/p&gt;

&lt;p&gt;        // Now we&apos;re done, check every requested object identity was found &lt;br/&gt;
        // and log it.&lt;br/&gt;
        if (LOG.isWarnEnabled()) {&lt;br/&gt;
          for (int i = 0; i &amp;lt; objects.length; i++) {&lt;br/&gt;
              if (!result.containsKey(objects&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt;)) &lt;/p&gt;
{
                  LOG.warn(&quot;Unable to find ACL information for object identity &apos;&quot;
                      + objects[i].toString() + &quot;&apos;&quot;);
              }
&lt;p&gt;          }&lt;br/&gt;
        }&lt;/p&gt;

&lt;p&gt;        return result;&lt;br/&gt;
    }&lt;/p&gt;


&lt;p&gt;Note: This should probably be added to &lt;br/&gt;
&lt;a href=&quot;http://opensource.atlassian.com/projects/spring/browse/SEC-532&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://opensource.atlassian.com/projects/spring/browse/SEC-532&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;NOTE: 2&lt;br/&gt;
This should be fixed after &lt;br/&gt;
&lt;a href=&quot;http://opensource.atlassian.com/projects/spring/browse/SEC-547&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://opensource.atlassian.com/projects/spring/browse/SEC-547&lt;/a&gt;&lt;br/&gt;
(included code contains fix for 547 and 589 also)&lt;/p&gt;

&lt;p&gt;NOTE: 3 This bug was very difficult to replicate in our application, because it is dependent on the last ObjectIdentity being found in the cache AND there being a batch or part batch of Acls to be looked up.&lt;/p&gt;</description>
                <environment>ubuntu feisty, Java HotSpot(TM) Client VM (build 1.6.0_01-b06, mixed mode, sharing)&lt;br/&gt;
tomcat 5.5.16</environment>
        <key id="18404">SEC-590</key>
            <summary>BasicLookupStrategy#readAclsById(ObjectIdentity[], Sid[]) has a loop that sometimes terminates prematurely</summary>
                <type id="1" iconUrl="https://jira.spring.io/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://jira.spring.io/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://jira.spring.io/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="balex">Ben Alex</assignee>
                                    <reporter username="svanders">Simon van der Sluis</reporter>
                        <labels>
                    </labels>
                <created>Mon, 5 Nov 2007 14:17:19 +0000</created>
                <updated>Sat, 6 Feb 2016 06:34:09 +0000</updated>
                            <resolved>Sat, 5 Apr 2008 09:34:14 +0000</resolved>
                                    <version>1.0.3</version>
                                    <fixVersion>2.0.0</fixVersion>
                                    <component>ACLs</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                    <timeoriginalestimate seconds="28800">1d</timeoriginalestimate>
                            <timeestimate seconds="28800">1d</timeestimate>
                                        <comments>
                            <comment id="34398" author="balex" created="Sat, 5 Apr 2008 09:34:14 +0000"  >&lt;p&gt;Thanks Simon for picking up a tricky bug and providing a usable patch!&lt;/p&gt;

&lt;p&gt;I have applied your changes to BasicLookupStrategy, and ensured they were applied subsequent to the other improvements you made in &lt;a href=&quot;https://jira.spring.io/browse/SEC-547&quot; title=&quot;acls BasicLookupStrategy user too many (&amp;gt; 1) databasse connections&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SEC-547&quot;&gt;&lt;del&gt;SEC-547&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://jira.spring.io/browse/SEC-589&quot; title=&quot;BasicLookupStrategy#readAclsById(ObjectIdentity[], Sid[]), throws exception, when a warning log would do&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SEC-589&quot;&gt;&lt;del&gt;SEC-589&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Tests pass (spring-security-acl, Contacts sample, DMS sample). SVN commit revision 2875.&lt;/p&gt;</comment>
                            <comment id="126583" author="issuemaster" created="Sat, 6 Feb 2016 06:34:09 +0000"  >&lt;p&gt;This issue has been migrated to &lt;a href=&quot;https://github.com/spring-projects/spring-security/issues/851&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/spring-projects/spring-security/issues/851&lt;/a&gt;&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10011">
                    <name>Depends</name>
                                            <outwardlinks description="depends on">
                                        <issuelink>
            <issuekey id="17838">SEC-547</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="18403">SEC-589</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_10170" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>First Response Date</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sat, 5 Apr 2008 09:34:14 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10280" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>20264</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10880" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i03zv3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10380" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>23352</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10381" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Ranking</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>19839</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_10171" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>