<!-- 
RSS generated by JIRA (6.4.11#64026-sha1:78f6ec473a3f058bd5d6c30e9319c7ab376bdb9c) at Fri Dec 23 09:47:12 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://jira.spring.io/si/jira.issueviews:issue-xml/SEC-1373/SEC-1373.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>Spring JIRA</title>
    <link>https://jira.spring.io</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.4.11</version>
        <build-number>64026</build-number>
        <build-date>25-08-2015</build-date>
    </build-info>

<item>
            <title>[SEC-1373] UsernamePasswordAuthenticationToken retains password in cleartext even after authentication has succeeded</title>
                <link>https://jira.spring.io/browse/SEC-1373</link>
                <project id="10040" key="SEC">Spring Security</project>
                    <description>&lt;p&gt;When using default form-based authentication, &lt;tt&gt;UsernamePasswordAuthenticationToken.getCredentials()&lt;/tt&gt; (specifically, &lt;tt&gt;((SecurityContextHolderAwareRequestWrapper)request).getUserPrincipal().getCredentials()&lt;/tt&gt;) returns the user&apos;s cleartext password on all requests, even after the user&apos;s session has been authenticated.&lt;/p&gt;

&lt;p&gt;Though I&apos;m far from a security expert, this seems really bad.  &lt;tt&gt;Authentication&lt;/tt&gt; instances (in this case, &lt;tt&gt;UsernamePasswordAuthenticationToken&lt;/tt&gt;) are likely being serialized to disk and databases right now by various containers &amp;#8211; those serializations almost certainly contain users&apos; cleartext passwords.  Clustered applications that use distributed sessions offer an even broader surface for accessing those credentials.&lt;/p&gt;

&lt;p&gt;A localized solution would be to add a &lt;tt&gt;setCredentials()&lt;/tt&gt; method to &lt;tt&gt;AbstractAuthenticationToken&lt;/tt&gt;, which &lt;tt&gt;UsernamePasswordAuthenticationFilter.attemptAuthentication()&lt;/tt&gt; could use to clear the credentials after a successful authentication.&lt;/p&gt;

&lt;p&gt;More broadly: perhaps there are auth providers that do require credentials even after a session has been authenticated, or perhaps there are other use cases where having credentials around is necessary for some other purpose, but (from my naive perspective) it seems that user credentials are &lt;b&gt;never&lt;/b&gt; needed after authentication has been completed successfully, so perhaps all authentication managers should clear credentials from &lt;tt&gt;Authentication&lt;/tt&gt; instances, regardless of the type of token/provider involved?&lt;/p&gt;</description>
                <environment></environment>
        <key id="29719">SEC-1373</key>
            <summary>UsernamePasswordAuthenticationToken retains password in cleartext even after authentication has succeeded</summary>
                <type id="1" iconUrl="https://jira.spring.io/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="2" iconUrl="https://jira.spring.io/images/icons/priorities/critical.png">Critical</priority>
                        <status id="6" iconUrl="https://jira.spring.io/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="luke">Luke Taylor</assignee>
                                    <reporter username="cemerick">Chas Emerick</reporter>
                        <labels>
                    </labels>
                <created>Tue, 19 Jan 2010 02:32:05 +0000</created>
                <updated>Sat, 6 Feb 2016 06:13:24 +0000</updated>
                            <resolved>Tue, 29 Jun 2010 05:21:01 +0000</resolved>
                                    <version>3.0.0</version>
                                    <fixVersion>3.0.3</fixVersion>
                    <fixVersion>3.1.0.M1</fixVersion>
                                    <component>Core</component>
                        <due></due>
                            <votes>3</votes>
                                    <watches>6</watches>
                                                                <comments>
                            <comment id="50316" author="cemerick" created="Tue, 19 Jan 2010 02:34:05 +0000"  >&lt;p&gt;Sorry for the formatting &amp;#8211; I (incorrectly) assumed that wiki formatting was enabled here. &lt;img class=&quot;emoticon&quot; src=&quot;https://jira.spring.io/images/icons/emoticons/sad.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="50320" author="luke" created="Tue, 19 Jan 2010 04:41:11 +0000"  >&lt;p&gt;It&apos;s generally assumed that you have full control of the environment your application is running in and that access to the disc and network traffic is secured. Even if you have the ability to clear passwords, you have no guarantee when or if it will be garbage collected and that it won&apos;t be written to disk at some point. Similarly with other security-related data in your application, like database passwords. You should also have control over session serialization in your servlet container. You can disable it if you want to.&lt;/p&gt;

&lt;p&gt;You can also customize the behaviour in Spring Security if you wish. You have control over the Authentication value that is returned from an AuthenticationProvider. For example, you can override DaoAuthenticationProvider.createSuccessAuthentication method. In Spring Security 3.0, you can also use a custom storage strategy for the security context by implementing SecurityContextRepository, so you are not limited to storage in the HttpSession.&lt;/p&gt;</comment>
                            <comment id="50322" author="cemerick" created="Tue, 19 Jan 2010 04:55:49 +0000"  >&lt;p&gt;I&apos;m not worried about in-JVM access, so GC and such isn&apos;t germane.  However, serializations that include those cleartext credentials are an easy attack vector, especially for apps with clustered sessions.  The notion of &quot;full control of the environment&quot; could be used as an argument for storing cleartext passwords in one&apos;s database, too, so I don&apos;t think that&apos;s much of a justification.&lt;/p&gt;

&lt;p&gt;A couple of key questions:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Are credentials required by any authentication provider after authentication has succeeded?  If not, then there&apos;s no harm and unlimited upside by ensuring Authentication instances always have their credentials cleared post-authentication.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;If the answer to Q #1 is &apos;yes&apos;, then what would the harm be in ensuring that default form authentication machinery cleared users&apos; credentials post-authentication?&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="50323" author="luke" created="Tue, 19 Jan 2010 06:50:40 +0000"  >&lt;p&gt;Even if you aren&apos;t worried about in-memory JVM access, you would also need to guarantee that your OS doesn&apos;t page the memory to disk, or that it uses a secure swap space. If people have direct access to the areas of the disk where your sessions are serialized then that is a problem. They will probably be able to directly hijack user sessions, for example, by reading the session data. In practice, replicated session clustering is not heavily used. Sticky-session load-balancer configurations are much more common and the problem is again about limiting local access. &lt;/p&gt;

&lt;p&gt;I think we should provide some ability to allow passwords to be discarded after authentication if they are not required. This is more a defence-in-depth feature though, I don&apos;t think it is a bug. Making it the default behaviour immediately would break things for users who are currently relying on the status quo - for example, the ability to set the &quot;authenticated&quot; flag to false on an Authentication and have it transparently reauthenticated by the security interceptor.&lt;/p&gt;</comment>
                            <comment id="50736" author="cemerick" created="Tue, 2 Feb 2010 04:37:10 +0000"  >&lt;p&gt;Leaving aside the semantics of enhancement vs. bug, I think that is totally backwards thinking.  The point is, security breaches are hardly uncommon, so one has to assume that an attacker will have access to serialized sessions on disk or in the database (consider JDBC session stores, etc).  That&apos;s bad enough for a single organization, but I&apos;d think the last thing you want to have happen is for all of a site&apos;s users to have their cleartext passwords floating out there because a spring-security user&apos;s systems were compromised.  Just to illustrate the nightmare scenario: &lt;a href=&quot;http://www.theregister.co.uk/2009/12/16/rockyou_password_snafu/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.theregister.co.uk/2009/12/16/rockyou_password_snafu/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This is why we hash and salt passwords to begin with, but the current issue makes repeats of events like the one linked above &lt;b&gt;inevitable&lt;/b&gt;.&lt;/p&gt;

&lt;p&gt;I&apos;m not familiar with the concrete counter-use-case you describe, but thinking about this more brings me to the position that the risk and potentially massive consequences of allowing user passwords to be stored in cleartext in any circumstance should outweigh any other consideration.&lt;/p&gt;

&lt;p&gt;Cheers,&lt;/p&gt;

&lt;p&gt;/me trying to not jump up and down &lt;img class=&quot;emoticon&quot; src=&quot;https://jira.spring.io/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="55326" author="luke" created="Tue, 29 Jun 2010 05:21:01 +0000"  >&lt;p&gt;The ability to clear credentials post-authentication is now supported following the work done for &lt;a href=&quot;https://jira.spring.io/browse/SEC-1493&quot; title=&quot;Add support for erasing credentials after authentication&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SEC-1493&quot;&gt;&lt;del&gt;SEC-1493&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="124285" author="issuemaster" created="Sat, 6 Feb 2016 06:13:24 +0000"  >&lt;p&gt;This issue has been migrated to &lt;a href=&quot;https://github.com/spring-projects/spring-security/issues/1616&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/spring-projects/spring-security/issues/1616&lt;/a&gt;&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10000">
                    <name>Duplicate</name>
                                                                <inwardlinks description="is duplicated by">
                                        <issuelink>
            <issuekey id="29881">SEC-1394</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10130">
                    <name>Supersede</name>
                                                                <inwardlinks description="is superseded by">
                                        <issuelink>
            <issuekey id="31597">SEC-1493</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_10170" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>First Response Date</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 19 Jan 2010 04:41:11 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10280" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>19580</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10880" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i03tnj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10380" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>22346</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10381" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Ranking</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3681</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_10171" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>