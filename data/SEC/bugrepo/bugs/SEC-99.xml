<!-- 
RSS generated by JIRA (6.4.11#64026-sha1:78f6ec473a3f058bd5d6c30e9319c7ab376bdb9c) at Fri Dec 23 11:49:29 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://jira.spring.io/si/jira.issueviews:issue-xml/SEC-99/SEC-99.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>Spring JIRA</title>
    <link>https://jira.spring.io</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.4.11</version>
        <build-number>64026</build-number>
        <build-date>25-08-2015</build-date>
    </build-info>

<item>
            <title>[SEC-99] MethodDefinitionMap must support superclass declared methods</title>
                <link>https://jira.spring.io/browse/SEC-99</link>
                <project id="10040" key="SEC">Spring Security</project>
                    <description>&lt;p&gt;As reported by Tom Dunstan, MethodDefinitionMap line 168 by default will only locate methods declared for the class, and not for superclasses (ie uses clazz.getMethods() instead of clazz.getDeclaredMethods()). Whilst this is consistent with Spring&apos;s transaction handling, it does present an issue for those relying on generic superclasses and wanting to define authorization configuration attributes against them. It is proposed to add a new keyword to the property editor to direct MethodDefinitionMap to use getDeclaredMethods() vs getMethods(), such that by default the existing behaviour is preserved (to be consistent with transaction services) but the superclass search behaviour can be used instead. Alternatively, we could introduce an optional prefix the method name, such as &quot;+&quot;, which denotes &quot;locate the matching methods in the superclass&quot;. This would have the added advantage of ensuring only patterns where you deliberately want to use getDeclaredMethods() will use that method.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12726">SEC-99</key>
            <summary>MethodDefinitionMap must support superclass declared methods</summary>
                <type id="4" iconUrl="https://jira.spring.io/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="3" iconUrl="https://jira.spring.io/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://jira.spring.io/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="balex">Ben Alex</assignee>
                                    <reporter username="balex">Ben Alex</reporter>
                        <labels>
                    </labels>
                <created>Mon, 14 Nov 2005 14:27:20 +0000</created>
                <updated>Sat, 6 Feb 2016 06:38:49 +0000</updated>
                            <resolved>Mon, 24 Mar 2008 11:45:11 +0000</resolved>
                                                    <fixVersion>2.0.0 RC1</fixVersion>
                                    <component>Core</component>
                        <due></due>
                            <votes>3</votes>
                                    <watches>7</watches>
                                                                <comments>
                            <comment id="15416" author="tomd" created="Mon, 14 Nov 2005 17:09:55 +0000"  >&lt;p&gt;I like both approaches for different scenarios, although if given the choice I&apos;d probably use the global one in our current project, since almost all the manager classes that we are applying security to have generic superclasses.&lt;/p&gt;

&lt;p&gt;Having had a wander through this code when i was trying to work out what was going on, I also noticed that there was a place where we seemed to be going the other way... getting the interfaces associated with the method invocation. Just looking now, the only thing that I can find is in MethodDefinitionMap.lookupAttributes(). Note that we look for the declared methods in there, and that in particular the way that we look is by asking for the declared method with the same parameter types. These may be different for a generic subinterface or class with the generic parameter filled, as while the type on the interface method may be Object or PersistableEntity or whatever, the concrete subinterface or implementing class my have filled the parameter to String or some domain object or whatever. I&apos;m not exactly sure what that code does, but I would think that it probably needs to be handled there as well. &lt;/p&gt;

&lt;p&gt;Hmm, also note that calling getInterfaces() only gets the direct parent interfaces, it doesn&apos;t walk the whole tree, so you might want to split that bit out into a method that can be called recursively, or add parent interfaces to a queue as you go or something like that.&lt;/p&gt;

&lt;p&gt;Anyway, I like the general approach (since I suggested it &lt;img class=&quot;emoticon&quot; src=&quot;https://jira.spring.io/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; ), but we might want to be careful to make sure that there aren&apos;t any other places that assume that they can deal with just the direct methods or methods on the directly declared interfaces.&lt;/p&gt;</comment>
                            <comment id="15533" author="balex" created="Thu, 24 Nov 2005 13:24:20 +0000"  >&lt;p&gt;I&apos;ve spent a while looking through the current code and have concluded that substantial refactoring of MethodDefinitionMap is going to be required to accommodate this request. The lookupAttributes(Method) method for instance will need to use Class.getMethods() for each interface and compare each located method&apos;s arguments with the supertypes of the present invocation&apos;s argument types. In addition, searching for superclass methods and registering located methods has issues because Method is used internally by the Map, and this is deliberate as lookupAttributes(Method) will walk the inheritence tree to add each interface&apos;s methods that match the present invocation. Some consideration will also need to be given to which definition takes priority if two interfaces define attributes the same method, which causes compounded confusion when the methods have different arguments but arguments that share a common type hierarchy. I wish there was a simple way of resolving this issue, but whatever we do would inevitibly break backward compatibility and represent a risk as we try to get 1.0.0 out. A more substantial refactoring of MethodDefinitionMap might be in order, particularly if it also allowed arguments to be declared. eg com.foo.ManagerImpl(org.foo.Person)=ROLE_FOO&lt;/p&gt;

&lt;p&gt;The workaround for today is to declare all methods that require authorization in the subclasses, and then declare the signatures for authorization purposes. &lt;/p&gt;

&lt;p&gt;If someone wants to contribute a new subclass of AbstractMethodDefinitionSource that provides a solution to this issue please attach it to this task.&lt;/p&gt;</comment>
                            <comment id="25736" author="asenft" created="Mon, 27 Aug 2007 17:01:21 +0000"  >
&lt;p&gt;Attached a patched version of MethodDefinitionMap. Instead of directly mapping to a method I introduced a MethodDescriptor class that allows for patterns and also supports the specification of argument types and considers inherited methods.&lt;br/&gt;
Also merging of attribute definitions is factored out into a pluggable strategy.&lt;br/&gt;
Tests are included as well.&lt;/p&gt;

&lt;p&gt;Regards,&lt;br/&gt;
Andreas&lt;/p&gt;</comment>
                            <comment id="33824" author="balex" created="Mon, 24 Mar 2008 11:45:11 +0000"  >&lt;p&gt;I have substantially refactored method security metadata services. Declarations against inherited methods, declared methods on both interfaces and target classes are fully supported. A common superclass, AbstractFallbackMethodDefinitionSource, has also been introduced for all method metadata services (Spring/Commons Attributes, JSR 250, @Secured, XML-based). Various improvements to the namespaces have also occurred to augment this refactoring.&lt;/p&gt;

&lt;p&gt;See the JavaDocs for AbstractFallbackMethodDefinitionSource for order in which method metadata is queried for further details.&lt;/p&gt;

&lt;p&gt;Tests were amended, checked in, and pass.&lt;/p&gt;</comment>
                            <comment id="127016" author="issuemaster" created="Sat, 6 Feb 2016 06:38:49 +0000"  >&lt;p&gt;This issue has been migrated to &lt;a href=&quot;https://github.com/spring-projects/spring-security/issues/360&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/spring-projects/spring-security/issues/360&lt;/a&gt;&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10011">
                    <name>Depends</name>
                                                                <inwardlinks description="is depended on by">
                                        <issuelink>
            <issuekey id="15928">SEC-428</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10000">
                    <name>Duplicate</name>
                                                                <inwardlinks description="is duplicated by">
                                        <issuelink>
            <issuekey id="15851">SEC-424</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="14997">SEC-353</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10020">
                    <name>Related</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="21291">SEC-734</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12828" name="sec-99.zip" size="21003" author="asenft" created="Mon, 27 Aug 2007 17:01:21 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_10170" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>First Response Date</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 14 Nov 2005 17:09:55 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10280" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>20727</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10880" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i04ndr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10380" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>27162</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10381" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Ranking</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>21811</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_10171" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>