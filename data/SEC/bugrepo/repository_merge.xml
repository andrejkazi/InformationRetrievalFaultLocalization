<?xml version = "1.0" encoding = "UTF-8" ?>
<bugrepository name="SEC">
	<bug id="1" master="3020" duplicate="3035" opendate="2015-06-26 08:22:36" fixdate="2015-07-16 12:34:02" resolution="Complete">
		<buginformation>
			<summary>HttpServletRequest.isUserInRole("ROLE_&lt;anything&gt;") returns false with defaults SecurityContextHolderAwareRequestWrapper#isUserInRole adds role prefix to already prefixed role</summary>
			<description>I&amp;amp;apos;m just trying to upgrade from Spring Security 3.1 to 4.0.1 and have discovered a breaking change in the behaviour of request.isUserInRole().
In Spring 3.1 the following was returning true and now returns false:
request.isUserInRole("ROLE_REMEMBER_ME")
In Spring 4.0.1 I had to change it to the following:
request.isUserInRole("REMEMBER_ME") SecurityContextHolderAwareRequestWrapper#isUserInRole adds role prefix even if passed role already has one.
Currently calling request.isUserInRole("ROLE_ADMIN") fails because ROLE_ADMIN becomes ROLE_ROLE_ADMIN in SecurityContextHolderAwareRequestWrapper#isGranted method.</description>
			<version>4.0.1</version>
			<fixedVersion>4.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestWrapperTests.java</file>
			<file type="M">org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestWrapper.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">3035</link>
			<link type="Duplicate" description="is duplicated by">3055</link>
			<link type="Relate" description="relates to">2926</link>
			<link type="Duplicate" description="duplicates">3020</link>
		</links>
	</bug>
	<bug id="2" master="1413" duplicate="1385" opendate="2010-01-24 21:22:54" fixdate="2010-08-10 13:21:15" resolution="Complete">
		<buginformation>
			<summary>AbstractRetryEntryPoint should use RedirectStrategy AbstractRetryEntryPoint should use DefaultRedirectStrategy for redirects to support proxies</summary>
			<description>For consistency, AbstractRetryEntryPoint should probably use RedirectStrategy as implemented in SEC-1226. Possible use cases include URL pre-processing, which users might want consistently applied.
Let me know if you agree and I am happy to supply a patch. The AbstractRetryEntryPoint builds the redirect url for the redirect itself in its commence method. The problem is, that the context-path is always used.
If you run your application through a proxy with a change of the path, than the redirects leeds to a wrong url.
Example:
The app is deployed on Tomcat as ajp://localhost:8009/app1 and is accessed via a apache proxy through http://yourdomain.com/. The redirect url of a secured resource /resource.html will be http://yourdomain.com/app1/resource.html instead of the correct one http://yourdomain.com/resource.html.
Other parts of Spring Security are using the DefaultRedirectStrategy, which works as expected when setting the contextRelative to true.
I think if the AbstractRetryEntryPoint uses the same convention (DefaultRedirectStrategy), then the problem with the http-&amp;gt;https redirect in DefaultRedirectStrategy (see comment on the class) will also be fixed.
As a workaround we implemented our own RetryWithHttpsEntryPoint, which processes the contextRelative flag, and it works. But this is heavily to configure, because you cannot use the namespace configuration any more.
https://fisheye.springsource.org/browse/spring-security/web/src/main/java/org/springframework/security/web/access/channel/AbstractRetryEntryPoint.java</description>
			<version>3.0.1</version>
			<fixedVersion>3.1.0.M1</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.access.channel.RetryWithHttpEntryPointTests.java</file>
			<file type="M">org.springframework.security.web.access.channel.AbstractRetryEntryPoint.java</file>
			<file type="M">org.springframework.security.web.access.channel.RetryWithHttpsEntryPointTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1385</link>
			<link type="Related" description="is related to">1500</link>
			<link type="Duplicate" description="duplicates">1413</link>
		</links>
	</bug>
	<bug id="3" master="925" duplicate="1224" opendate="2008-07-16 05:43:27" fixdate="2009-09-30 05:32:23" resolution="Fixed">
		<buginformation>
			<summary>BasicLookupStrategy - support for schema qualifier BasicLookupStrategy, JdbcAclService, and JdbcMutableAclService should support Catalog and Schema</summary>
			<description>The current impl of this class works great - I would like to avoid writing my own custom strategy wherever possible.  The JavaDocs for BasicLookupStrategy state that it&amp;amp;apos;s not design for extension which I understand.
It would be great, however, if a property could be set in the bean config that would allow the referenced tables in the SQL to be qualified by a schema.  Projects often run into such requirements based on the conventions used by a DBA group.  In our particular case, we&amp;amp;apos;re using DB2 and the ACL tables are being created in a schema that is not the default schema. Some systems may have security objects and normal application objects seperated in to different domains, and those domains may be defined in different database catalogs and/or schemas.
The BasicLookupStrategy, JdbcAclService, and JdbcMutableAclService classes should account for a database catalog and schema.  A developer and/or integrator should be able to specify the catalog and schema for said classes when defining the beans in their context configurations.</description>
			<version>2.0.3</version>
			<fixedVersion>3.0.0 RC1</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.jdbc.JdbcAclService.java</file>
			<file type="M">org.springframework.security.acls.jdbc.JdbcMutableAclService.java</file>
			<file type="M">org.springframework.security.acls.jdbc.BasicLookupStrategy.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1224</link>
			<link type="Duplicate" description="is duplicated by">1308</link>
			<link type="Duplicate" description="duplicates">925</link>
		</links>
	</bug>
	<bug id="4" master="328" duplicate="341" opendate="2006-07-27 19:49:15" fixdate="2006-09-14 14:37:09" resolution="Fixed">
		<buginformation>
			<summary>AbstractUserDetailsAuthenticationProvider makes two hits when no cache is used Retrieving User after AuthenticationException</summary>
			<description>if you look at AbstractUserDetailsAuthenticationProvider.authenticate, you&amp;amp;apos;ll notice that in case of failure, Acegi suppose that it is due to a cache synchronization problem and make a second retrieveUser.
But if you use no cache, your information were already up to date and retrieveUser is still called...
I think that this snippet (l. 148-151):
 // There was a problem, so try again after checking we&amp;amp;apos;re using latest data
cacheWasUsed = false;
user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication);
additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication);
has to be changed to that :
if(cacheWasUsed) 
{
            // There was a problem, so try again after checking we&amp;amp;apos;re using latest data
            cacheWasUsed = false;
            user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication);
            additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication);
 }
 else {
            throw exception
}
It&amp;amp;apos;ll avoid an useless double check... In AbstractUserDetailsAuthenticationProvider the authenticate() method calls the additionalAuthenticationChecks() method in a try block and can catch an AuthenticationException.  The code in the catch block (line 147 for rel 1.0.1) calls the retrieveUser() and additionalAuthenticationChecks() methods.  If the user details used for the call in the try block came from the cache, I understand why this makes sense.  However, if cacheWasUsed is false, the call to retrieve the user details obtains the exact same user details.
Perhaps the catch block should only repeat those method calls if cacheWasUsed is true, and throws the caught AuthenticationException if cacheWasUsed is false.</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.providers.dao.AbstractUserDetailsAuthenticationProvider.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">350</link>
			<link type="Duplicate" description="is duplicated by">341</link>
			<link type="Duplicate" description="duplicates">328</link>
		</links>
	</bug>
	<bug id="5" master="2897" duplicate="2895" opendate="2015-03-04 14:57:47" fixdate="2015-03-20 13:43:23" resolution="Fixed">
		<buginformation>
			<summary>ActiveDirectoryLdapAuthenticationProvider should use bindPrincipal not username Active Directory based configuration no longer works in 3.2.6</summary>
			<description>Shouldn&amp;amp;apos;t the lines
return SpringSecurityLdapTemplate.searchForSingleEntryInternal(context, searchControls,
                   searchRoot, searchFilter, new Object[]
{username}
);
actually be
return SpringSecurityLdapTemplate.searchForSingleEntryInternal(context, searchControls,
                   searchRoot, searchFilter, new Object[]
{bindPrincipal}
);
?
This currently breaks our authentication. Hi. I upgraded to org.springframework.security:spring-security-ldap:3.2.6.RELEASE to authenticate users against my ldap server.
Config yml:






ldap:




  domain: myldapdomain.net




  url: ldaps://172.XX.X.XX:690






Spring boot groovy config:






@Configuration




@EnableWebMvcSecurity




public class WebSecurityConfig extends WebSecurityConfigurerAdapter {









   @Value(&amp;amp;apos;${ldap.domain}&amp;amp;apos;)




   private String DOMAIN




   @Value(&amp;amp;apos;${ldap.url}&amp;amp;apos;)




   private String URL




...









   @Override




   protected void configure(AuthenticationManagerBuilder authManagerBuilder) throws Exception {




      authManagerBuilder.authenticationProvider(activeDirectoryLdapAuthenticationProvider())




            .userDetailsService(userDetailsService())




   }









   @Bean




   public AuthenticationManager authenticationManager() {




      return new ProviderManager(Arrays.asList(activeDirectoryLdapAuthenticationProvider()))




   }









   @Bean




   public AuthenticationProvider activeDirectoryLdapAuthenticationProvider() {




      ActiveDirectoryLdapAuthenticationProvider provider =




            new ActiveDirectoryLdapAuthenticationProvider(DOMAIN, URL)




      provider.setConvertSubErrorCodesToExceptions(true)




      provider.setUseAuthenticationRequestCredentials(true)




      return provider




   }




}






With 2.3.5 I can type only my AD username, and this works.
With 2.3.6, using only my AD username I get this message in the logs, and fails:






javax.naming.PartialResultException: Unprocessed Continuation Reference(s); remaining name &amp;amp;apos;dc=myldapdomain,dc=net&amp;amp;apos;






If, however, I login as myuser@myldapdomain.net I can login correctly.
Is there a new configuration parameter I should set? Thanks!</description>
			<version>3.2.6</version>
			<fixedVersion>3.2.7, 4.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ldap.authentication.ad.ActiveDirectoryLdapAuthenticationProviderTests.java</file>
			<file type="M">org.springframework.security.ldap.authentication.ad.ActiveDirectoryLdapAuthenticationProvider.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">2895</link>
			<link type="Duplicate" description="is duplicated by">2900</link>
			<link type="Relate" description="is related to">1915</link>
			<link type="Duplicate" description="duplicates">2897</link>
		</links>
	</bug>
	<bug id="6" master="1968" duplicate="1958" opendate="2012-05-04 02:07:52" fixdate="2012-07-12 06:04:05" resolution="Fixed">
		<buginformation>
			<summary>PreAuthenticatedProcessingFilter does not clear out the security context causing user to unintentionally remain authenticated authentication successful even if it&amp;apos;s not in AbstractPreAuthenticatedProcessingFilter</summary>
			<description>When the pre-authenticated user is null, the previously authenticated user&amp;amp;apos;s security context remains, and as such, the previous user remains authenticated.
It seems like the AbstractPreAuthenticatedProcessingFilter should clear out the security context in doAuthenticate if the principal is null.  I can override the getPreAuthenticatedPrincipal call to do this (if I return  null for the principal), but it seems that this is not something the user should have to manage.  And, it seems like a side-effect / hack to put something like that in a method that should just be getting the principal, and doAuthenticate itself is private.  This is dangerous because later in the chain, in AbstractSecurityInterceptor.beforeInvocation(Object object) the security context is not null, even though it should be, and so, no exception is thrown from:
        if (SecurityContextHolder.getContext().getAuthentication() == null) 
{
            credentialsNotFound(messages.getMessage("AbstractSecurityInterceptor.authenticationNotFound",
                    "An Authentication object was not found in the SecurityContext"), object, attributes);
        }

It could also possibly be argued that the security context should be cleared in AbstractPreAuthenticatedFilter.requiresAuthentication in the session invalidation on a principal change - namely in here:
        if (invalidateSessionOnPrincipalChange) {
            HttpSession session = request.getSession(false);
            if (session != null) 
{
                logger.debug("Invalidating existing session");
                session.invalidate();
                request.getSession();
            }
        }
I have attached a test application that demonstrates this in the simplest format I could come up with. Basically the pre-authentication occurs by grabbing a username from a request parameter, and then it displays the logged in user&amp;amp;apos;s username on the home page.
So if I go to http://localhost:8080/security/?username=bob the application will display &amp;amp;apos;Hello bob&amp;amp;apos;.  If I hit http://localhost:8080/security/?username=jimi, it will switch to saying &amp;amp;apos;Hello jimi&amp;amp;apos;, but if I do http://localhost:8080/security/?username= it will remain at &amp;amp;apos;Hello jimi&amp;amp;apos; (or whatever the previously authenticated user was), instead of requiring authentication.
However, if in getPreAuthenticatedPrincipal() I call SecurityContextHolder.clearContext(), then hitting http://localhost:8080/security/?username= will result in taking me to the login page which I think is the desired behavior if the user is not pre-authenticated - indicated by getPreAuthenticatedPrincipal() returning null. Consider scenario using AbstractPreAuthenticatedProcessingFilter with setCheckForPrincipalChanges(true).
1. on first page request authentication is successful and everything is ok
2. on next page request authentication failed, getPreAuthenticatedPrincipal returns null. Method doAuthenticate in current implementation does this:






        if (principal == null) {




            if (logger.isDebugEnabled()) {




                logger.debug("No pre-authenticated principal found in request");




            }









            return;




        }






This means that no AuthenticationException is raised and no check to continueFilterChainOnUnsuccessfulAuthentication is made.</description>
			<version>3.1.0</version>
			<fixedVersion>3.0.8, 3.1.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilterTests.java</file>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1958</link>
			<link type="Duplicate" description="duplicates">1968</link>
		</links>
	</bug>
	<bug id="7" master="2697" duplicate="2727" opendate="2014-08-07 03:28:01" fixdate="2014-09-26 07:11:30" resolution="Complete">
		<buginformation>
			<summary>Invalid warning logged when using Spring 3.2.10.RELEASE Spring security version check reports incorrectly.</summary>
			<description>I&amp;amp;apos;m using Spring Framework (version 3.2.10.RELEASE).
During application startup I&amp;amp;apos;m getting following warning:

org.springframework.security.core.SpringSecurityCoreVersion - **** You are advised to use Spring 3.2.8.RELEASE or later with this version. You are running: 3.2.10.RELEASE
It seems that versions are compared using String.compareTo().
Using this method "3.2.10.RELEASE" is lower then "3.2.8.RELEASE". When using spring core version 3.2.10 or greater the spring security version check reports a warning message about minimum version incorrectly.
To recreate run spring core 3.2.11 with spring security 3.2.4.
The issue is in the compare statement of:






if (springVersion.compareTo(MIN_SPRING_VERSION) &amp;lt; 0) {




     logger.warn("**** You are advised to use Spring " + MIN_SPRING_VERSION +  " or later with this version. You are running: " + springVersion);




}





</description>
			<version>3.2.4</version>
			<fixedVersion>3.2.5, 4.0.0.M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.core.SpringSecurityCoreVersionTests.java</file>
			<file type="M">org.springframework.security.core.SpringSecurityCoreVersion.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">2727</link>
			<link type="Duplicate" description="duplicates">2697</link>
		</links>
	</bug>
	<bug id="8" master="1868" duplicate="1934" opendate="2011-12-14 03:37:05" fixdate="2012-03-17 09:46:08" resolution="Fixed">
		<buginformation>
			<summary>SecurityNamespaceHandler should not log an error if the web classes are not available NamspaceHandler logs error if web module not present</summary>
			<description>Currently the SecurityNamespaceHandler logs an error if the FilterChainProxy is not available on the classpath.
This should be turned back to an if instead of a try/catch and it should definitely not log an error message  The SecurityNamespaceHandler in the config module tries to load FilterChainProxy (which it probably shouldn&amp;amp;apos;t anyway?) although one might not have included the Spring Security web module as one might only want to use global methd security in the first place. The pom.xml of the config module actually states the web module to be optional but apparently the code is not.
Of course Spring Security works just fine without the web module present but logging an error is at least irritating then.</description>
			<version>3.1.0</version>
			<fixedVersion>3.1.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.SecurityNamespaceHandler.java</file>
			<file type="M">org.springframework.security.config.SecurityNamespaceHandlerTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1934</link>
			<link type="Duplicate" description="duplicates">1868</link>
		</links>
	</bug>
	<bug id="9" master="2045" duplicate="2101" opendate="2012-09-06 11:28:44" fixdate="2012-12-27 13:19:49" resolution="Fixed">
		<buginformation>
			<summary>AbstractAuthorizeTag cannot specify which WebInvocationPrivilegeEvaluator AbstractAuthorizeTag.getPrivilegeEvaluator() always returns first WebInvocationPrivilegeEvaluator found</summary>
			<description>AbstractAuthorizeTag uses the first WebInvocationPrivilegeEvaluator which causes problems when evaluating the url attribute and having multiple &amp;lt;http&amp;gt; elements. When using the authorize tag like this:






&amp;lt;sec:authorize method="POST" url="/data/hosts"&amp;gt;....&amp;lt;/sec:authorize&amp;gt;






...the AbstractAuthorizeTag.getPrivilegeEvaluator() method is requested to return an evaluator. But this method will always return the first it finds even if more than one is found. This is especially a problem if one or more of the &amp;amp;apos;sections&amp;amp;apos; of privileges are aimed at something else than a HTML access(fx. JSON API).
I have this in my springsecuritycontext.xml:






&amp;lt;http request-matcher-ref="jsonMatcher" create-session="stateless" authentication-manager-ref="apiAuthMgr"&amp;gt;




        &amp;lt;intercept-url pattern="/data/**" access="ROLE_API_USER" /&amp;gt;




        &amp;lt;http-basic /&amp;gt;




    &amp;lt;/http&amp;gt;




    




    &amp;lt;http authentication-manager-ref="siteAuthMgr"&amp;gt;




        &amp;lt;intercept-url  method="PUT" pattern="/data/**" access="ROLE_IT-infrastruktur" /&amp;gt;




        &amp;lt;intercept-url  method="POST" pattern="/data/**" access="ROLE_IT-infrastruktur" /&amp;gt;




        &amp;lt;intercept-url  method="DELETE" pattern="/data/**" access="ROLE_IT-infrastruktur" /&amp;gt;




        &amp;lt;intercept-url  method="GET" pattern="/data/credentials**" access="ROLE_IT-infrastruktur" /&amp;gt;




        &amp;lt;form-login/&amp;gt;




    &amp;lt;/http&amp;gt;




.......






This work flawlessly in regards to using the correct authentication-manager based on the request-matcher, but when it comes to the authorize-tag it will always try to match on the first section, because AbstractAuthorizeTag.getPrivilegeEvaluator() always returns the first one:






private WebInvocationPrivilegeEvaluator getPrivilegeEvaluator() throws IOException {




        ApplicationContext ctx = WebApplicationContextUtils.getRequiredWebApplicationContext(getServletContext());




        Map&amp;lt;String, WebInvocationPrivilegeEvaluator&amp;gt; wipes = ctx.getBeansOfType(WebInvocationPrivilegeEvaluator.class);









        if (wipes.size() == 0) {




            throw new IOException(




                    "No visible WebInvocationPrivilegeEvaluator instance could be found in the application "




                            + "context. There must be at least one in order to support the use of URL access checks in &amp;amp;apos;authorize&amp;amp;apos; tags.");




        }









        return (WebInvocationPrivilegeEvaluator) wipes.values().toArray()[0];   &amp;lt;---- PROBLEM (Line 340)




    }





</description>
			<version>3.1.2</version>
			<fixedVersion>3.1.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.WebAttributes.java</file>
			<file type="M">org.springframework.security.taglibs.authz.AbstractAuthorizeTag.java</file>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilterTests.java</file>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">2101</link>
			<link type="Duplicate" description="is duplicated by">3073</link>
			<link type="Duplicate" description="is duplicated by">2045</link>
		</links>
	</bug>
	<bug id="10" master="422" duplicate="467" opendate="2007-01-02 22:02:11" fixdate="2008-04-05 09:17:29" resolution="Fixed">
		<buginformation>
			<summary>BasicLookupStrategy - computeRepeatingSql contains bad SQL New Acl package not compatible with Mysql Db</summary>
			<description>The line
+ "ACL_OBJECT_IDENTITY,ENTRIES_INHERITING, "
should be
+ "ACL_OBJECT_IDENTITY.ENTRIES_INHERITING, " (notice the dot instead of comma) The sql statements JdbcAclService and JdbcMutableAclService are only compatible with hsqlDb but not with other DBs e.g. mysql. the "call identity()" for example query must be "SELECT LAST_INSERT_ID()" in mysql dialect.
So it would be great if you could access the ...Query properties via setter-methods and configure JdbcMutableAclService via spring beans xml.
also have a look at this thread please:
http://forum.springframework.org/archive/index.php/t-34222.html
thank you</description>
			<version>1.0.4</version>
			<fixedVersion>2.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.jdbc.JdbcMutableAclService.java</file>
			<file type="M">org.springframework.security.acls.jdbc.BasicLookupStrategy.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">467</link>
			<link type="Duplicate" description="duplicates">422</link>
		</links>
	</bug>
	<bug id="11" master="2543" duplicate="2570" opendate="2014-04-02 10:08:49" fixdate="2014-05-02 09:31:05" resolution="Fixed">
		<buginformation>
			<summary>Logout Does Not Require POST even though CSRF is enabled LogoutConfigurer supports GET by default when CSRF is enabled</summary>
			<description>The documentation says "Adding CSRF will update the LogoutFilter to only use HTTP POST. This ensures that log out requires a CSRF token and that a malicious user cannot forcibly log out your users.": http://docs.spring.io/spring-securit...e/#csrf-logout
However, in my testing, I can still logout with a GET to /logout using the following Java-based security configuration:






SecurityConfig.java






@Configuration




@EnableWebMvcSecurity




public class SecurityConfig extends WebSecurityConfigurerAdapter {




    @Override




    protected void configure(final AuthenticationManagerBuilder auth)




            throws Exception {




        auth.inMemoryAuthentication()//




                .withUser("user").password("password").roles("USER")//




                .and()//




                .withUser("admin").password("password").roles("USER", "ADMIN");




    }









    @Override




    protected void configure(final HttpSecurity http) throws Exception {




        http.authorizeRequests()//




                .antMatchers("/admin/**").hasRole("ADMIN")//




                .antMatchers("/**").permitAll().and()//




                .formLogin();




    }




}





 Since commit 5082a046 for SEC-2311, the default LogoutRequestMatcher supports all HTTP methods regardless of the CSRF configuration.
You can see in the LogoutConfigurer.java code below that a POST only matcher is created, but not used:






    @SuppressWarnings("unchecked")




    private RequestMatcher getLogoutRequestMatcher(H http) {




        if(logoutRequestMatcher != null) {




            return logoutRequestMatcher;




        }




        if(http.getConfigurer(CsrfConfigurer.class) != null) {




            this.logoutRequestMatcher = new AntPathRequestMatcher(this.logoutUrl, "POST");




        }




        return new AntPathRequestMatcher(this.logoutUrl);




    }





</description>
			<version>3.2.3</version>
			<fixedVersion>3.2.4, 4.0.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.configurers.LogoutConfigurer.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">2570</link>
			<link type="Duplicate" description="duplicates">2543</link>
		</links>
	</bug>
	<bug id="12" master="2919" duplicate="2949" opendate="2015-03-25 21:24:22" fixdate="2015-04-28 18:53:46" resolution="Fixed">
		<buginformation>
			<summary>DefaultLoginGeneratingFilter incorrectly used if login-url="/login" Custom Login not working in Spring 4.0</summary>
			<description>If an application specifies form-login@login-url="/login" then the DefaultLoginGeneratingFilter is incorrectly used. This means that the custom login page cannot be specified with the URL "/login". For example:






&amp;lt;http ...&amp;gt;




	&amp;lt;form-login login-page="/login" ... /&amp;gt;




&amp;lt;/http&amp;gt;






Workaround
Using a different URL
One workaround is to use a different URL for the login page. For example, one could use "/authenticate".
Using a BeanDefinitionRegistryPostProcessor
Alternatively, the following BeanDefinitionRegistryPostProcessor will fix the issue by removing the DefaultLoginPageGeneratingFilter. To use it simply ensure to register the BeanDefinitionRegistryPostProcessor as a Bean.






import java.util.Iterator;




import java.util.List;









import org.springframework.beans.BeansException;




import org.springframework.beans.factory.config.BeanDefinition;




import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;




import org.springframework.beans.factory.support.BeanDefinitionRegistry;




import org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor;




import org.springframework.security.web.DefaultSecurityFilterChain;




import org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter;









public class Sec2919PostProcessor implements BeanDefinitionRegistryPostProcessor {




	@Override




	public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)




			throws BeansException {




		String[] beanDefinitionNames = registry.getBeanDefinitionNames();




		for(String name : beanDefinitionNames) {




			BeanDefinition beanDefinition = registry.getBeanDefinition(name);




			if(beanDefinition.getBeanClassName().equals(DefaultSecurityFilterChain.class.getName())) {




				List&amp;lt;Object&amp;gt; filters = (List&amp;lt;Object&amp;gt;) beanDefinition.getConstructorArgumentValues().getArgumentValue(1, List.class).getValue();




				Iterator&amp;lt;Object&amp;gt; iFilters = filters.iterator();




				while(iFilters.hasNext()) {




					Object f = iFilters.next();




					if(f instanceof BeanDefinition) {




						BeanDefinition bean = (BeanDefinition) f;




						if(bean.getBeanClassName().equals(DefaultLoginPageGeneratingFilter.class.getName())) {




							iFilters.remove();




						}




					}




				}




			}




		}




	}









	@Override




	public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)




			throws BeansException {




	}




}





 i created a simple spring mvc project and added a custom login page. The custom login works fine with 3.2.7 but the same custom login does not work when i upgrade to 4.0.0.Release. </description>
			<version>4.0.0</version>
			<fixedVersion>4.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.AuthenticationConfigBuilder.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">2949</link>
			<link type="Duplicate" description="duplicates">2919</link>
		</links>
	</bug>
	<bug id="13" master="423" duplicate="461" opendate="2007-01-04 01:40:23" fixdate="2007-05-24 12:54:29" resolution="Fixed">
		<buginformation>
			<summary>CLONE -SEC 356 Introduces New Bug: Changes to Authentication leak into synchronous requests when using HttpSessionContextIntegrationFilter HttpSessionContextIntegrationFilter with cloneFromHttpSession = true causes problems at login</summary>
			<description>HttpSessionContextIntegrationFilter will read an existing SecurityContext object from the session and attach it to the Http request thread by calling: SecurityContextHolder#setContext. This means that simultaneous requests get the same SecurityContext object. If one of those threads changes the authentication attached to the context (for example, to enable some "Run As" functionality such as in org.acegisecurity.intercept.AbstractSecurityInterceptor) that authentication will be seen to change in all the request threads and may enable those threads to be able to gain access that they shouldn&amp;amp;apos;t have.
 The cloneFromHttpSession feature of the HttpSessionContextIntegrationFilter is fantastic - just what I needed, but it has a bug. 
On line 172, it checks to see if the clone feature is turned on and then asserts that the context from the session is an instance of Cloneable.  However, the context from the session might be null at this point.  The check for cloneFromHttpSession should be moved inside the next if() statement so that it only checks when the context in the session is non-null. </description>
			<version>1.0.3</version>
			<fixedVersion>1.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.context.HttpSessionContextIntegrationFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">461</link>
			<link type="Duplicate" description="duplicates">423</link>
		</links>
	</bug>
	<bug id="14" master="1885" duplicate="1911" opendate="2012-01-04 08:51:17" fixdate="2012-03-17 09:48:22" resolution="Complete">
		<buginformation>
			<summary>Adding &lt;debug/&gt; causes NoSuchMethodException when FilterChainProxy&amp;apos;s relies on beans that have Autowired Constructors &lt;security:debug/&gt; enables SecurityDebugBeanFactoryPostProcessor which ignores &lt;context:annotation-config/&gt;</summary>
			<description>An example would be if a configuration used &amp;lt;debug/&amp;gt; and a custom AuthenticationProvider or UserDetailsService which had an Autowired constructor one might get an exception similar to NoSuchMethodException MyCustomAuthenticationProvider.&amp;lt;init&amp;gt;()     &amp;lt;bean id="customBasedAuthenticationProvider" class="com.test.admin.auth.CustomBasedAuthenticationProvider"&amp;gt;
    	&amp;lt;property name="configBean" ref="annotationBean" /&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;context:annotation-config/&amp;gt;
    &amp;lt;security:debug/&amp;gt; 
     &amp;lt;security:authentication-manager&amp;gt;
        &amp;lt;security:authentication-provider ref="customBasedAuthenticationProvider"&amp;gt;
        &amp;lt;/security:authentication-provider&amp;gt;
    &amp;lt;/security:authentication-manager&amp;gt;

configBean

@Component("annotationBean")
@Scope(BeanDefinition.SCOPE_SINGLETON)
public class AnnotationConfigBean implements InitializingBean {
	@Autowired
	public AutowiredBean bean;
	/* (non-Javadoc)

@see org.springframework.beans.factory.InitializingBean#afterPropertiesSet()
	 */
	@Override
	public void afterPropertiesSet() throws Exception 
{
		if(bean==null)
			throw new RuntimeException("noconfigbean");
		
	}

}

autowiredBean

@Component
public class AutowiredBean {
}
when injecting  annotationBean into customBasedAuthenticationProvider the @Autowired AutowiredBean is not set on the annotationBean. This occurs only when  &amp;lt;security:debug/&amp;gt;  is enabled.</description>
			<version>3.1.0</version>
			<fixedVersion>3.1.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.util.InMemoryXmlApplicationContext.java</file>
			<file type="M">org.springframework.security.config.debug.SecurityDebugBeanFactoryPostProcessor.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1948</link>
			<link type="Duplicate" description="is duplicated by">1911</link>
			<link type="Duplicate" description="duplicates">1885</link>
		</links>
	</bug>
	<bug id="15" master="404" duplicate="464" opendate="2006-11-29 13:52:40" fixdate="2007-05-21 19:34:32" resolution="Fixed">
		<buginformation>
			<summary>Logout when not logged in cause NullPointerException NPE when missing &amp;apos;j_acegi_logout&amp;apos; when not logged in</summary>
			<description>When a user attempts to logout when they aren&amp;amp;apos;t logged in (e.g. when their session has expired) a NullPointerException occurs in TokenBasedRememberMeServices.logout(TokenBasedRememberMeServices.java:295).
The line that fails is:
        cancelCookie(request, response, "Logout of user " + authentication.getName());
I guess the cookie should still be cancelled, so the change might simply be to change the line to something like:
        cancelCookie(request, response, "Logout of user " + authentication == null ? "Unknown" : authentication.getName());
Regards,
Damien I receive a NPE Null PointerException when linking to &amp;amp;apos;j_acegi_logout&amp;amp;apos;:
    &amp;lt;a href="&amp;lt;c:url value="/j_acegi_logout"/&amp;gt;"&amp;gt;Logoff&amp;lt;/a&amp;gt;
when there is no user currently logged in
Here is the stack trace for the exception:
An Error has occurred in this application.
java.lang.NullPointerException
	at org.acegisecurity.ui.rememberme.TokenBasedRememberMeServices.logout(TokenBasedRememberMeServices.java:295)
	at org.acegisecurity.ui.logout.LogoutFilter.doFilter(LogoutFilter.java:98)
	at org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:274)
	at org.acegisecurity.context.HttpSessionContextIntegrationFilter.doFilter(HttpSessionContextIntegrationFilter.java:229)
	at org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:274)
	at org.acegisecurity.util.FilterChainProxy.doFilter(FilterChainProxy.java:148)
	at org.acegisecurity.util.FilterToBeanProxy.doFilter(FilterToBeanProxy.java:98)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:202)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:173)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:78)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:77)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:202)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:173)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:213)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:178)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:126)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:105)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:107)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:148)
	at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:869)
	at org.apache.coyote.http11.Http11BaseProtocol$Http11ConnectionHandler.processConnection(Http11BaseProtocol.java:664)
	at org.apache.tomcat.util.net.PoolTcpEndpoint.processSocket(PoolTcpEndpoint.java:527)
	at org.apache.tomcat.util.net.LeaderFollowerWorkerThread.runIt(LeaderFollowerWorkerThread.java:80)
	at org.apache.tomcat.util.threads.ThreadPool$ControlRunnable.run(ThreadPool.java:684)
	at java.lang.Thread.run(Thread.java:595)
My current workaround for the problem is to wrap the "logout" link with &amp;lt;authz/&amp;gt; tags:
    &amp;lt;authz:authorize ifAnyGranted="ROLE_USER,ROLE_ADMINISTRATOR"&amp;gt;
        &amp;lt;a href="&amp;lt;c:url value="/j_acegi_logout"/&amp;gt;"&amp;gt;Logoff&amp;lt;/a&amp;gt;
    &amp;lt;/authz:authorize&amp;gt;
which prevents the "Logoff" link from showing, but does not stop a user from manually entering the &amp;amp;apos;j_acegi_logout&amp;amp;apos; link themselves.
Here is the filterChainProxy config:
    &amp;lt;bean id="filterChainProxy" class="org.acegisecurity.util.FilterChainProxy"&amp;gt;
        &amp;lt;property name="filterInvocationDefinitionSource"&amp;gt;
            &amp;lt;value&amp;gt;
                CONVERT_URL_TO_LOWERCASE_BEFORE_COMPARISON
                PATTERN_TYPE_APACHE_ANT
                /images/**=#NONE#
                /scripts/**=#NONE#
                /styles/**=#NONE#
                /**=httpSessionContextIntegrationFilter,logoutFilter,authenticationProcessingFilter,securityContextHolderAwareRequestFilter,rememberMeProcessingFilter,anonymousProcessingFilter,exceptionTranslationFilter,filterInvocationInterceptor
            &amp;lt;/value&amp;gt;
            &amp;lt;!-- :TODO: Put channelProcessingFilter before securityContextHolderAwareRequestFilter to turn on SSL switching --&amp;gt;
            &amp;lt;!-- It&amp;amp;apos;s off by default b/c Canoo WebTest doesn&amp;amp;apos;t support SSL out-of-the-box --&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
Here is the logoutFilter config:
    &amp;lt;bean id="logoutFilter" class="org.acegisecurity.ui.logout.LogoutFilter"&amp;gt;
      &amp;lt;constructor-arg value="/"/&amp;gt; &amp;lt;!-- URL redirected to after logout --&amp;gt;
      &amp;lt;constructor-arg&amp;gt;
         &amp;lt;list&amp;gt;
              &amp;lt;ref bean="rememberMeServices"/&amp;gt;
              &amp;lt;bean class="org.acegisecurity.ui.logout.SecurityContextLogoutHandler"/&amp;gt;
         &amp;lt;/list&amp;gt;
      &amp;lt;/constructor-arg&amp;gt;
    &amp;lt;/bean&amp;gt;</description>
			<version>1.0.3</version>
			<fixedVersion>1.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.rememberme.TokenBasedRememberMeServices.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">433</link>
			<link type="Duplicate" description="is duplicated by">464</link>
			<link type="Duplicate" description="is duplicated by">407</link>
			<link type="Duplicate" description="duplicates">404</link>
		</links>
	</bug>
	<bug id="16" master="335" duplicate="494" opendate="2006-08-12 15:15:26" fixdate="2008-01-17 06:47:24" resolution="Fixed">
		<buginformation>
			<summary>Add Secure/InsecureChannelProcessor supporting attribute Add IgnoredChannelProcessor for org.acegisecurity.securechannel.ChannelDecisionManagerImpl</summary>
			<description>Most of my URLs fall into two categories: require security (REQUIRES_SECURE_CHANNEL) or require insecure (REQUIRES_INSECURE_CHANNEL). But I have a couple links which must support both HTTP/HTTPS and there is no way for me to express this exception. I recommend two new attributes:
SUPPORTS_INSECURE_CHANNEL
SUPPORTS_SECURE_CHANNEL
Then I can write my bean as follows:
&amp;lt;property name="filterInvocationDefinitionSource"&amp;gt;
  &amp;lt;value&amp;gt;
    CONVERT_URL_TO_LOWERCASE_BEFORE_COMPARISON 
    \A/secure/.*\Z=REQUIRES_SECURE_CHANNEL 
    \A/myspecialcase/*\Z=SUPPORTS_SECURE_CHANNEL
    \A.*\Z=REQUIRES_INSECURE_CHANNEL
  &amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt; when use ajax,switch http and https may cause cross domain exception.
I need:
in page  https://localhost:8443/account/login,dwr is https://localhost:8443/dwr/
in page http://localhost:8080/index,dwr is http://localhost:8080/dwr/
so I add a IgnoredChannelProcessor with key &amp;amp;apos;IGNORED_CHANNEL&amp;amp;apos;
CONVERT_URL_TO_LOWERCASE_BEFORE_COMPARISON
\A/struts/.*\Z=IGNORED_CHANNEL
\A/dwr/.*\Z=IGNORED_CHANNEL
\A/account/.*\Z=REQUIRES_SECURE_CHANNEL
\A/.*\Z=REQUIRES_INSECURE_CHANNEL
</description>
			<version>1.0.4</version>
			<fixedVersion>2.0.0 M2</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.securechannel.ChannelDecisionManagerImplTests.java</file>
			<file type="M">org.springframework.security.config.HttpSecurityBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.securechannel.ChannelDecisionManagerImpl.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">494</link>
			<link type="Duplicate" description="duplicates">335</link>
		</links>
	</bug>
	<bug id="17" master="1084" duplicate="1154" opendate="2009-01-21 01:19:20" fixdate="2009-05-06 20:03:00" resolution="Fixed">
		<buginformation>
			<summary>Retain Authentication.details when authenticating in LdapAuthenticationProvider LdapAuthenticationProvider.createSuccessfulAuthentication() returned object should include authentication.getDetails() if using useAuthenticationRequestCredentials</summary>
			<description>It seems that the LdapAuthenticationProvider looses any details set on the incomming Authentication.details property. Several other AuthenticationProviders retain these details
Unless of course this is intentional it should be trivial to improve this with simply copying the details, thus making them available to the application. 
Simple suggestion attached as patch. the createSuccessfulAuthentication(UsernamePasswordAuthenticationToken auth, UserDetails user) method from LdapAuthenticationProvider returns a new UsernamePasswordAuthenticationToken based on auth&amp;amp;apos;s password, depending on useAuthenticationRequestCredentials boolean.
In the case this happens, shouldn&amp;amp;apos;t the returned object also include auth.getDetails()? I.e., something like:
protected Authentication createSuccessfulAuthentication(UsernamePasswordAuthenticationToken authentication, UserDetails user)
{
  Object password = useAuthenticationRequestCredentials ? authentication.getCredentials() : ((Object) (user.getPassword()));
  if (useAuthenticationRequestCredentials)
  {
      UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken(user, password, user.getAuthorities());
      token.setDetails(authentication.getDetails());
      return token;
  }
  return new UsernamePasswordAuthenticationToken(user, password, user.getAuthorities());
}
(as part of our current project, we are building a custom authenticationProvider which extends LdapAuthenticationProvider, and we expected this behaviour. Not very sure this should be marked as bug or as an improvement, though)</description>
			<version>2.0.4</version>
			<fixedVersion>3.0.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ldap.authentication.LdapAuthenticationProvider.java</file>
			<file type="M">org.springframework.security.ldap.authentication.LdapAuthenticationProviderTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1154</link>
			<link type="Duplicate" description="duplicates">1084</link>
		</links>
	</bug>
	<bug id="18" master="1038" duplicate="1199" opendate="2008-11-25 18:55:32" fixdate="2009-08-23 00:12:54" resolution="Fixed">
		<buginformation>
			<summary>Error in JdbcMutableAclService with Postgres JdbcMutableAclService can&amp;apos;t create acl_object_identity entry in PostgreSQL</summary>
			<description>When I use the Spring Security&amp;amp;apos;s ACL services with a Postgres database, I am getting the following error when I call the createAcl method in the JdbcMutableAclService class  :
Caused by: org.postgresql.util.PSQLException: ERROR: column "object_id_identity" is of type bigint but expression is of type character varying
The problem is caused in the createObjectIdentity method by object.getIdentifier().toString() because the parameter is a string or the column is a bigint in the database. 
To solve the problem, you must cast to long : 
protected void createObjectIdentity(ObjectIdentity object, Sid owner) {
  Long sidId = createOrRetrieveSidPrimaryKey(owner, true);
  Long classId = createOrRetrieveClassPrimaryKey(object.getJavaType(), true);
  jdbcTemplate.update(insertObjectIdentity,
      new Object[] 
{classId, new Long(object.getIdentifier().toString()), sidId, new Boolean(true)}
);
}
There is a thread in the forum about this problem : http://forum.springframework.org/showthread.php?t=56889
Thomas The JdbcMutableAclService fails to create acl_object_identity entry in Postgresql, because it passes string as the object_id_identity where an integer (long) type is expected (in method JdbcMutableAclService.createObjectIdentity() ). 
The result is:
org.springframework.jdbc.BadSqlGrammarException: PreparedStatementCallback; bad SQL grammar [insert into acl_object_identity (object_id_class, object_id_identity, owner_sid, entries_inheriting) values (?, ?, ?, ?)]; nested exception is org.postgresql.util.PSQLException: ERROR: column "object_id_identity" is of type bigint but expression is of type character varying
  Hint: You will need to rewrite or cast the expression.
  Position: 51
	at org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslator.translate(SQLErrorCodeSQLExceptionTranslator.java:276)
	at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:607)
	at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:792)
	at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:850)
	at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:858)
	at org.springframework.security.acls.jdbc.JdbcMutableAclService.createObjectIdentity(JdbcMutableAclService.java:157)
	at org.springframework.security.acls.jdbc.JdbcMutableAclService.createAcl(JdbcMutableAclService.java:108)
</description>
			<version>2.0.5</version>
			<fixedVersion>3.0.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.springframework.security.acls.jdbc.AclPermissionInheritanceTests.java</file>
			<file type="M">org.springframework.security.acls.jdbc.JdbcMutableAclServiceTests.java</file>
			<file type="M">org.springframework.security.acls.jdbc.JdbcMutableAclService.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1199</link>
			<link type="Duplicate" description="duplicates">1038</link>
		</links>
	</bug>
	<bug id="19" master="1346" duplicate="1353" opendate="2009-12-29 12:17:09" fixdate="2010-01-06 07:26:21" resolution="Fixed">
		<buginformation>
			<summary>SessionManagementFilter: should "return;" after "redirectStrategy.sendRedirect(request, response, invalidSessionUrl);" SessionManagementFilter can invoke other filters after sending redirect</summary>
			<description>java.lang.IllegalStateException: Cannot create a session after the response has been committed
	org.apache.catalina.connector.Request.doGetSession(Request.java:2313)
	org.apache.catalina.connector.Request.getSession(Request.java:2074)
	org.apache.catalina.connector.RequestFacade.getSession(RequestFacade.java:833)
	org.apache.catalina.connector.RequestFacade.getSession(RequestFacade.java:844)
	javax.servlet.http.HttpServletRequestWrapper.getSession(HttpServletRequestWrapper.java:224)
	org.springframework.security.web.savedrequest.HttpSessionRequestCache.saveRequest(HttpSessionRequestCache.java:38)
	org.springframework.security.web.access.ExceptionTranslationFilter.sendStartAuthentication(ExceptionTranslationFilter.java:177)
	org.springframework.security.web.access.ExceptionTranslationFilter.handleException(ExceptionTranslationFilter.java:158)
	org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:118)
	org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:356)
	org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:95)
	org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:356)
	org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:79)
	org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:356)
	org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:55)
	org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:356)
	org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:36)
	org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:356)
	org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:188)
	org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:356)
	org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:106)
	org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:356)
	org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:80)
	org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:356)
	org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:150)
	org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:237)
	org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:167) SessionManagementFilter::doFilter() fails to stop request processing in branch "No security context or authentication present" (at SessionManagementFilter.java:89). More precisely, it does not return after calling redirectStrategy.sendRedirect(), but passes to the next filter.
This causes an error if there are controllers that define methods taking a HttpSession argument, because in this case AnnotationMethodHandlerAdapter attempts to call request.getSession(), which is not permitted after a redirect had been sent.</description>
			<version>3.0.0</version>
			<fixedVersion>3.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.concurrent.ConcurrentSessionFilterTests.java</file>
			<file type="M">org.springframework.security.web.session.SessionManagementFilter.java</file>
			<file type="M">org.springframework.security.web.util.UrlUtils.java</file>
			<file type="M">org.springframework.security.web.session.SessionManagementFilterTests.java</file>
			<file type="M">org.springframework.security.web.session.ConcurrentSessionFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1353</link>
			<link type="Duplicate" description="duplicates">1346</link>
		</links>
	</bug>
	<bug id="20" master="925" duplicate="1308" opendate="2008-07-16 05:43:27" fixdate="2009-11-30 08:11:03" resolution="Fixed">
		<buginformation>
			<summary>BasicLookupStrategy - support for schema qualifier Jdbc[Mutable]AclService  can allow (all) sql statements to be configured</summary>
			<description>The current impl of this class works great - I would like to avoid writing my own custom strategy wherever possible.  The JavaDocs for BasicLookupStrategy state that it&amp;amp;apos;s not design for extension which I understand.
It would be great, however, if a property could be set in the bean config that would allow the referenced tables in the SQL to be qualified by a schema.  Projects often run into such requirements based on the conventions used by a DBA group.  In our particular case, we&amp;amp;apos;re using DB2 and the ACL tables are being created in a schema that is not the default schema. I&amp;amp;apos;m providing a candidate patch for consideration. It&amp;amp;apos;s an enhancement to jdbc acl service that allows all sql statement strings to be configured by via spring. Please review and incorporate if desired.
The attached patch contains:
1) Interface for AclSQLSource (not sure if setters should really be part of this or not. I decided to include them.)
2) DefaultAclSQLSource - contains the usual Postgres SQL statements and setters for Spring configuration. Additional constructor takes a map with property and sql map entries.
3) Changes to JdbcAclService and JdbcMutableAclService to read statements from the AclSQLSource.
===
Sample configuration:
	&amp;lt;bean id="sqlSource"
		class="org.springframework.security.acls.jdbc.DefaultAclSQLSource"&amp;gt;
		&amp;lt;constructor-arg&amp;gt;
			&amp;lt;map&amp;gt;
				&amp;lt;entry key="classIdentityQuery" value="SELECT ACL_CLASS_ID_SEQ.CURRVAL FROM DUAL" /&amp;gt;
				&amp;lt;entry key="sidIdentityQuery" value="SELECT ACL_SID_ID_SEQ.CURRVAL FROM DUAL" /&amp;gt;
				&amp;lt;entry key="selectSidPrimaryKey"
					value="select id from acl_sid where principal=DECODE(?,&amp;amp;apos;TRUE&amp;amp;apos;,&amp;amp;apos;1&amp;amp;apos;,&amp;amp;apos;Y&amp;amp;apos;,&amp;amp;apos;1&amp;amp;apos;,&amp;amp;apos;1&amp;amp;apos;,&amp;amp;apos;1&amp;amp;apos;,&amp;amp;apos;FALSE&amp;amp;apos;,&amp;amp;apos;0&amp;amp;apos;,&amp;amp;apos;N&amp;amp;apos;,&amp;amp;apos;0&amp;amp;apos;,&amp;amp;apos;0&amp;amp;apos;,&amp;amp;apos;0&amp;amp;apos;) and sid=?" /&amp;gt;
				&amp;lt;entry key="insertSid"
					value="insert into acl_sid (principal, sid) values (DECODE(?,&amp;amp;apos;TRUE&amp;amp;apos;,&amp;amp;apos;1&amp;amp;apos;,&amp;amp;apos;Y&amp;amp;apos;,&amp;amp;apos;1&amp;amp;apos;,&amp;amp;apos;1&amp;amp;apos;,&amp;amp;apos;1&amp;amp;apos;,&amp;amp;apos;FALSE&amp;amp;apos;,&amp;amp;apos;0&amp;amp;apos;,&amp;amp;apos;N&amp;amp;apos;,&amp;amp;apos;0&amp;amp;apos;,&amp;amp;apos;0&amp;amp;apos;,&amp;amp;apos;0&amp;amp;apos;), ?)" /&amp;gt;
			&amp;lt;/map&amp;gt;
		&amp;lt;/constructor-arg&amp;gt;
	&amp;lt;/bean&amp;gt;
	&amp;lt;bean id="aclService"
		class="org.springframework.security.acls.jdbc.JdbcMutableAclService"&amp;gt;
		&amp;lt;constructor-arg ref="secDataSource" index="0"/&amp;gt;
		&amp;lt;constructor-arg ref="lookupStrategy" index="1"/&amp;gt;
		&amp;lt;constructor-arg ref="aclCache" index="2"/&amp;gt;
		&amp;lt;constructor-arg ref="sqlSource" index="3"/&amp;gt;
	&amp;lt;/bean&amp;gt;
===</description>
			<version>2.0.5</version>
			<fixedVersion>3.0.0.RC2</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.jdbc.JdbcAclService.java</file>
			<file type="M">org.springframework.security.acls.jdbc.JdbcMutableAclService.java</file>
			<file type="M">org.springframework.security.acls.jdbc.BasicLookupStrategy.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1224</link>
			<link type="Duplicate" description="is duplicated by">1308</link>
			<link type="Duplicate" description="duplicates">925</link>
		</links>
	</bug>
	<bug id="21" master="1885" duplicate="1948" opendate="2012-01-04 08:51:17" fixdate="2012-04-15 10:12:51" resolution="Complete">
		<buginformation>
			<summary>Adding &lt;debug/&gt; causes NoSuchMethodException when FilterChainProxy&amp;apos;s relies on beans that have Autowired Constructors Custom AbstractUserDetailsAuthenticationProvider Does not process annotations</summary>
			<description>An example would be if a configuration used &amp;lt;debug/&amp;gt; and a custom AuthenticationProvider or UserDetailsService which had an Autowired constructor one might get an exception similar to NoSuchMethodException MyCustomAuthenticationProvider.&amp;lt;init&amp;gt;() I have a custom class derived from AbstractUserDetailsAuthenticationProvider which needs to use a custom dao (UserDao).  Within this provider I have an @Autowired UserDao field which does not get autowired.  UserDao is successfully autowired into other beans in the same context (all beans reside within the root context).
The hack to get it to work is to manually inject the userDao via xml configuration.  When that happens though, other annotations within UserDao (in this case @Transactional) are also removed.
For more information see:  http://stackoverflow.com/a/10036529/80286
</description>
			<version>3.1.0</version>
			<fixedVersion>3.1.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.util.InMemoryXmlApplicationContext.java</file>
			<file type="M">org.springframework.security.config.debug.SecurityDebugBeanFactoryPostProcessor.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1948</link>
			<link type="Duplicate" description="is duplicated by">1911</link>
			<link type="Duplicate" description="duplicates">1885</link>
		</links>
	</bug>
	<bug id="22" master="183" duplicate="233" opendate="2006-02-09 08:58:38" fixdate="2006-04-23 23:32:22" resolution="Fixed">
		<buginformation>
			<summary>Avoid unnecessary HttpSession creation when using Anonymous and Remember-Me authentication AnonymousProcessingFilter - redundant creation of Authentication object causes IllegalStateException</summary>
			<description>A small number of users use HttpSessionContextIntegrationFilter.allowSessionCreation = false, as they are using an authentication mechanism (such as BASIC) which relies upon the user agent for representing authentication information on each web request. For such users, changes made as part of SEC-168 and SEC-182 will cause issues because these changes will always create a HttpSession (in order to obtain a Session ID that in turn was needed by the concurrent session capabilities). In the finally block of the doFilter method, it seems the WebAuthenticationDetails object is created again in order to compare against the current Security Context&amp;amp;apos;s Authentication object to see that it has not changed over the course of the request.  This rendundant creation can potentially cause an IllegalStateException: a session cannot be created sine the response is commited.  The response may be commited anytime down the filter pipeline.  Why create another Authentication object just to check for equality.   A references should be held before the filter chain is invoked since this is the only safe time to create a session and that reference should be used for comparison after the filter chain returns.  This will avoid the unnessary and invalid creation of a session.  </description>
			<version>1.0.0 RC2</version>
			<fixedVersion>1.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.rememberme.TokenBasedRememberMeServices.java</file>
			<file type="M">org.acegisecurity.context.HttpSessionContextIntegrationFilter.java</file>
			<file type="M">org.acegisecurity.context.HttpSessionContextIntegrationFilterTests.java</file>
			<file type="M">org.acegisecurity.providers.anonymous.AnonymousProcessingFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">233</link>
			<link type="Duplicate" description="duplicates">183</link>
		</links>
	</bug>
	<bug id="23" master="105" duplicate="109" opendate="2005-11-18 01:26:15" fixdate="2005-11-24 14:30:10" resolution="Fixed">
		<buginformation>
			<summary>Mis-named method signature in n.s.a.util.PortMapperImpl PortMapperImpl property mistake</summary>
			<description>Forum discussion :
http://forum.springframework.org/showthread.php?t=19903
yielded a little problem with PortMappingImpl.  The javadocs state that use the following in a spring config file
   &amp;lt;property name="httpsPortMapping"&amp;gt;
     &amp;lt;map&amp;gt;
       &amp;lt;entry key="80"&amp;gt;&amp;lt;value&amp;gt;443&amp;lt;/value&amp;gt;&amp;lt;/entry&amp;gt;
       &amp;lt;entry key="8080"&amp;gt;&amp;lt;value&amp;gt;8443&amp;lt;/value&amp;gt;&amp;lt;/entry&amp;gt;
     &amp;lt;/map&amp;gt;
   &amp;lt;/property&amp;gt;
Looking into the source of PortMappingImpl and there&amp;amp;apos;s no corresponding setHttpsPortMapping for spring to inject.  Spring falls over.  
Solution : either update the javadocs or better in my opinion change the existing method from setPortMapping(Map m) to setHttpsPortMapping(Map m)  In accordance wuth Acegi Security System Platform Documentation, you can set a custom definition of socket port mapping (by default this is set in this way HTTP: 80/8080, HTTPS: 443/8443).
The definition of the setter method public void setPortMappings(Map newMappings) set this property httpsPortMapping. 
But this definition cause an Exception on the property writing. 
To allow the settings the property in applicationContext must be set as "portMapping".
Again, API&amp;amp;apos;s report this specifics for method setPortMappiungs:
public void setPortMappings(Map newMappings)
Set to override the default HTTP port to HTTPS port mappings of 80:443, 
and 8080:8443. In a Spring XML ApplicationContext, a definition would look something like 
this:
   &amp;lt;property name="httpsPortMapping"&amp;gt;
     &amp;lt;map&amp;gt;
       &amp;lt;entry key="80"&amp;gt;&amp;lt;value&amp;gt;443&amp;lt;/value&amp;gt;&amp;lt;/entry&amp;gt;
       &amp;lt;entry key="8080"&amp;gt;&amp;lt;value&amp;gt;8443&amp;lt;/value&amp;gt;&amp;lt;/entry&amp;gt;
     &amp;lt;/map&amp;gt;
   &amp;lt;/property&amp;gt;
Parameters:
newMappings - A Map consisting of String keys and String values, where 
for each entry the key is the string representation of an integer HTTP port 
number, and the value is the string representation of the corresponding 
integer HTTPS port number. 
Throws:
IllegalArgumentException - if input map does not consist of String 
keys and values, each representing an integer port number in the range 
1-65535 for that mapping.
Thanks for attention.
Kind Regards
</description>
			<version>0.8.3</version>
			<fixedVersion>1.0.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.util.PortMapperImpl.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">109</link>
			<link type="Duplicate" description="duplicates">105</link>
		</links>
	</bug>
	<bug id="24" master="243" duplicate="197" opendate="2006-02-21 17:41:01" fixdate="2006-04-25 14:05:59" resolution="Fixed">
		<buginformation>
			<summary>SessionRegistryImpl.getAllSessions(Object) incorrectly includes expired and destroyed sessions ConcurrentSessionController should count non-expired Sessions only</summary>
			<description>The function SessionRegistryImpl.getAllSessions(principal) returns all session associated with the principal, even it is marked as expired. This is in violation of the SessionRegistry interface contract.
The fix is to filter out any expired session information return by function sessionRegistry.getAllSessions(principal) With ConcurrentSession support enabled, its very common for a user to close their browser without logging out, thereby locking themselves out of the app until their session expires.  
I have added a function to my admin to "logout" an active user, bascially calling SessionInformation.expireNow() for each session beloging to him.  
But, after doing this the user still can&amp;amp;apos;t logon because ConcurrentSessionController just counts how many SessionInformation objects are returned from getAllSessions.  Until the HttpSession expires or the logged out user hits the site again (triggering a HttpSession invalidation) the user cannot login again.  
If the ConcurrentSessionController.checkAuthenticationAllowed method counted non-expired sessions instead of all sessions, this would allow the user to log back in (even though he has an abondonded HttpSession) and continue to use the system.</description>
			<version>1.0.0 RC2</version>
			<fixedVersion>1.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.concurrent.SessionRegistryImplTests.java</file>
			<file type="M">org.acegisecurity.concurrent.ConcurrentSessionControllerImpl.java</file>
			<file type="M">org.acegisecurity.concurrent.SessionRegistryImpl.java</file>
			<file type="M">org.acegisecurity.concurrent.SessionRegistry.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">197</link>
			<link type="Duplicate" description="duplicates">243</link>
		</links>
	</bug>
	<bug id="25" master="2549" duplicate="2604" opendate="2014-04-07 01:34:51" fixdate="2014-05-23 06:09:25" resolution="Complete">
		<buginformation>
			<summary>java.lang.IllegalAccessError: class org.springframework.security.config.annotation.authentication.configuration.$Proxy90 cannot access its superinterface &lt;omitted&gt;.AuthenticationConfiguration$LazyBean Spring Security not working with configurations in Parent Application Contect</summary>
			<description>Is it possible to change the visibility of LazyBean marker interface to `public`?
We are planning to pull up spring dependencies as JBoss EAP "module" (shared libraries) to be shared among all of our applications.
Each "module" has its own isolated ClassLoader, and is parallel to the war "module" ClassLoader, so we have to emulate the class loading hierarchy ourselves for compatibility.
The problem is that the aggregated ClassLoader (delegates to "module" classLoader and then the applications&amp;amp;apos;s ClassLoader) cannot sees the private LazyBean marker. Hi,
In your web application, we have three layers of application context. 
1. Spring MVC Context
2. Web Application Context
3. Parent Application Context.
WebApplicationContext is parent of SpringMVCContext.
ParentApplicationContext is parent of WebApplicationContext.
We are using JavaConfig in our application.
Now, we want to use Authorization feature Spring Security in our application. To use this we configured below in Parent Context
1. Authentication Manager
2. Authentication Provider
3. UserDetailsService
We have defined these beans in the class which extends from GlobalSecurityConfiguration. This class is annotated with @GlobalMethodSecurity.
We&amp;amp;apos;ve overriden the configure(AuthenticationManagerBuilder) and added AuthenticationProvider in AuthenticationBuilder to build the AuthenticationManager.






protected void configure(AuthenticationManagerBuilder auth) throws Exception {









        auth.authenticationProvider(preAuthenticatedAuthenticationProvider());









    }






We have exposed the AuthenticationManager as below






   @Bean(name="authenticationManager")




    public AuthenticationManager authenticationManagerBean() throws Exception {




        return authenticationManager();




    }






And, we have configured the required filter bean in SpringMVCContext. 
Filter gets the reference of the AuthenticationManager which is configured in ParentContext. However, it throws below exception and application does not work.






Caused by: java.lang.IllegalAccessError: org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration$LazyBean




      at java.lang.reflect.Proxy.defineClass0(Native Method)




      at java.lang.reflect.Proxy.getProxyClass0(Proxy.java:625)




      at java.lang.reflect.Proxy.newProxyInstance(Proxy.java:702)




      at org.springframework.aop.framework.JdkDynamicAopProxy.getProxy(JdkDynamicAopProxy.java:121)




      at org.springframework.aop.framework.ProxyFactoryBean.getProxy(ProxyFactoryBean.java:368)




      at org.springframework.aop.framework.ProxyFactoryBean.getSingletonInstance(ProxyFactoryBean.java:322)




      at org.springframework.aop.framework.ProxyFactoryBean.getObject(ProxyFactoryBean.java:246)




      at org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration.lazyBean(AuthenticationConfiguration.java:119)




      at org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration.getAuthenticationMangerBean(AuthenticationConfiguration.java:123)




      at org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration.getAuthenticationManager(AuthenticationConfiguration.java:81)




      at org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter.authenticationManager(WebSecurityConfigurerAdapter.java:229)




      at org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter.getHttp(WebSecurityConfigurerAdapter.java:171)




      at org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter.init(WebSecurityConfigurerAdapter.java:276)




      at org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter.init(WebSecurityConfigurerAdapter.java:61)




      at com.deere.dsfj.jdorderspringmvcweb.config.SpringWebSecurityConfig$$EnhancerBySpringCGLIB$$1ccbdc0f.init(&amp;lt;generated&amp;gt;)




      at org.springframework.security.config.annotation.AbstractConfiguredSecurityBuilder.init(AbstractConfiguredSecurityBuilder.java:369)




      at org.springframework.security.config.annotation.AbstractConfiguredSecurityBuilder.doBuild(AbstractConfiguredSecurityBuilder.java:322)




      at org.springframework.security.config.annotation.AbstractSecurityBuilder.build(AbstractSecurityBuilder.java:39)




      at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration.springSecurityFilterChain(WebSecurityConfiguration.java:92)




      at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$$EnhancerBySpringCGLIB$$a1372076.CGLIB$springSecurityFilterChain$1(&amp;lt;generated&amp;gt;)




      at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$$EnhancerBySpringCGLIB$$a1372076$$FastClassBySpringCGLIB$$a530ca1c.invoke(&amp;lt;generated&amp;gt;)




      at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:228)




      at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:312)




      at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$$EnhancerBySpringCGLIB$$a1372076.springSecurityFilterChain(&amp;lt;generated&amp;gt;)




      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:60)




      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:37)




      at java.lang.reflect.Method.invoke(Method.java:611)




      at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:166)




      ... 113 more






Please suggest
</description>
			<version>3.2.3</version>
			<fixedVersion>3.2.4, 4.0.0.M1</fixedVersion>
			<type>Defect</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter.java</file>
			<file type="M">org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">2604</link>
			<link type="Relate" description="relates to">2531</link>
			<link type="Duplicate" description="duplicates">2549</link>
		</links>
	</bug>
	<bug id="26" master="2223" duplicate="2237" opendate="2013-07-21 12:28:59" fixdate="2013-07-30 07:26:22" resolution="Fixed">
		<buginformation>
			<summary>FirewallRequest#reset() has incomplete javadoc API documentation for FirewalledRequest.reset() incomplete</summary>
			<description> The API documentation of the method FirewalledRequest.reset is incomplete and ends immendiately before giving the most important piece of information:
Right now, the last setence reads like this:
"An implementation can thus choose to modify the state of the request for the security infrastructure, while still maintaining the [!]"
The important information is what is still maintained. This is missing right now.</description>
			<version>3.2.0.M2</version>
			<fixedVersion>3.2.0.RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.firewall.FirewalledRequest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">2237</link>
			<link type="Duplicate" description="duplicates">2223</link>
		</links>
	</bug>
	<bug id="27" master="297" duplicate="355" opendate="2006-06-05 19:27:55" fixdate="2006-11-12 09:00:09" resolution="Fixed">
		<buginformation>
			<summary>defaultTargetUrl Scheme Scheme not supported in AbstractProcessingFilter.defaultTargetUrl</summary>
			<description>Documentation regarding inclusion of http://or https:// scheme in the defaultTargetUrl :
defaultTargetUrl indicates the URL that should be used for redirection if the HttpSession attribute named ACEGI_SAVED_REQUEST_KEY does not indicate the target URL once authentication is completed successfully. eg: /. The defaultTargetUrl will be treated as relative to the web-app&amp;amp;apos;s context path, and should include the leading /. Alternatively, inclusion of a scheme name (eg http:// or https://) as the prefix will denote a fully-qualified URL and this is also supported.
Snippet of acegi configuration file:
    &amp;lt;bean id="authenticationProcessingFilter" class="org.acegisecurity.ui.webapp.AuthenticationProcessingFilter"&amp;gt;
        &amp;lt;property name="authenticationManager"&amp;gt;&amp;lt;ref local="authenticationManager"/&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name="authenticationFailureUrl"&amp;gt;&amp;lt;value&amp;gt;/login.do?error=true&amp;lt;/value&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name="defaultTargetUrl"&amp;gt;&amp;lt;value&amp;gt;https://bpz.fluxweb.com/ctxroot/home.do?method=home&amp;lt;/value&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name="filterProcessesUrl"&amp;gt;&amp;lt;value&amp;gt;/j_security_check&amp;lt;/value&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
However the defaultTargetUrl is always prefixed with the context root (based on the debugging information below):
[app] DEBUG [TP-Processor2] AbstractProcessingFilter.successfulAuthentication(384) | Redirecting to target URL from HTTP Session (or default): /ctxroothttps://bpz.fluxweb.com/ctxroot/home.do?method=home The JavaDoc for AbstractProcessingFilter states that the defaultTargetUrl supports absolute URLs by starting with a scheme name (the JavaDoc says: The &amp;lt;code&amp;gt;defaultTargetUrl&amp;lt;/code&amp;gt; will be treated as relative to the web-app&amp;amp;apos;s context path, and should include the leading &amp;lt;code&amp;gt;/&amp;lt;/code&amp;gt;. Alternatively, inclusion of a scheme name (eg http:// or https://) as the prefix will denote a fully-qualified URL and this is also supported.)
However, the actual code that builds the redirect URL looks like:
            targetUrl = request.getContextPath() + getDefaultTargetUrl();
and therefore the full URL just gets appended to the contextPath.
As an aside, it would also be useful if the code for determining the targetUrl was factored out so that it could be overridden easily. 
Regards,
Damien</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.AbstractProcessingFilter.java</file>
			<file type="M">org.acegisecurity.ui.AbstractProcessingFilterTests.java</file>
			<file type="M">org.acegisecurity.ui.webapp.SiteminderAuthenticationProcessingFilterTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">355</link>
			<link type="Duplicate" description="duplicates">297</link>
		</links>
	</bug>
	<bug id="28" master="2045" duplicate="3073" opendate="2012-09-06 11:28:44" fixdate="2015-08-18 09:58:33" resolution="Fixed">
		<buginformation>
			<summary>AbstractAuthorizeTag cannot specify which WebInvocationPrivilegeEvaluator JSPAuthorizeTag authorizeUsingUrlCheck only compares against first WebInvocationPrivilegeEvaluator</summary>
			<description>AbstractAuthorizeTag uses the first WebInvocationPrivilegeEvaluator which causes problems when evaluating the url attribute and having multiple &amp;lt;http&amp;gt; elements. In AbstractAuthorizeTag, authorizeUsingUrlCheck calls getPrivilegeEvaluator which on line 347 returns the first WebInvocationPrivilegeEvaluator ignoring others. 
An application might have multiple WebInvocationPrivilegeEvaluators for instance if there is one &amp;lt;http&amp;gt; config for the main ui of the application and one for a built in REST service. 
Example REST &amp;lt;http&amp;gt; config:
 &amp;lt;http pattern="/api/**" create-session="stateless" use-expressions="true"&amp;gt;
    	&amp;lt;intercept-url pattern="/api/**" access="hasRole(&amp;amp;apos;ROLE_REST&amp;amp;apos;)"/&amp;gt;
    	&amp;lt;http-basic/&amp;gt;
    &amp;lt;/http&amp;gt; 
Thus a JSP authorize url check such as:
&amp;lt;sec:authorize url="/secureAction"&amp;gt;
will only be evaluated against the first &amp;lt;http&amp;gt; config.
In some cases, such as when the main &amp;lt;http&amp;gt; config contains a catchall (&amp;lt;intercept-url pattern="/**" access="isAuthenticated()" /&amp;gt;), the order of the &amp;lt;http&amp;gt; configs can not be changed yielding no way to conduct url evaluations.
It seems like all WebInvocationPrivilegeEvaluators should be considered.</description>
			<version>3.2.8</version>
			<fixedVersion>3.1.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.WebAttributes.java</file>
			<file type="M">org.springframework.security.taglibs.authz.AbstractAuthorizeTag.java</file>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilterTests.java</file>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">2101</link>
			<link type="Duplicate" description="is duplicated by">3073</link>
			<link type="Duplicate" description="duplicates">2045</link>
		</links>
	</bug>
	<bug id="29" master="108" duplicate="117" opendate="2005-11-21 21:53:15" fixdate="2005-12-02 22:24:12" resolution="Fixed">
		<buginformation>
			<summary>Change JdbcDaoImpl fields to be protected (not private) JdbcDaoImpl not properly extensible</summary>
			<description>In the previous version we were able to get to the authoritiesByUsernameMapping via a getter. As of version 0.9.0 this getter is no longer available. We need this in the subclasses of JdbcDaoImpl. While the javadoc for JdbcDaoImpl suggests that it is possible to override the initMappingSqlQueries() if the default strategy for customizing the SQL queries doesn&amp;amp;apos;t provide enough flexibility, this is in fact impossible because authoritiesByUsernameMapping and usersByUsernameMapping are declared private while they should be protected.
This as far as I can see prevents using this class against an Oracle database that doesn&amp;amp;apos;t support boolean fields.</description>
			<version>0.9.0</version>
			<fixedVersion>1.0.0 RC1</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.userdetails.jdbc.JdbcDaoImpl.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">117</link>
			<link type="Duplicate" description="duplicates">108</link>
		</links>
	</bug>
	<bug id="30" master="1998" duplicate="2067" opendate="2012-07-08 20:35:03" fixdate="2012-12-03 09:37:58" resolution="Complete">
		<buginformation>
			<summary>Support for Servlet 3.0/3.1 asynchronous request processing Security context incorrectly removed from session when asynchronous servlet used</summary>
			<description>Similar to SPR-8517 Spring Security should support Asynch Servlet request processing
Note: SEC-2067 has a sample application that should be validated against when fixing this issue Take the following sample servlet:






@Override




protected void doGet(final HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException {




	req.startAsync();




	new Thread("AsyncThread") {




		@Override




		public void run() {




			try {




				TimeUnit.SECONDS.sleep(1);




				resp.getOutputStream().flush();




			} catch (Exception e) {




				e.printStackTrace();




			}




		}




	}.start();




}






As you can see it does nothing except flushing after one second in a separate thread. However this servlet is secured by Spring Security so the resp.getOutputStream() stream is actually an instance of org.springframework.security.web.context.SaveContextOnUpdateOrErrorResponseWrapper.SaveContextServletOutputStream.
This class calls org.springframework.security.web.context.HttpSessionSecurityContextRepository.SaveToSessionResponseWrapper.saveContext() on flush(). That&amp;amp;apos;s where the bug is  This method under certain conditions removes security context from session:






httpSession.removeAttribute(springSecurityContextKey)






This method was heavily rewritten lately (see: See SEC-776, SEC-1587 and SEC-1735) so I can&amp;amp;apos;t tell where the actually bug lies. All I see is that since it can&amp;amp;apos;t find security context in thread local holder (we are flushing from a different thread), it removes the context from the session as well. Basically asynchronous servlet logs me out from the application.
I extracted the error and prepared sample, simplistic application exposing that bug (attached). I actually run into it when using Atmosphere Comet library together with Spring Security, but this application shows exact same error.
Extract and call mvn tomcat7:run. Only one Java class, browse to localhost:8080, login using admin/admin and follow instructions to reproduce.</description>
			<version>3.1.3</version>
			<fixedVersion>3.2.0.M1</fixedVersion>
			<type>New Feature</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.servletapi.HttpServlet3RequestFactory.java</file>
			<file type="M">org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilterTests.java</file>
			<file type="M">org.springframework.security.web.FilterInvocation.java</file>
			<file type="M">org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilterTests.java</file>
			<file type="M">org.springframework.security.web.context.request.async.SecurityContextCallableProcessingInterceptor.java</file>
			<file type="M">org.springframework.security.web.context.request.async.SecurityContextCallableProcessingInterceptorTests.java</file>
			<file type="M">org.springframework.security.web.context.SaveContextOnUpdateOrErrorResponseWrapper.java</file>
			<file type="M">org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.java</file>
			<file type="M">org.springframework.security.config.http.SecurityFilters.java</file>
			<file type="M">org.springframework.security.web.savedrequest.DefaultSavedRequest.java</file>
			<file type="M">org.springframework.security.web.authentication.rememberme.AbstractRememberMeServicesTests.java</file>
			<file type="M">org.springframework.security.config.http.HttpConfigurationBuilder.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="depends on">2077</link>
			<link type="Duplicate" description="is duplicated by">2067</link>
			<link type="Relate" description="is related to">2111</link>
			<link type="Duplicate" description="duplicates">1998</link>
		</links>
	</bug>
	<bug id="31" master="1870" duplicate="1951" opendate="2011-12-14 09:00:50" fixdate="2012-04-19 13:10:21" resolution="Fixed">
		<buginformation>
			<summary>HttpSessionDestroyedEvent#getSecurityContexts() broken HttpSessionDestroyedEvent#getSecurityContexts always return empty</summary>
			<description>The implementation of HttpSessionDestroyedEvent#getSecurityContexts() is broken. See the code snippet from the source below. The code retrieves the names of the session attributes which are Strings and test the Strings to be instances of SecurityContext in the loop. Strings are most likely not SecurityContexts, so the result of the method is always an empty list.






Enumeration&amp;lt;String&amp;gt; attributes = session.getAttributeNames();









ArrayList&amp;lt;SecurityContext&amp;gt; contexts = new ArrayList&amp;lt;SecurityContext&amp;gt;();









while(attributes.hasMoreElements()) {




    Object attribute = attributes.nextElement();




    if (attribute instanceof SecurityContext) {




        contexts.add((SecurityContext) attribute);




    }




}





 Looking into the source code of HttpSessionDestroyedEvent.java on line 52:
Object attribute = attributes.nextElement();
This should be: session.getAttribute(attributes.nextElement())
Thanks
</description>
			<version>3.1.0</version>
			<fixedVersion>3.1.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.session.HttpSessionDestroyedEvent.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1951</link>
			<link type="Duplicate" description="duplicates">1870</link>
		</links>
	</bug>
	<bug id="32" master="1603" duplicate="1628" opendate="2010-10-26 17:18:01" fixdate="2011-01-06 08:00:29" resolution="Complete">
		<buginformation>
			<summary>Add authentication-success-handler-ref attribute to &lt;remember-me&gt; tag add authentication-success-handler to &lt;remember-me&gt; tag</summary>
			<description>IMHO, I think it would be extremely helpful to some web developers to be able to specify a specific page to be loaded when a user is "logged in" via rememberMeServices, right out of the box. This is especially true for developers who set the always-use-default-target="true" in the &amp;lt;form-login&amp;gt; tag.  If you want the &amp;lt;remember-me&amp;gt; tag to act in the same manor, the learning curve gets pretty steep.
It would also be useful if the user&amp;amp;apos;s session always needs to be re-iniated by the web application after an expired session.  Having the target-url go to a page the tells the user their session has expired, they are being redirected to a "start page", and automatically logged-in is helpful. We are using an AuthenticationSuccessHandler to post-process login information to cache attributes into the HttpSession (we&amp;amp;apos;re using a third-party servlet that can handle some database queries by itself but needs the appropriate keys, etc.).  However, after a remember-me login, there is no way to insert a success handler to perform the appropriate initialization for the new session.
It would be helpful to have an authentication-success-handler-ref attribute on the &amp;lt;remember-me&amp;gt; tag analogous to the attribute on the &amp;lt;*-login&amp;gt; tags, triggered after the RememberMeServices handles a persistent login.
(The forum link is not my post, but there appears to be a significant desire for this feature.)</description>
			<version>3.1.0.M1</version>
			<fixedVersion>3.1.0.RC1</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.RememberMeBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilterTests.java</file>
			<file type="M">org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1628</link>
			<link type="Duplicate" description="duplicates">1603</link>
		</links>
	</bug>
	<bug id="33" master="305" duplicate="361" opendate="2006-06-23 10:21:23" fixdate="2007-05-23 13:05:02" resolution="Fixed">
		<buginformation>
			<summary>HttpSessionContextIntegrationFilter to retain SecurityContext when rendering error pages &lt;auth:authorize ifNotGranted="ROLE_ANONYMOUS"&gt; doesn&amp;apos;t work sometimes</summary>
			<description>This happens when you want to set up error pages as described in SRV.9.9.2 Error Pages in Java Servlet Specification
Version 2.4.
If for example want to display the current user name on an error page, the security context does not contain the authenticated user.
The reason is believed to be that HttpSessionContextIntegrationFilter is only applied once per request.
Seehttp://forum.springframework.org/showthread.php?t=21534 web.xml:
...........
&amp;lt;error-page&amp;gt;
  &amp;lt;error-code&amp;gt;404&amp;lt;/error-code&amp;gt;
  &amp;lt;location&amp;gt;/common/documentnotfound.do&amp;lt;/location&amp;gt;
&amp;lt;/error-page&amp;gt;
...........
If the requested page not found tomcat redirect user to the pointed url (documentnotfount.do) and in this case &amp;lt;auth:authorize ifNotGranted="ROLE_ANONYMOUS"&amp;gt; doesn&amp;amp;apos;t work.
SecurityContextHolder.getContext() = org.acegisecurity.context.SecurityContextImpl@ffffffff: Null authentication (AuthorizeTag.java: 129)
SecurityContextHolder.getContext().getAuthentication() = null (AuthorizeTag.java: 129)
granted = [] (AuthorizeTag.java: 80)
evaledIfNotGranted = ROLE_ANONYMOUS (AuthorizeTag.java: 82)
grantedCopy = [] (AuthorizeTag.java: 86)</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.4</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.context.HttpSessionContextIntegrationFilter.java</file>
			<file type="M">org.acegisecurity.context.HttpSessionContextIntegrationFilterTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">361</link>
			<link type="Duplicate" description="duplicates">305</link>
		</links>
	</bug>
	<bug id="34" master="1380" duplicate="1395" opendate="2010-01-22 08:45:04" fixdate="2010-02-02 02:33:51" resolution="Fixed">
		<buginformation>
			<summary>"access" attribute in "intercept-url" should trim whitespace from attributes intercept-url access attribute should support spaces when specifying a list of authorized roles</summary>
			<description>Currently "ROLE_A, ROLE_B" will map to two attributes, the second being " ROLE_B". Whitespace should be trimmed. The "extra" space in access definition is not supported, it should be allowed.
If this is the desired behavior, the xsd should be updated to reflect the constraint.













&amp;lt;security:intercept-url pattern="/app/*.action" access="ROLE_ANONYMOUS, ROLE_USER" /&amp;gt;













it produces






2010-02-02 00:17:40.500:WARN::Nested in org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;org.springframework.security.web.access.intercept.FilterSecurityInterceptor#0&amp;amp;apos;: Invocation of init method failed; nested exception is java.lang.IllegalArgumentException: Unsupported configuration attributes: [ ROLE_USER]: java.lang.IllegalArgumentException: Unsupported configuration attributes: [ ROLE_USER]




        at org.springframework.security.access.intercept.AbstractSecurityInterceptor.afterPropertiesSet(AbstractSecurityInterceptor.java:153)




        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1460)




        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1398)




        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:512)




        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:450)




        at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:290)




        at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222)




        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:287)




        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:189)




        at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:557)




        at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:842)




        at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:416)





</description>
			<version>3.0.1</version>
			<fixedVersion>3.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.HttpSecurityBeanDefinitionParserTests.java</file>
			<file type="M">org.springframework.security.access.SecurityConfig.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1395</link>
			<link type="Duplicate" description="duplicates">1380</link>
		</links>
	</bug>
	<bug id="35" master="1507" duplicate="1577" opendate="2010-07-02 00:52:38" fixdate="2010-10-15 09:52:57" resolution="Fixed">
		<buginformation>
			<summary>NullPointerException in RoleVoter if original UserDetails#getAuthorities() is empty and if RoleHierarchy is enabled NPE in AuthorityUtils in combination with RoleHierarchy and User with empty authorities collection</summary>
			<description>I have a custom UserDetailsService implementation which may not provide any role for some user, i.e. the UserDetails#getAuthorities() returns is an empty Collection.
If this user try to access a secured resource with a given role (e.g. not IS_AUTHENTICATED_REMEMBERED) then the following exception occurs:
java.lang.NullPointerException
	at org.springframework.security.access.vote.RoleVoter.vote(RoleVoter.java:103)
	at org.codehaus.groovy.grails.plugins.springsecurity.AuthenticatedVetoableDecisionManager.checkOtherVoters(AuthenticatedVetoableDecisionManager.java:90)
	at org.codehaus.groovy.grails.plugins.springsecurity.AuthenticatedVetoableDecisionManager.decide(AuthenticatedVetoableDecisionManager.java:44)
	at org.springframework.security.access.intercept.AbstractSecurityInterceptor.beforeInvocation(AbstractSecurityInterceptor.java:203)
	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:106)
	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:83)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:355)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:97)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:355)
	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:78)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:355)
	at org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilter.doFilter(RememberMeAuthenticationFilter.java:119)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:355)
	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:54)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:355)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:188)
	at org.codehaus.groovy.grails.plugins.springsecurity.RequestHolderAuthenticationFilter.doFilter(RequestHolderAuthenticationFilter.java:40)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:355)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:188)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:355)
	at org.codehaus.groovy.grails.plugins.springsecurity.MutableLogoutFilter.doFilter(MutableLogoutFilter.java:79)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:355)
	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:79)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:355)
	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:149)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:237)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:167)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at org.codehaus.groovy.grails.web.servlet.filter.GrailsReloadServletFilter.doFilterInternal(GrailsReloadServletFilter.java:104)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:76)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at org.codehaus.groovy.grails.web.servlet.mvc.GrailsWebRequestFilter.doFilterInternal(GrailsWebRequestFilter.java:67)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:76)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at org.codehaus.groovy.grails.web.filters.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:66)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:76)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:88)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:76)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:237)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:167)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at org.jasig.cas.client.session.SingleSignOutFilter.doFilter(SingleSignOutFilter.java:106)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at org.jasig.cas.client.session.SingleSignOutFilter.doFilter(SingleSignOutFilter.java:106)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:233)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:191)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:128)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:102)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:109)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:293)
	at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:849)
	at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.process(Http11Protocol.java:583)
	at org.apache.tomcat.util.net.JIoEndpoint$Worker.run(JIoEndpoint.java:454)
	at java.lang.Thread.run(Thread.java:619)
After looking at SEC-1325, I found that RoleHierarchyImpl.java still uses null when the authorities Collection is empty.
I have attached a patch to fix this and i have tested it against current master.
My current workaround is to provide at least the "ROLE_DUMMY" role to users. If have the following intercept-url defined in my security config (with expressions):
&amp;lt;security:intercept-url pattern="/.*/$
{webapp.context}
/flow/welcome" access="hasRole(&amp;amp;apos;ROLE_USER&amp;amp;apos;)" /&amp;gt;
I also use role hierarchies.  After authentication the user arrives at the welcome page.  When the user hasn&amp;amp;apos;t got any authorities, I receive a NPE because in RoleHierarchyImpl, which is called by SecurityExpressionRoot, the empty authorities Set is set to null:
    public Collection&amp;lt;GrantedAuthority&amp;gt; getReachableGrantedAuthorities(Collection&amp;lt;GrantedAuthority&amp;gt; authorities) {
        if (authorities == null || authorities.isEmpty()) 
{
            return null;
        }

In AuthorityUtils, the size() method is called on the null collection:
    public static Set&amp;lt;String&amp;gt; authorityListToSet(Collection&amp;lt;GrantedAuthority&amp;gt; userAuthorities) {
        Set&amp;lt;String&amp;gt; set = new HashSet&amp;lt;String&amp;gt;(userAuthorities.size());
java.lang.NullPointerException
	at org.springframework.security.core.authority.AuthorityUtils.authorityListToSet(AuthorityUtils.java:39)
	at org.springframework.security.access.expression.SecurityExpressionRoot.getAuthoritySet(SecurityExpressionRoot.java:104)
	at org.springframework.security.access.expression.SecurityExpressionRoot.hasAnyRole(SecurityExpressionRoot.java:44)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.springframework.expression.spel.support.ReflectiveMethodExecutor.execute(ReflectiveMethodExecutor.java:58)
	at org.springframework.expression.spel.ast.MethodReference.getValueInternal(MethodReference.java:76)
	at org.springframework.expression.spel.ast.SpelNodeImpl.getTypedValue(SpelNodeImpl.java:102)&amp;lt;security:intercept-url pattern="/.*</description>
			<version>3.0.3</version>
			<fixedVersion>3.1.0.M1, 3.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl.java</file>
			<file type="M">org.springframework.security.access.hierarchicalroles.RoleHierarchyImplTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1577</link>
			<link type="Duplicate" description="duplicates">1507</link>
		</links>
	</bug>
	<bug id="36" master="408" duplicate="500" opendate="2006-12-03 14:04:17" fixdate="2007-08-28 23:37:44" resolution="Fixed">
		<buginformation>
			<summary>Add getFilterProcessesUrl() to org.acegisecurity.ui.logout.LogoutFilter Provide a getFilterProcessesUrl (protected or public) method in org.acegisecurity.ui.logout.LogoutFilter so that subclasses can access this parameter</summary>
			<description>Please add a getFilterProcessesUrl() method to LogoutFilter to give sub-classes access to the filterProcessesUrl field.
For the JAMWiki project (jamwiki.org) we have a need to use a custom redirect, and therefore have created a subclass of LogoutFilter to implement a custom version of the sendRedirect() method.  Unfortunately this subclass cannot access the filterProcessesUrl field because it is private in the LogoutFilter class and there is no get method in LogoutFilter.  We have worked around the problem by extending the setFilterProcessesUrl() method in our subclass, but it would be much cleaner to just be able to call a parent getFilterProcessesUrl() method. Provide a getFilterProcessesUrl (protected or public) method in org.acegisecurity.ui.logout.LogoutFilter so that subclasses can access this parameter.</description>
			<version>1.0.4</version>
			<fixedVersion>1.0.5</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.logout.LogoutFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Depends" description="is depended on by">500</link>
			<link type="Duplicate" description="is duplicated by">500</link>
			<link type="Depends" description="depends on">408</link>
			<link type="Duplicate" description="duplicates">408</link>
		</links>
	</bug>
	<bug id="37" master="2455" duplicate="2457" opendate="2013-12-18 01:35:17" fixdate="2014-01-29 13:36:10" resolution="Fixed">
		<buginformation>
			<summary>form@login-processing-url and logout@logout-url produce warnings Warning "Method &amp;apos;setFilterProcessesUrl&amp;apos; is marked deprecated" on http-login and http-logout tag</summary>
			<description>On upgrading to 3.2.0 RELEASE, we encountered this warning in the &amp;lt;http&amp;gt; block in the namespace configuration. 
&amp;lt;form-login&amp;gt; and &amp;lt;logout&amp;gt;
The warning says that setFilterProcessesUrl (which is inherited from AbstractAuthenticationProcessingFilter whose subclass be used by http@form-login and http@logout) is deprecated. Did we miss on replacing the deprecated method with the new method to be used? Can we remove this method altogether? Or is this warning here to stay? What does this warning mean? &amp;lt;security:form-login login-page=&amp;amp;apos;/login&amp;amp;apos; default-target-url="/" authentication-failure-url="/loginfailed" /&amp;gt;
&amp;lt;security:logout logout-success-url="/" invalidate-session="true" logout-url="/logout" /&amp;gt;
Warning appear on each line : "Method &amp;amp;apos;setFilterProcessesUrl&amp;amp;apos; is marked deprecated"
Is there now a new recommended way to do this?
I have not seen anything in the documentation about it.</description>
			<version>3.2.0</version>
			<fixedVersion>3.2.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.AuthenticationConfigBuilder.java</file>
			<file type="M">org.springframework.security.config.http.FormLoginBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.web.authentication.logout.LogoutFilter.java</file>
			<file type="M">org.springframework.security.config.http.LogoutBeanDefinitionParser.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">2457</link>
			<link type="Duplicate" description="duplicates">2455</link>
		</links>
	</bug>
	<bug id="38" master="2822" duplicate="2793" opendate="2014-12-12 07:34:38" fixdate="2015-01-27 11:55:24" resolution="Complete">
		<buginformation>
			<summary>IllegalStateException: Cannot apply DaoAuthenticationConfigurer to already built object Spring Boot Requires "extends WebSecurityConfigurerAdapter"</summary>
			<description>Created by request from Rob Winch.
When initializing global authentication by injecting AuthenticationManagerBuilder you may get this exception






org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration&amp;amp;apos;: Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire method: public void org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration.setFilterChainProxySecurityConfigurer(org.springframework.security.config.annotation.ObjectPostProcessor,java.util.List) throws java.lang.Exception; nested exception is org.springframework.beans.factory.BeanExpressionException: Expression parsing failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;demo.SecurityConfig&amp;amp;apos;: Injection of autowired dependencies failed; nested exception is java.lang.IllegalStateException: Cannot apply org.springframework.security.config.annotation.authentication.configurers.userdetails.DaoAuthenticationConfigurer@62f10514 to already built object




	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:334)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1202)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:537)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:476)




	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:303)




	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)




	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:299)




	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:194)




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:762)




	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:757)




	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:480)




	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:691)




	at org.springframework.boot.SpringApplication.run(SpringApplication.java:321)




	at org.springframework.boot.test.SpringApplicationContextLoader.loadContext(SpringApplicationContextLoader.java:98)




	at org.springframework.test.context.DefaultCacheAwareContextLoaderDelegate.loadContextInternal(DefaultCacheAwareContextLoaderDelegate.java:68)




	at org.springframework.test.context.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:86)




	at org.springframework.test.context.DefaultTestContext.getApplicationContext(DefaultTestContext.java:72)




	at org.springframework.test.context.web.ServletTestExecutionListener.setUpRequestContextIfNecessary(ServletTestExecutionListener.java:170)




	at org.springframework.test.context.web.ServletTestExecutionListener.prepareTestInstance(ServletTestExecutionListener.java:110)




	at org.springframework.test.context.TestContextManager.prepareTestInstance(TestContextManager.java:212)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.createTest(SpringJUnit4ClassRunner.java:200)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner$1.runReflectiveCall(SpringJUnit4ClassRunner.java:252)




	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.methodBlock(SpringJUnit4ClassRunner.java:254)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:217)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:83)




	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)




	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)




	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)




	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)




	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)




	at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)




	at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:68)




	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:163)




	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)




	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)




Caused by: org.springframework.beans.factory.BeanCreationException: Could not autowire method: public void org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration.setFilterChainProxySecurityConfigurer(org.springframework.security.config.annotation.ObjectPostProcessor,java.util.List) throws java.lang.Exception; nested exception is org.springframework.beans.factory.BeanExpressionException: Expression parsing failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;demo.SecurityConfig&amp;amp;apos;: Injection of autowired dependencies failed; nested exception is java.lang.IllegalStateException: Cannot apply org.springframework.security.config.annotation.authentication.configurers.userdetails.DaoAuthenticationConfigurer@62f10514 to already built object




	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredMethodElement.inject(AutowiredAnnotationBeanPostProcessor.java:649)




	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:88)




	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:331)




	... 40 common frames omitted




Caused by: org.springframework.beans.factory.BeanExpressionException: Expression parsing failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;demo.SecurityConfig&amp;amp;apos;: Injection of autowired dependencies failed; nested exception is java.lang.IllegalStateException: Cannot apply org.springframework.security.config.annotation.authentication.configurers.userdetails.DaoAuthenticationConfigurer@62f10514 to already built object




	at org.springframework.context.expression.StandardBeanExpressionResolver.evaluate(StandardBeanExpressionResolver.java:164)




	at org.springframework.beans.factory.support.AbstractBeanFactory.evaluateBeanDefinitionString(AbstractBeanFactory.java:1365)




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:964)




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:949)




	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredMethodElement.inject(AutowiredAnnotationBeanPostProcessor.java:606)




	... 42 common frames omitted




Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;demo.SecurityConfig&amp;amp;apos;: Injection of autowired dependencies failed; nested exception is java.lang.IllegalStateException: Cannot apply org.springframework.security.config.annotation.authentication.configurers.userdetails.DaoAuthenticationConfigurer@62f10514 to already built object




	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:334)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1202)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:537)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:476)




	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:303)




	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)




	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:299)




	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199)




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeansOfType(DefaultListableBeanFactory.java:523)




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeansOfType(DefaultListableBeanFactory.java:512)




	at org.springframework.security.config.annotation.web.configuration.AutowiredWebSecurityConfigurersIgnoreParents.getWebSecurityConfigurers(AutowiredWebSecurityConfigurersIgnoreParents.java:52)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:606)




	at org.springframework.expression.spel.support.ReflectiveMethodExecutor.execute(ReflectiveMethodExecutor.java:112)




	at org.springframework.expression.spel.ast.MethodReference.getValueInternal(MethodReference.java:129)




	at org.springframework.expression.spel.ast.MethodReference.access$000(MethodReference.java:49)




	at org.springframework.expression.spel.ast.MethodReference$MethodValueRef.getValue(MethodReference.java:342)




	at org.springframework.expression.spel.ast.CompoundExpression.getValueInternal(CompoundExpression.java:88)




	at org.springframework.expression.spel.ast.SpelNodeImpl.getValue(SpelNodeImpl.java:120)




	at org.springframework.expression.spel.standard.SpelExpression.getValue(SpelExpression.java:242)




	at org.springframework.context.expression.StandardBeanExpressionResolver.evaluate(StandardBeanExpressionResolver.java:161)




	... 46 common frames omitted




Caused by: java.lang.IllegalStateException: Cannot apply org.springframework.security.config.annotation.authentication.configurers.userdetails.DaoAuthenticationConfigurer@62f10514 to already built object




	at org.springframework.security.config.annotation.AbstractConfiguredSecurityBuilder.add(AbstractConfiguredSecurityBuilder.java:192)




	at org.springframework.security.config.annotation.AbstractConfiguredSecurityBuilder.apply(AbstractConfiguredSecurityBuilder.java:125)




	at org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder.apply(AuthenticationManagerBuilder.java:296)




	at org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder.userDetailsService(AuthenticationManagerBuilder.java:193)




	at demo.SecurityConfig.configureGlobal(SecurityConfig.java:39)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:606)




	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredMethodElement.inject(AutowiredAnnotationBeanPostProcessor.java:642)




	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:88)




	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:331)




	... 68 common frames omitted





 Spring Boot causes ordering issues if using configureGlobal and the class configuring it does not extend WebSecurityConfigurerAdapter. This should be fixed to leverage the @Enable* annotations to eagerly initialize these classes.</description>
			<version>3.2.5</version>
			<fixedVersion>3.2.6, 4.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">2793</link>
			<link type="Relate" description="relates to">12646</link>
			<link type="Duplicate" description="duplicates">2822</link>
		</links>
	</bug>
	<bug id="39" master="328" duplicate="350" opendate="2006-07-27 19:49:15" fixdate="2006-09-14 14:37:09" resolution="Fixed">
		<buginformation>
			<summary>AbstractUserDetailsAuthenticationProvider makes two hits when no cache is used Second access to database when NullUserCache is used</summary>
			<description>if you look at AbstractUserDetailsAuthenticationProvider.authenticate, you&amp;amp;apos;ll notice that in case of failure, Acegi suppose that it is due to a cache synchronization problem and make a second retrieveUser.
But if you use no cache, your information were already up to date and retrieveUser is still called...
I think that this snippet (l. 148-151):
 // There was a problem, so try again after checking we&amp;amp;apos;re using latest data
cacheWasUsed = false;
user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication);
additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication);
has to be changed to that :
if(cacheWasUsed) 
{
            // There was a problem, so try again after checking we&amp;amp;apos;re using latest data
            cacheWasUsed = false;
            user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication);
            additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication);
 }
 else {
            throw exception
}
It&amp;amp;apos;ll avoid an useless double check... I am use DaoAuthenticationProvider.
When user enter right login and wrong  password, AbstractUserDetailsAuthenticationProvider makes 2 queries to database.
This happends when this class uses NullUserCache (by default) for user caching.
In these lines we load user details from database if there is no user in the cache (and remember that in cacheWasUsed) :
        UserDetails user = this.userCache.getUserFromCache(username);
        if (user == null) {
            cacheWasUsed = false;
            try 
{
                user = retrieveUser(username,
                    (UsernamePasswordAuthenticationToken) authentication);
                    ......
            }
....
        }
But when user enter wrong password we just load user one more time:
       // This check must come here, as we don&amp;amp;apos;t want to tell users
        // about account status unless they presented the correct credentials
        try 
{
            additionalAuthenticationChecks(user,
                (UsernamePasswordAuthenticationToken) authentication);
        }
 catch (AuthenticationException exception) 
{
            // There was a problem, so try again after checking we&amp;amp;apos;re using latest data
            cacheWasUsed = false;
            user = retrieveUser(username,
                    (UsernamePasswordAuthenticationToken) authentication);
            additionalAuthenticationChecks(user,
                (UsernamePasswordAuthenticationToken) authentication);
        }</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.providers.dao.AbstractUserDetailsAuthenticationProvider.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">350</link>
			<link type="Duplicate" description="is duplicated by">341</link>
			<link type="Duplicate" description="duplicates">328</link>
		</links>
	</bug>
	<bug id="40" master="1151" duplicate="1300" opendate="2009-05-04 01:35:05" fixdate="2009-11-29 22:53:47" resolution="Fixed">
		<buginformation>
			<summary>Check on acl bounds not correct ArrayIndex out of bounds in AclImpl</summary>
			<description>On line 130 of AclImpl.java in trunk (line number is different in other releases) a check is performed on the upper bound of the list of access control entries.
Code is:
        if (aceIndex &amp;gt; this.aces.size()) {
should be:
        if (aceIndex &amp;gt;= this.aces.size()) {
Result is that exception out of underlying list impl is thrown.  Minor. In AclImpl#verifyAceIndexExists(...)
I think this is an "off by one" bug. I may be wrong but shouldn&amp;amp;apos;t 
this:
        if (aceIndex &amp;gt; this.aces.size()) 
{
        	throw new NotFoundException("aceIndex must correctly refer to an index of the AccessControlEntry collection");
        }

be this:

        if (aceIndex &amp;gt; this.aces.size() - 1) {        	throw new NotFoundException("aceIndex must correctly refer to an index of the AccessControlEntry collection");        }

Since I&amp;amp;apos;m getting the exception but wondered how it passed verifyAceIndexExists?:
eption Handler execution resulted in exception - forwarding to resolved error view
                                 java.lang.IndexOutOfBoundsException: Index: 2, Size: 2
        at java.util.ArrayList.RangeCheck(ArrayList.java:572)
        at java.util.ArrayList.remove(ArrayList.java:415)
        at org.springframework.security.acls.domain.AclImpl.deleteAce(AclImpl.java:131)
        at com.acme.app.springframework.security.AclSecurityServiceImpl.replaceUserPermissions(AclSecurityServiceImpl.jav</description>
			<version>2.0.5</version>
			<fixedVersion>3.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.domain.AclImpl.java</file>
			<file type="M">org.springframework.security.acls.domain.AclImplTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1300</link>
			<link type="Duplicate" description="duplicates">1151</link>
		</links>
	</bug>
	<bug id="41" master="2948" duplicate="2960" opendate="2015-04-27 13:16:16" fixdate="2015-07-09 21:21:01" resolution="Complete">
		<buginformation>
			<summary>Incorrect message when upgrading to 4.0.x with the wrong xml schema declarations Bad Spring Security XSD Version Error Message</summary>
			<description>During migration from 3.2.x to 4.0.1 I came across the following error message when using the 4.0.1 library with an XML config file with 3.2 schema declarations...






SEVERE: Exception sending context initialized event to listener instance of class org.springframework.web.context.ContextLoaderListener




org.springframework.beans.factory.parsing.BeanDefinitionParsingException: Configuration problem: You cannot use a spring-security-2.0.xsd or spring-security-3.0.xsd or spring-security-3.1.xsd schema with Spring Security 3.2. Please update your schema declarations to the 3.2 schema.




Offending resource: class path resource [foo/bar/spring/spring-security.xml]






The error message needs to be updated to...
You cannot use a spring-security-2.0.xsd or spring-security-3.0.xsd or spring-security-3.1.xsd or spring-security-3.2.xsd schema with Spring Security 4.0. Please update your schema declarations to the 4.0 schema.
XML Declarations that cause the error...






&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;




&amp;lt;beans xmlns="http://www.springframework.org/schema/beans"




    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"




    xmlns:aop="http://www.springframework.org/schema/aop"




    xmlns:context="http://www.springframework.org/schema/context"




    xmlns:security="http://www.springframework.org/schema/security"




    xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd




    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd




    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd




    http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security-3.2.xsd"




    &amp;gt;





 When applicationContext.xml includes an old Spring Security XSD, the error message is misleading, indicating that version 3.2 needs to be used (I was using 3.2), when 4.0+ actually needs to be used.
The Reference URL indicates the erroneous line.
Note that this has been a problem in the past:
https://jira.spring.io/browse/SEC-2145
Perhaps it&amp;amp;apos;s worth considering a dynamically-created error message?</description>
			<version>4.0.1</version>
			<fixedVersion>4.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.SecurityNamespaceHandler.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">2960</link>
			<link type="Duplicate" description="is duplicated by">2990</link>
			<link type="Duplicate" description="duplicates">2948</link>
		</links>
	</bug>
	<bug id="42" master="525" duplicate="1277" opendate="2007-08-14 03:41:20" fixdate="2009-11-03 02:01:00" resolution="Fixed">
		<buginformation>
			<summary>[PATCH] Add AccessCheckerTag based on URL resource access permissions. The authorization tag libraries are totally wrong!</summary>
			<description>I have developed a tag (AccessCheckerTag) based on URL and not in roles, which reuse objectDefinitionSource (urls + roles) and accessDecisionManager (voters) of the filterInvocationInterceptor bean, inspired in AuthorizeTag and AccessControlListTag.
jsp looks like this:
&amp;lt;authz:accesschecker url="/deletePerson.do"&amp;gt;
    &amp;lt;A HREF="&amp;lt;c:out value="$
{request.contextPath}
" /&amp;gt;/deletePerson.do?id=&amp;lt;c:out value="$
{person.id}
" /&amp;gt;"&amp;gt;Del&amp;lt;/A&amp;gt;
&amp;lt;/authz:accesschecker&amp;gt;
I consider that this tag can be useful for some cases in which before printing the html link or button it is necessary to verify if required access is had to url resource.
see: http://forum.springframework.org/showthread.php?t=42550 &amp;lt;security:authorize ifAllGranted="ROLE_SUPERVISOR"&amp;gt;
&amp;lt;td&amp;gt;
  &amp;lt;a href="del.htm?id=&amp;lt;c:out value="$
{contact.id}"/&amp;gt;"&amp;gt;Del&amp;lt;/a&amp;gt;
&amp;lt;/td&amp;gt;
&amp;lt;/security:authorize&amp;gt;

I think it is more reasonable to protect a resource like this
&amp;lt;security:authorize ifAllAuthorised="del.htm"&amp;gt;
&amp;lt;td&amp;gt;
  &amp;lt;a href="del.htm?id=&amp;lt;c:out value="${contact.id}
"/&amp;gt;"&amp;gt;Del&amp;lt;/a&amp;gt;
&amp;lt;/td&amp;gt;
&amp;lt;/security:authorize&amp;gt;
Because the relationship between resources and roles may change in the future,
even more,the role name may change.</description>
			<version>1.0.5</version>
			<fixedVersion>3.0.0.RC2</fixedVersion>
			<type>New Feature</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.taglibs.authz.AuthorizeTag.java</file>
			<file type="D">org.springframework.security.web.access.WebInvocationPrivilegeEvaluatorTests.java</file>
			<file type="M">org.springframework.security.config.http.HttpSecurityBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.web.util.UrlUtils.java</file>
			<file type="M">org.springframework.security.taglibs.authz.AuthorizeTagTests.java</file>
			<file type="M">org.springframework.security.web.access.WebInvocationPrivilegeEvaluator.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1277</link>
			<link type="Duplicate" description="duplicates">525</link>
		</links>
	</bug>
	<bug id="43" master="2595" duplicate="2698" opendate="2014-05-17 09:18:19" fixdate="2014-08-11 07:09:25" resolution="Complete">
		<buginformation>
			<summary>@EnableGlobalMethodSecurity creates JDK dynamic proxies instead of using AspectJ advices @EnableGlobalMethodSecurity is not respecting mode = AdviceMode.ASPECTJ</summary>
			<description>The following config creates JDK proxies for secured beans preprocessed with an AspectJ compiler, thus rendering AnnotationSecurityAspect useless.
@EnableGlobalMethodSecurity(mode=AdviceMode.ASPECTJ, securedEnabled=true)
class SecurityConfig 
{...}

The AspectJMethodSecurityInterceptor that AnnotationSecurityAspect requires appears to only be instantiated by GlobalMethodSecurityBeanDefinitionParser. This implies that AnnotationSecurityAspect is only usable in XML config mode (but not Java config mode).
The attached Gradle project demonstrates this problem. Long description in link to Stackoverflow.
XML Configuration like this:
	&amp;lt;security:global-method-security mode="aspectj" proxy-target-class="false" pre-post-annotations="enabled"&amp;gt;
		&amp;lt;security:expression-handler ref="expressionHandler" /&amp;gt;
	&amp;lt;/security:global-method-security&amp;gt;
The AnnotationSecurityAspect is configured by GlobalMethodSecurityBeanDefinitionParser at line 251
With a Javaconfig Class like this:
@Configuration
@EnableGlobalMethodSecurity(mode = AdviceMode.ASPECTJ, prePostEnabled = true)
public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration
{
	@Override
	protected MethodSecurityExpressionHandler createExpressionHandler ( )
	{ 
          ...
	}
}
The AnnotationSecurityAspect is not configured. Spring-Security will create some AutoProxy AOP Classes which is bad as I wanted to use aspectj with compile-time-weaving
</description>
			<version>4.0.0.M1</version>
			<fixedVersion>3.2.5, 4.0.0.M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.method.configuration.GlobalMethodSecurityAspectJAutoProxyRegistrar.java</file>
			<file type="M">org.springframework.security.config.annotation.method.configuration.GlobalMethodSecurityConfiguration.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">2698</link>
			<link type="Relate" description="is related to">3005</link>
			<link type="Relate" description="is related to">3045</link>
			<link type="Duplicate" description="duplicates">2595</link>
			<link type="Relate" description="is related to">3005</link>
			<link type="Relate" description="is related to">3045</link>
		</links>
	</bug>
	<bug id="44" master="3020" duplicate="3055" opendate="2015-06-26 08:22:36" fixdate="2015-07-25 06:36:07" resolution="Complete">
		<buginformation>
			<summary>HttpServletRequest.isUserInRole("ROLE_&lt;anything&gt;") returns false with defaults request.isUserInRole add an extra "ROLE_"</summary>
			<description>I&amp;amp;apos;m just trying to upgrade from Spring Security 3.1 to 4.0.1 and have discovered a breaking change in the behaviour of request.isUserInRole().
In Spring 3.1 the following was returning true and now returns false:
request.isUserInRole("ROLE_REMEMBER_ME")
In Spring 4.0.1 I had to change it to the following:
request.isUserInRole("REMEMBER_ME") When calling the request.isUserInRole, the underling class: SecurityContextHolderAwareRequestWrapper:isGranted adds an extra "ROLE_" prefix so calling the request.isUserInRole("ROLE_TEST"); will cause too : ROLE_ROLE_TEST.
</description>
			<version>4.0.1</version>
			<fixedVersion>4.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestWrapperTests.java</file>
			<file type="M">org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestWrapper.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">3035</link>
			<link type="Duplicate" description="is duplicated by">3055</link>
			<link type="Relate" description="relates to">2926</link>
			<link type="Duplicate" description="duplicates">3020</link>
		</links>
	</bug>
	<bug id="45" master="2078" duplicate="2794" opendate="2012-11-09 01:12:03" fixdate="2015-02-24 14:45:28" resolution="Complete">
		<buginformation>
			<summary>Pre-authentication fails when using check for principal change and using non String principals AbstractPreAuthenticatedProcessingFilter requires authentication check failure</summary>
			<description>The problem occurs when using pre-authentication with "check for principal change" set and the class there extends org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilter using non String principals but e.g. java.security.Principal.
The problem is that the authentication manager will always authenticate even the principal has no changed, this can give problems with the authentication provider, and performance in the code.
The error is in line 145 in the AbstractPreAuthenticatedProcessingFilter class, the code:
  if (currentUser.getName().equals(principal)) 
{
    return false;
  }

should be changed to something like:
  if (principal instanceof Principal) 
{
    return !currentUser.getName().equals(((Principal)principal).getName());
  }
  else 
{
    return !currentUser.getName().equals(principal.toString());
  }

The original code will only function when the passed principal parameter is of the type String. The code suggested will function for all type of objects there either implements the java.security.Principal interface or override the toString method. In the AbstractPreAuthenticatedProcessingFilter.requiresAuthentication(HttpServletRequest request) method which is private, there is the following code:
        Object principal = getPreAuthenticatedPrincipal(request);
        if (currentUser.getName().equals(principal)) 
{
            return false;
        }

This assumes that the overriden method of getPreAuthenticatedPrincipal(request) will always return a String, when in fact it could be any object. This needs to change to either:
		String principal = request.getUserPrincipal().getName();
		if (currentUser.getName().equals(principal)) 
{
			return false;
		}
or provide an abstract method (or at least a protected/public method) in order to do the comparison - see attachment. My getPreAuthenticatedPrincipal(request) returns a FederationPrincipal, and not a String. The only way to deal with it at the moment is to completely copy the AbstractPreAuthenticatedProcessingFilter, and change the tiny bit of code above.</description>
			<version>4.0.0.RC1</version>
			<fixedVersion>3.2.6, 4.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilterTests.java</file>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">2497</link>
			<link type="Duplicate" description="is duplicated by">2751</link>
			<link type="Duplicate" description="is duplicated by">2794</link>
			<link type="Relate" description="is related to">3051</link>
			<link type="Duplicate" description="duplicates">2078</link>
		</links>
	</bug>
	<bug id="46" master="272" duplicate="325" opendate="2006-05-22 22:44:38" fixdate="2008-01-14 07:57:54" resolution="Fixed">
		<buginformation>
			<summary>Provide user group support Add support for Groups</summary>
			<description>As discussed at The Spring Experience in December 2005, the community would like a way of grouping users together and assigning those groups roles. We&amp;amp;apos;ll add this feature - which will involve an extra table. http://forum.springframework.org/showthread.php?p=53307
&amp;lt;quote from="raible"&amp;gt;I attended a BOF at The Spring Experience where there was much debate about having a "Groups" concept in Acegi. Colin was for it, Ben against. However, in the end, I believe Ben said it&amp;amp;apos;d only take 10 minutes to add - so he&amp;amp;apos;d do it.&amp;lt;/quote&amp;gt;
&amp;lt;quote from="alex"&amp;gt;It&amp;amp;apos;s a semantic thing. People who want an "administrative" / "management" interface for security would like to see groups etc. I would not modify the GrantedAuthority concept to not recognise groups - I would merely add a GROUP table which the out-of-the-box DAOs would recognise and then generate additional GrantedAuthority[]s accordingly.&amp;lt;/quote&amp;gt;</description>
			<version>1.0.1</version>
			<fixedVersion>2.0.0 M2</fixedVersion>
			<type>New Feature</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.springframework.security.userdetails.GroupsManager.java</file>
			<file type="M">org.springframework.security.userdetails.jdbc.JdbcUserDetailsManagerTests.java</file>
			<file type="M">org.springframework.security.userdetails.jdbc.JdbcUserDetailsManager.java</file>
			<file type="M">org.springframework.security.userdetails.jdbc.JdbcDaoImpl.java</file>
			<file type="M">org.springframework.security.PopulatedDatabase.java</file>
			<file type="M">org.springframework.security.userdetails.jdbc.JdbcDaoImplTests.java</file>
			<file type="M">org.acegisecurity.PopulatedDatabase.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">325</link>
			<link type="Related" description="is related to">513</link>
			<link type="Related" description="is related to">391</link>
			<link type="Duplicate" description="duplicates">272</link>
		</links>
	</bug>
	<bug id="47" master="2897" duplicate="2900" opendate="2015-03-06 07:14:44" fixdate="2015-03-10 14:43:09" resolution="Fixed">
		<buginformation>
			<summary>ActiveDirectoryLdapAuthenticationProvider should use bindPrincipal not username Active-directory based login stopped working</summary>
			<description>Shouldn&amp;amp;apos;t the lines
return SpringSecurityLdapTemplate.searchForSingleEntryInternal(context, searchControls,
                   searchRoot, searchFilter, new Object[]
{username}
);
actually be
return SpringSecurityLdapTemplate.searchForSingleEntryInternal(context, searchControls,
                   searchRoot, searchFilter, new Object[]
{bindPrincipal}
);
?
This currently breaks our authentication. Active-directory based login in my project works fine with version 3.2.5.
With 3.2.6 it does not anymore, without any exception.
I am using a "FilteringAuthenticationProvider" to decide if the AD-controller is hit with an auth. request or not. I will include the code here.
&amp;lt;beans:bean id="filteringLdapProvider" class="com.example.FilteringAuthenticationProvider"&amp;gt;
	&amp;lt;beans:constructor-arg ref="adAuthenticationProvider" /&amp;gt;
&amp;lt;/beans:bean&amp;gt;
&amp;lt;authentication-manager alias="authenticationManager"&amp;gt;
	&amp;lt;authentication-provider ref="filteringLdapProvider" /&amp;gt;
	&amp;lt;authentication-provider user-service-ref="myUserDetailsService"&amp;gt;
		&amp;lt;password-encoder ref="passwordEncoder" /&amp;gt;
	&amp;lt;/authentication-provider&amp;gt;
&amp;lt;/authentication-manager&amp;gt;
&amp;lt;beans:bean id="adAuthenticationProvider" class="org.springframework.security.ldap.authentication.ad.ActiveDirectoryLdapAuthenticationProvider"&amp;gt;
	&amp;lt;beans:constructor-arg value="the.domain" /&amp;gt;
	&amp;lt;beans:constructor-arg value="ldap://the.host/" /&amp;gt;
&amp;lt;/beans:bean&amp;gt;
import javax.inject.Inject;
import com.example.service.UserService;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.validator.GenericValidator;
import org.apache.log4j.Logger;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.authentication.WebAuthenticationDetails;
import org.springframework.stereotype.Component;
@Component
public class FilteringAuthenticationProvider implements AuthenticationProvider {
	// http://stackoverflow.com/questions/21381893/use-different-authenticationprovider-depending-on-username-and-remote-ip-address/
	private static Logger			logger		= Logger.getLogger(FilteringAuthenticationProvider.class);
	private AuthenticationProvider	delegate	= null;
	@Inject
	private UserService				userService;
	public FilteringAuthenticationProvider() {
	}
	public FilteringAuthenticationProvider(final AuthenticationProvider delegate) 
{
		this.delegate = delegate;
	}


	@Override
	public Authentication authenticate(final Authentication authentication) throws AuthenticationException {
		final Object details = authentication.getDetails();
		final String username = authentication.getPrincipal().toString();
		String remoteAddress = null;
		if (details instanceof WebAuthenticationDetails) 
{
			remoteAddress = ((WebAuthenticationDetails) details).getRemoteAddress();
		}

		if (matches(remoteAddress, username)) {
			final boolean isWindowsLoginEnabled = userService.isWindowsLoginEnabled(username);
			if (isWindowsLoginEnabled) 
{
				logger.info("Delegating user &amp;amp;apos;" + username + "&amp;amp;apos; to ActiveDirectoryLdapAuthenticationProvider");
				return delegate.authenticate(authentication);
			}
 else 
{
				return null;
			}
		}
		return null;
	}
	private boolean matches(final String remoteAddress, final String username) {
		if (!GenericValidator.isEmail(username)) 
{
			return true;
		}

		return false;
	}
	@Override
	public boolean supports(final Class&amp;lt;?&amp;gt; authentication) 
{
		return authentication.equals(UsernamePasswordAuthenticationToken.class);
	}
}</description>
			<version>3.2.6</version>
			<fixedVersion>3.2.7, 4.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ldap.authentication.ad.ActiveDirectoryLdapAuthenticationProviderTests.java</file>
			<file type="M">org.springframework.security.ldap.authentication.ad.ActiveDirectoryLdapAuthenticationProvider.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">2895</link>
			<link type="Duplicate" description="is duplicated by">2900</link>
			<link type="Relate" description="is related to">1915</link>
			<link type="Duplicate" description="duplicates">2897</link>
		</links>
	</bug>
	<bug id="48" master="2078" duplicate="2751" opendate="2012-11-09 01:12:03" fixdate="2015-02-24 14:45:28" resolution="Complete">
		<buginformation>
			<summary>Pre-authentication fails when using check for principal change and using non String principals AbstractPreAuthenticatedProcessingFilter assumes principal is a string</summary>
			<description>The problem occurs when using pre-authentication with "check for principal change" set and the class there extends org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilter using non String principals but e.g. java.security.Principal.
The problem is that the authentication manager will always authenticate even the principal has no changed, this can give problems with the authentication provider, and performance in the code.
The error is in line 145 in the AbstractPreAuthenticatedProcessingFilter class, the code:
  if (currentUser.getName().equals(principal)) 
{
    return false;
  }

should be changed to something like:
  if (principal instanceof Principal) 
{
    return !currentUser.getName().equals(((Principal)principal).getName());
  }
  else 
{
    return !currentUser.getName().equals(principal.toString());
  }

The original code will only function when the passed principal parameter is of the type String. The code suggested will function for all type of objects there either implements the java.security.Principal interface or override the toString method. I am using pre-authentication alongside form login. I ran into a problem similar to this user:
https://jira.spring.io/browse/SEC-1983?focusedCommentId=93727&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-93727
In working around this problem, I noticed this code inside 
AbstractPreAuthenticatedProcessingFilter.requiresAuthentication():
if (currentUser.getName().equals(principal)) 
{
            return false;
 }

In my case, principal is an instance of UserDetails. So comparing an instance of String to an instance of UserDetails always returned false.
I had to change the above code to this:
if (currentUser.getPrincipal().equals(principal)) {
            return false;
}
</description>
			<version>3.2.5</version>
			<fixedVersion>3.2.6, 4.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilterTests.java</file>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">2497</link>
			<link type="Duplicate" description="is duplicated by">2751</link>
			<link type="Duplicate" description="is duplicated by">2794</link>
			<link type="Relate" description="is related to">3051</link>
			<link type="Duplicate" description="duplicates">2078</link>
		</links>
	</bug>
	<bug id="49" master="404" duplicate="433" opendate="2006-11-29 13:52:40" fixdate="2007-05-21 18:56:10" resolution="Fixed">
		<buginformation>
			<summary>Logout when not logged in cause NullPointerException Fix to SEC-359 has introduced a NullPointer to TokenBasedRememberMeServices.logout()</summary>
			<description>When a user attempts to logout when they aren&amp;amp;apos;t logged in (e.g. when their session has expired) a NullPointerException occurs in TokenBasedRememberMeServices.logout(TokenBasedRememberMeServices.java:295).
The line that fails is:
        cancelCookie(request, response, "Logout of user " + authentication.getName());
I guess the cookie should still be cancelled, so the change might simply be to change the line to something like:
        cancelCookie(request, response, "Logout of user " + authentication == null ? "Unknown" : authentication.getName());
Regards,
Damien 
cancelCookie(request, response, "Logout of user " + authentication.getName()); &amp;lt;-- NULL POINTER if authentication is null
Stack trace: java.lang.NullPointerException
    at org.acegisecurity.ui.rememberme.TokenBasedRememberMeServices.logout(TokenBasedRememberMeServices.java:295)
    at org.acegisecurity.ui.logout.LogoutFilter.doFilter(LogoutFilter.java:98)
    at org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:274)
    at org.acegisecurity.context.HttpSessionContextIntegrationFilter.doFilter(HttpSessionContextIntegrationFilter.java:229)
    at org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:274)
    at org.acegisecurity.securechannel.ChannelProcessingFilter.doFilter(ChannelProcessingFilter.java:138)
    at org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:274)
    at org.acegisecurity.util.FilterChainProxy.doFilter(FilterChainProxy.java:148)
    at org.acegisecurity.util.FilterToBeanProxy.doFilter(FilterToBeanProxy.java:98) </description>
			<version>1.0.3</version>
			<fixedVersion>1.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.rememberme.TokenBasedRememberMeServices.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">433</link>
			<link type="Duplicate" description="is duplicated by">464</link>
			<link type="Duplicate" description="is duplicated by">407</link>
			<link type="Duplicate" description="duplicates">404</link>
		</links>
	</bug>
	<bug id="50" master="99" duplicate="353" opendate="2005-11-14 14:27:20" fixdate="2008-03-24 11:45:11" resolution="Fixed">
		<buginformation>
			<summary>MethodDefinitionMap must support superclass declared methods Acegi only checks current class interfaces against rules</summary>
			<description>As reported by Tom Dunstan, MethodDefinitionMap line 168 by default will only locate methods declared for the class, and not for superclasses (ie uses clazz.getMethods() instead of clazz.getDeclaredMethods()). Whilst this is consistent with Spring&amp;amp;apos;s transaction handling, it does present an issue for those relying on generic superclasses and wanting to define authorization configuration attributes against them. It is proposed to add a new keyword to the property editor to direct MethodDefinitionMap to use getDeclaredMethods() vs getMethods(), such that by default the existing behaviour is preserved (to be consistent with transaction services) but the superclass search behaviour can be used instead. Alternatively, we could introduce an optional prefix the method name, such as "+", which denotes "locate the matching methods in the superclass". This would have the added advantage of ensuring only patterns where you deliberately want to use getDeclaredMethods() will use that method. A implements I
B extends A
If method definition specifies I methods ( eg. I.myMethod() ) and the invoked class is B then method is not securited.
MethodDefinitionMap 201-202
        // Add attributes explicitly defined for this method invocation&amp;amp;apos;s interfaces
        Class[] interfaces = method.getDeclaringClass().getInterfaces();</description>
			<version>1.0.0</version>
			<fixedVersion>2.0.0 RC1</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.intercept.method.MethodDefinitionSourceEditorTests.java</file>
			<file type="D">org.springframework.security.annotation.Jsr250SecurityAnnotationAttributes.java</file>
			<file type="D">org.springframework.security.intercept.method.MethodDefinitionMap.java</file>
			<file type="M">org.springframework.security.util.SimpleMethodInvocation.java</file>
			<file type="M">org.springframework.security.intercept.method.MethodInvocationPrivilegeEvaluatorTests.java</file>
			<file type="M">org.springframework.security.intercept.method.MethodDefinitionAttributesTests.java</file>
			<file type="M">org.springframework.security.intercept.method.MethodDefinitionSourceEditor.java</file>
			<file type="M">org.springframework.security.intercept.method.aopalliance.MethodDefinitionSourceAdvisor.java</file>
			<file type="M">org.springframework.security.config.AnnotationDrivenBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.intercept.method.MockMethodDefinitionSource.java</file>
			<file type="M">org.springframework.security.OtherTargetObject.java</file>
			<file type="M">org.springframework.security.intercept.method.aopalliance.MethodDefinitionSourceAdvisorTests.java</file>
			<file type="M">org.springframework.security.config.InterceptMethodsBeanDefinitionDecorator.java</file>
			<file type="M">org.springframework.security.ConfigAttributeDefinition.java</file>
			<file type="M">org.springframework.security.intercept.method.MethodDefinitionSource.java</file>
			<file type="M">org.springframework.security.intercept.method.aspectj.AspectJSecurityInterceptorTests.java</file>
			<file type="M">org.springframework.security.context.rmi.ContextPropagatingRemoteInvocationTests.java</file>
			<file type="M">org.springframework.security.annotation.MethodDefinitionSourceEditorTigerTests.java</file>
			<file type="M">org.springframework.security.intercept.method.aopalliance.MethodSecurityInterceptorTests.java</file>
			<file type="M">org.springframework.security.MockJoinPoint.java</file>
			<file type="D">org.springframework.security.annotation.SecurityAnnotationAttributes.java</file>
			<file type="D">org.springframework.security.annotation.SecurityAnnotationAttributesTests.java</file>
			<file type="M">org.springframework.security.util.MethodInvocationUtils.java</file>
			<file type="M">org.springframework.security.intercept.method.MethodDefinitionAttributes.java</file>
			<file type="M">org.springframework.security.vote.BasicAclEntryVoterTests.java</file>
			<file type="M">org.springframework.security.config.BeanIds.java</file>
			<file type="D">org.springframework.security.annotation.Jsr250SecurityAnnotationAttributesTests.java</file>
		</fixedFiles>
		<links>
			<link type="Depends" description="is depended on by">428</link>
			<link type="Duplicate" description="is duplicated by">424</link>
			<link type="Duplicate" description="is duplicated by">353</link>
			<link type="Related" description="is related to">734</link>
			<link type="Duplicate" description="duplicates">99</link>
		</links>
	</bug>
	<bug id="51" master="1608" duplicate="1614" opendate="2010-11-02 04:44:29" fixdate="2010-11-10 04:00:27" resolution="Fixed">
		<buginformation>
			<summary>FirewalledRequest.reset() is not called for a resource with no filters Status 404 with Apache Tiles</summary>
			<description> We use Apache Tiles 2.1.4 to render our pages. After we&amp;amp;apos;ve upgraded to Spring Security 3.0.4 we received a "HTTP Status 404" error page from tomcat when accessing some pages.
When we use a custom HttpFirewall and FirewalledRequest, which does nothing, the errors disappear.
As far as I found out all pages are impacted which are "excluded" from Spring Security&amp;amp;apos;s FilterChainProxy, as our login and logout pages for example.
I think that issue is related to SEC-1608. 
Tiles does various forwards/includes during the rendering phase which (obviously) will change the ServletPath and PathInfo
To track down the error, I&amp;amp;apos;ve developed a custom "RequestWrapper" which outputs the original and stripped version of the ServletPath and PathInfo:
Constructor - StrippedServletPath: /main - StrippedPathInfo: /login/login.htm
getServletPath() - stripPaths: true - strippedServletPath: /main - servletPath: /main
getPathInfo() - stripPaths: true - strippedPathInfo: /login/login.htm - pathInfo: /login/login.htm
getServletPath() - stripPaths: true - strippedServletPath: /main - servletPath: /main
getServletPath() - stripPaths: true - strippedServletPath: /main - servletPath: /main
getServletPath() - stripPaths: true - strippedServletPath: /main - servletPath: /main
getPathInfo() - stripPaths: true - strippedPathInfo: /login/login.htm - pathInfo: /login/login.htm
getServletPath() - stripPaths: true - strippedServletPath: /main - servletPath: /WEB-INF/layouts/plain.jsp
As you can see at the end of the request the "strippedServletPath" and "servletPath" are different while "stripPaths" is still true. Therefore the "wrong" stripped ServletPath gets returned and Tiles fails to render the response correctly.
getPathInfo() - stripPaths: true - strippedPathInfo: /login/login.htm - pathInfo: null</description>
			<version>3.0.4</version>
			<fixedVersion>3.1.0.M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.FilterChainProxyTests.java</file>
			<file type="M">org.springframework.security.web.FilterChainProxy.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1838</link>
			<link type="Duplicate" description="is duplicated by">1614</link>
			<link type="Relate" description="is related to">1606</link>
			<link type="Duplicate" description="duplicates">1608</link>
		</links>
	</bug>
	<bug id="52" master="1117" duplicate="1014" opendate="2008-10-16 20:55:23" fixdate="2009-04-28 13:04:10" resolution="Fixed">
		<buginformation>
			<summary>Unable to use NtlmAwareLdapAuthenticator with LdapAuthenticationProvider due to checking for null password.   minor changes for an easy NTLM / LDAP configuration</summary>
			<description>Currently LdapAuthenticatonProvider checks for empty password in its authenticate() method (lines 225 onward). This does not allow to use NtlmAwareLdapAuthenticator as a delegate for authentication because null password will be always rejected - as is the case when using NTLM authentication - and NtlmAwareLdapAuthenticator never gets called.  
Forum thread mentioned above confirms the same problem encountered by another user (see item 2 in the top post)
Also a similiar problem exists with id: SEC-1014.  Following changes are needed for an easy NTLM and LDAP (Active Directory) integration :
LdapAuthenticationProvider :
Either accept empty password (then LdapAuthenticationProvider can be used as is), or change scope to protected for the private LdapAuthenticator authenticator; : in that case we can easily override the authenticate() method to avoid password length check, without the need to use another LdapAuthenticator in the overriding class.
Another change is needed for NTLM : AbstractLdapAuthenticator with no password check.
PasswordComparisonAuthenticator is final and can&amp;amp;apos;t be overrided, despite the only usefull change is to comment last lines in authenticate() to remove password check.
Because of the class name, it&amp;amp;apos;s not easy to change this...
So may a new class extending LdapAuthenticationProvider  exists  ( with no password check) ?
With those 2 changes, we can use NTLM to get username, use it to query LDAP and retrieve user informations (email, name, etc..) then use such informations in a custom UserDetails implementation (via a convenient UserDetailsContextMapper) without any implementation.
Hope this can help.
Regards.
</description>
			<version>2.0.4</version>
			<fixedVersion>3.0.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ldap.authentication.LdapAuthenticationProvider.java</file>
			<file type="M">org.springframework.security.ldap.authentication.BindAuthenticator.java</file>
			<file type="M">org.springframework.security.ldap.authentication.BindAuthenticatorTests.java</file>
			<file type="M">org.springframework.security.ldap.authentication.LdapAuthenticationProviderTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1014</link>
			<link type="Duplicate" description="duplicates">1117</link>
		</links>
	</bug>
	<bug id="53" master="572" duplicate="597" opendate="2007-10-11 01:35:45" fixdate="2008-04-13 17:42:07" resolution="Fixed">
		<buginformation>
			<summary>Cannot set ACL&amp;apos;s parent to null AclImpl.setParent() throws Exception when changing parent to null</summary>
			<description>The setParent() method in AclImpl throws an exception if I try to set the parent to null. I cannot see why I shouldn&amp;amp;apos;t be able to do this. After all, the constructor allows me to set parent to null. 
In our app we have a tree like structure of objects which are secured using Acegi&amp;amp;apos;s ACL package (the new implementation). Permissions are inherited throughout the tree. Nodes in the tree can be moved around and can become top level nodes. This is why we would like to be able to set parent to null. The work around is to use an invisible super root node for all top level nodes. We would prefer not to have to do that. I think it should be possible to change the parent of a directory to null:
Sample Scenario:
Filebrowser that manages a directory structure (the directories are secured by acegi). Now i want to move a nested directory to Root-Level. The parent-property of the corresponding ACL has to be changed to NULL.
Solution:
Simply change:
    public void setParent(Acl newParent) 
{
        aclAuthorizationStrategy.securityCheck(this, AclAuthorizationStrategy.CHANGE_GENERAL);
        Assert.notNull(newParent, "New Parent required");
        Assert.isTrue(!newParent.equals(this), "Cannot be the parent of yourself");
        this.parentAcl = newParent;
    }

to
    public void setParent(Acl newParent) 
{
        aclAuthorizationStrategy.securityCheck(this, AclAuthorizationStrategy.CHANGE_GENERAL);
        Assert.isTrue(newParent == null || !newParent.equals(this), "Cannot be the parent of yourself");
        this.parentAcl = newParent;
    }
</description>
			<version>1.0.5</version>
			<fixedVersion>2.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.domain.AclImpl.java</file>
			<file type="M">org.springframework.security.ui.webapp.AuthenticationProcessingFilterTests.java</file>
			<file type="M">org.springframework.security.ui.AbstractProcessingFilterTests.java</file>
			<file type="M">org.springframework.security.ui.AbstractProcessingFilter.java</file>
			<file type="M">org.springframework.security.ui.webapp.AuthenticationProcessingFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Depends" description="is depended on by">532</link>
			<link type="Duplicate" description="is duplicated by">597</link>
			<link type="Duplicate" description="duplicates">572</link>
		</links>
	</bug>
	<bug id="54" master="1608" duplicate="1838" opendate="2010-11-02 04:44:29" fixdate="2011-10-13 07:39:01" resolution="Fixed">
		<buginformation>
			<summary>FirewalledRequest.reset() is not called for a resource with no filters FirewalledRequest.reset() is not called if there are no matching filters</summary>
			<description> FilterChainProxy.doFilter() determines the list of filters that have to be applied to a request. If there are filters, this method delegates to VirtualFilterChain.doFilter(), which will reset the firewall request wrapper at the end of the chain.
The problem occurs, if there are no filters: FilterChainProxy.doFilter() is creating an instance of FirewalledRequest nevertheless, which it passes on to the original chain. But it does not call the "reset" method this FirewalledRequest object.
This situation occurs, if you map "/" in web.xml to the Spring Security Filter Chain, but the Spring Security Filter Chain only handles "/some/" and "/thing/*". With this mapping, there are URLs like "/status" which are passed to the security chain proxy, but which are not covered by a filter list. The effect is bug is, that the servlet which is mapped to "/status" will get an invalid pathInfo and servletPath.
The resolution should be quite simple: If FilterChainProxy.doFilter() has an empty filter list for a given URL, it must not pass the firewalled request to the original chain but the original request. The line "chain.doFilter(fwRequest, response);" should be changed into "chain.doFilter(servletRequest, response);".
I don&amp;amp;apos;t know if Spring Security 3 is affected too, because we are using 2.0.x.</description>
			<version>3.0.4</version>
			<fixedVersion>3.0.5, 3.1.0.M2, 2.0.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.FilterChainProxyTests.java</file>
			<file type="M">org.springframework.security.web.FilterChainProxy.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1838</link>
			<link type="Duplicate" description="is duplicated by">1614</link>
			<link type="Relate" description="is related to">1606</link>
			<link type="Duplicate" description="duplicates">1608</link>
		</links>
	</bug>
	<bug id="55" master="1272" duplicate="1289" opendate="2009-10-18 16:06:23" fixdate="2009-11-16 23:04:52" resolution="Fixed">
		<buginformation>
			<summary>&lt;authentication-manager&gt; does not register default event handler DefaultAuthenticationEventPublisher Successful registration event</summary>
			<description>When using the namespace configuration, creating an &amp;lt;authentication-manager&amp;gt; should automatically register a default event publisher. This allows applications to be notified about security events such as logins and login failures - for example I want these notifications so that I can write audit logs of failed logins. 
The Javadoc on org.springframework.security.authentication.ProviderManager states that such a default event publisher is automatically registered when using the namespace. It says: 
"The standard implementation is DefaultAuthenticationEventPublisher which maps common exceptions to events (in the case of authentication failure) and publishes an AuthenticationSuccessEvent if authentication succeeds. If you are using the namespace then an instance of this bean will be used automatically by the &amp;lt;http&amp;gt; configuration, so you will receive events from the web part of your application automatically."
However ProviderManager does not actually register a DefaultAuthenticationEventPublisher! It uses its private NullEventPublisher class that does nothing. That means that if you use the namespace configuration you don&amp;amp;apos;t actually receive the default events. The only way to receive those events is to manually create a ProviderManager bean and inject a DefaultAuthenticationEventPublisher bean into it.
I think that:

&amp;lt;authentication-manager&amp;gt; should use DefaultAuthenticationEventPublisher instead of NullEventPublisher
&amp;lt;authentication-manager&amp;gt; should allow the AuthenticationEventPublisher on ProviderManager to be overridden if desired

 With 3.0M2 and before I used the following code to register successful registrations and save client&amp;amp;apos;s IPs
[code]
public class AuthenticationListener implements ApplicationListener {
    @Override
    public void onApplicationEvent(ApplicationEvent event) {
        if (event instanceof AuthenticationSuccessEvent) 
{
            onAuthenticationSuccessEvent((AuthenticationSuccessEvent) event);
        }
    }
    public void onAuthenticationSuccessEvent(AuthenticationSuccessEvent authenticationSuccessEvent) 
{
        // my code
    }
}
[/code]
With 3.0RC1 there are no AuthenticationSuccessEvent events any more. I&amp;amp;apos;ve found the following comment for org.springframework.security.authentication.DefaultAuthenticationEventPublisher
"The default strategy used by &amp;lt;tt&amp;gt;ProviderManager&amp;lt;/tt&amp;gt; for publishing authentication events."
But when I looked in ProviderManager I&amp;amp;apos;ve found that the default strategy is NullEventPublisher which is created by private field&amp;amp;apos;s initializer.
I thought that it&amp;amp;apos;s possible to inject DefaultAuthenticationEventPublisher with default XML security scheme but I&amp;amp;apos;ve found no entry point to do this.</description>
			<version>3.0.0 RC1</version>
			<fixedVersion>3.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.authentication.AuthenticationManagerBeanDefinitionParserTests.java</file>
			<file type="M">org.springframework.security.config.authentication.AuthenticationManagerBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.authentication.DefaultAuthenticationEventPublisher.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1289</link>
			<link type="Duplicate" description="duplicates">1272</link>
		</links>
	</bug>
	<bug id="56" master="308" duplicate="315" opendate="2006-06-29 03:03:56" fixdate="2006-09-14 07:46:34" resolution="Fixed">
		<buginformation>
			<summary>Lookup of headers in SavedRequestAwareWrapper is not case insensitive SavedRequest header names are case insensitive</summary>
			<description>According to the servlet spec, lookups using HttpServletRequest.getHeader and getHeaders should be case insensitive.  The current implementation of SavedRequest uses a HashMap to store saved headers.  The result is that the lookup of headers by name is case sensitive when SavedRequestAwareWrapper delegates to a SavedRequest.
We use a library that relies on the User-Agent header for rendering.  We experienced problems with rendering on the first page after login.  After debugging we found that the library was not able to get the correct value for the User-Agent due to the case sensitivity of the SavedRequest implementation.  I am attaching a patch that fixes this problem.  The patch is against the 1.0.1 tag.
After redirect after login:
request.getHeader("User-Agent") returns null;
request.getHeader("user-agent") returns the correct value;
Normal Request:
request.getHeader("User-Agent") returns the correct value;
request.getHeader("user-agent") returns the correct value; HTTP header names are case insensitive. We does not take it into account in org.acegisecurity.ui.savedrequest.SavedRequest 
We should reduce the header names to canonical form in the beginning of addHeader and getHeaderValues methods.</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.acegisecurity.ui.savedrequest.SavedCookieTest.java</file>
			<file type="M">org.acegisecurity.ui.savedrequest.SavedRequest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">315</link>
			<link type="Duplicate" description="is duplicated by">308</link>
		</links>
	</bug>
	<bug id="57" master="2948" duplicate="2990" opendate="2015-04-27 13:16:16" fixdate="2015-07-16 09:18:42" resolution="Complete">
		<buginformation>
			<summary>Incorrect message when upgrading to 4.0.x with the wrong xml schema declarations Fix SecurityNamespaceHandler exception message</summary>
			<description>During migration from 3.2.x to 4.0.1 I came across the following error message when using the 4.0.1 library with an XML config file with 3.2 schema declarations...






SEVERE: Exception sending context initialized event to listener instance of class org.springframework.web.context.ContextLoaderListener




org.springframework.beans.factory.parsing.BeanDefinitionParsingException: Configuration problem: You cannot use a spring-security-2.0.xsd or spring-security-3.0.xsd or spring-security-3.1.xsd schema with Spring Security 3.2. Please update your schema declarations to the 3.2 schema.




Offending resource: class path resource [foo/bar/spring/spring-security.xml]






The error message needs to be updated to...
You cannot use a spring-security-2.0.xsd or spring-security-3.0.xsd or spring-security-3.1.xsd or spring-security-3.2.xsd schema with Spring Security 4.0. Please update your schema declarations to the 4.0 schema.
XML Declarations that cause the error...






&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;




&amp;lt;beans xmlns="http://www.springframework.org/schema/beans"




    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"




    xmlns:aop="http://www.springframework.org/schema/aop"




    xmlns:context="http://www.springframework.org/schema/context"




    xmlns:security="http://www.springframework.org/schema/security"




    xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd




    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd




    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd




    http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security-3.2.xsd"




    &amp;gt;





 Migrating an application from Spring Security 3.2.x to 4.0.x raised this exception:
      org.springframework.beans.factory.parsing.BeanDefinitionParsingException:
      Configuration problem: You cannot use a spring-security-2.0.xsd or
      spring-security-3.0.xsd or spring-security-3.1.xsd schema with
      Spring Security 3.2. Please update your schema declarations to the
      3.2 schema.  Offending resource: ServletContext resource
[/WEB-INF/applicationContext-security.xml]
It appears that the exception message in config/src/main/java/org/springframework/security/config/SecurityNamespaceHandler.java needs to be updated.</description>
			<version>4.0.1</version>
			<fixedVersion>4.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.SecurityNamespaceHandler.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">2960</link>
			<link type="Duplicate" description="is duplicated by">2990</link>
			<link type="Duplicate" description="duplicates">2948</link>
			<link type="Duplicate" description="is duplicated by">3010</link>
		</links>
	</bug>
	<bug id="58" master="2078" duplicate="2497" opendate="2012-11-09 01:12:03" fixdate="2015-02-24 14:45:28" resolution="Complete">
		<buginformation>
			<summary>Pre-authentication fails when using check for principal change and using non String principals checkForPrincipalChanges limited to String Principal</summary>
			<description>The problem occurs when using pre-authentication with "check for principal change" set and the class there extends org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilter using non String principals but e.g. java.security.Principal.
The problem is that the authentication manager will always authenticate even the principal has no changed, this can give problems with the authentication provider, and performance in the code.
The error is in line 145 in the AbstractPreAuthenticatedProcessingFilter class, the code:
  if (currentUser.getName().equals(principal)) 
{
    return false;
  }

should be changed to something like:
  if (principal instanceof Principal) 
{
    return !currentUser.getName().equals(((Principal)principal).getName());
  }
  else 
{
    return !currentUser.getName().equals(principal.toString());
  }

The original code will only function when the passed principal parameter is of the type String. The code suggested will function for all type of objects there either implements the java.security.Principal interface or override the toString method. In AbstractPreAuthenticatedProcessingFilter,
method requiresAuthentication , Principal are assumed to be String 
 if (currentUser.getName().equals(principal)) 
should be
  if (currentUser.getPrincipal().equals(principal)) </description>
			<version>3.2.0</version>
			<fixedVersion>3.2.6, 4.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilterTests.java</file>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">2497</link>
			<link type="Duplicate" description="is duplicated by">2751</link>
			<link type="Duplicate" description="is duplicated by">2794</link>
			<link type="Relate" description="is related to">3051</link>
			<link type="Duplicate" description="duplicates">2078</link>
		</links>
	</bug>
	<bug id="59" master="1878" duplicate="1886" opendate="2011-12-21 13:16:46" fixdate="2012-06-16 15:56:43" resolution="Fixed">
		<buginformation>
			<summary>DefaultFilterChainValidator throws UnsupportedOperationException UnsupportedOperationException is thrown by DefaultFilterChainValidator if voter invokes an unsupported method</summary>
			<description>If the expression used in the access attribute of the intercept-url element references a request element not supported by the new [1] org.springframework.security.web.FilterInvocation$DummyRequest class AND a custom-filter is defined, then the filterChainProxy bean will fail to be created [2]. This is a regression from 3.0.6.RELEASE. 
For example: 
   &amp;lt;security:custom-filter ref="myAuthFilter" position="FIRST" /&amp;gt;
   &amp;lt;security:intercept-url pattern="/**"  access="request.parameterMap['test'] == null ? permitAll : permitAll" /&amp;gt; 
will fail with the stack trace below[2].
There is an easy (hacky) workaround...just check the for request.contextPath = &amp;amp;apos;/cp&amp;amp;apos; (assuming you don&amp;amp;apos;t really have a /cp path!)...this works because contextPath is supported by the DummyRequest.  
 &amp;lt;security:intercept-url pattern="/**"  access="request.contextPath == &amp;amp;apos;/cp&amp;amp;apos; ? denyAll : request.parameterMap['test'] == null ? permitAll : permitAll" /&amp;gt;
I have attached simple maven project that will exercise this bug. To reproduce, download, unzip the intercpet-url-access-bug.zip attachment, and run mvn jetty:run. 
[1] https://fisheye.springsource.org/browse/spring-security/web/src/main/java/org/springframework/security/web/FilterInvocation.java?r2=93438defffe5c339026469afa09dad60b2928a4f&amp;amp;r1=052537c8b04182595e92abd1e1949b0ff7e731b4
[2] 
SEVERE: Context initialization failed
org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;org.springframework.security.filterChainProxy&amp;amp;apos;: Invocation of init method failed; nested exception is java.lang.IllegalArgumentException: Failed to evaluate expression &amp;amp;apos;request.parameterMap['test'] == null ? permitAll : permitAll&amp;amp;apos;
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1455)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:519)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:456)
	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:294)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:225)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:291)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:193)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:585)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:913)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:464)
	at org.springframework.web.context.ContextLoader.createWebApplicationContext(ContextLoader.java:282)
	at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:204)
	at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:47)
	at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:4206)
	at org.apache.catalina.core.StandardContext.start(StandardContext.java:4705)
	at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1057)
	at org.apache.catalina.core.StandardHost.start(StandardHost.java:840)
	at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1057)
	at org.apache.catalina.core.StandardEngine.start(StandardEngine.java:463)
	at org.apache.catalina.core.StandardService.start(StandardService.java:525)
	at org.apache.catalina.core.StandardServer.start(StandardServer.java:754)
	at org.apache.catalina.startup.Catalina.start(Catalina.java:595)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:592)
	at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:289)
	at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:414)
Caused by: java.lang.IllegalArgumentException: Failed to evaluate expression &amp;amp;apos;request.parameterMap['test'] == null ? permitAll : permitAll&amp;amp;apos;
	at org.springframework.security.access.expression.ExpressionUtils.evaluateAsBoolean(ExpressionUtils.java:13)
	at org.springframework.security.web.access.expression.WebExpressionVoter.vote(WebExpressionVoter.java:34)
	at org.springframework.security.web.access.expression.WebExpressionVoter.vote(WebExpressionVoter.java:18)
	at org.springframework.security.access.vote.AffirmativeBased.decide(AffirmativeBased.java:62)
	at org.springframework.security.config.http.DefaultFilterChainValidator.checkLoginPageIsntProtected(DefaultFilterChainValidator.java:170)
	at org.springframework.security.config.http.DefaultFilterChainValidator.validate(DefaultFilterChainValidator.java:35)
	at org.springframework.security.web.FilterChainProxy.afterPropertiesSet(FilterChainProxy.java:148)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1514)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1452)
	... 27 more
Caused by: org.springframework.expression.spel.SpelEvaluationException: EL1021E:(pos 8): A problem occurred whilst attempting to access the property &amp;amp;apos;parameterMap&amp;amp;apos;: &amp;amp;apos;Unable to access property &amp;amp;apos;parameterMap&amp;amp;apos; through getter&amp;amp;apos;
	at org.springframework.expression.spel.ast.PropertyOrFieldReference.readProperty(PropertyOrFieldReference.java:201)
	at org.springframework.expression.spel.ast.PropertyOrFieldReference.getValueInternal(PropertyOrFieldReference.java:72)
	at org.springframework.expression.spel.ast.CompoundExpression.getValueInternal(CompoundExpression.java:57)
	at org.springframework.expression.spel.ast.OpEQ.getValueInternal(OpEQ.java:37)
	at org.springframework.expression.spel.ast.OpEQ.getValueInternal(OpEQ.java:1)
	at org.springframework.expression.spel.ast.SpelNodeImpl.getValue(SpelNodeImpl.java:135)
	at org.springframework.expression.spel.ast.Ternary.getValueInternal(Ternary.java:47)
	at org.springframework.expression.spel.ast.SpelNodeImpl.getTypedValue(SpelNodeImpl.java:102)
	at org.springframework.expression.spel.standard.SpelExpression.getValue(SpelExpression.java:97)
	at org.springframework.security.access.expression.ExpressionUtils.evaluateAsBoolean(ExpressionUtils.java:11)
	... 35 more
Caused by: org.springframework.expression.AccessException: Unable to access property &amp;amp;apos;parameterMap&amp;amp;apos; through getter
	at org.springframework.expression.spel.support.ReflectivePropertyAccessor$OptimalPropertyAccessor.read(ReflectivePropertyAccessor.java:499)
	at org.springframework.expression.spel.ast.PropertyOrFieldReference.readProperty(PropertyOrFieldReference.java:196)
	... 44 more
Caused by: java.lang.reflect.InvocationTargetException
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:592)
	at org.springframework.expression.spel.support.ReflectivePropertyAccessor$OptimalPropertyAccessor.read(ReflectivePropertyAccessor.java:495)
	... 45 more
Caused by: java.lang.UnsupportedOperationException
	at org.springframework.security.web.DummyRequest.getParameterMap(FilterInvocation.java:334)
	... 50 more
 The DefaultFilterChainValidator prevents the application context from starting up if a custom AccessDecisionVoter attempts to access an unsupported method of the DummyRequest, for example the #getRemoteAddr(). There is no way to turn off this validation when using &amp;lt;http&amp;gt; config.






Stack Trace






Caused by: java.lang.UnsupportedOperationException




	at org.springframework.security.web.DummyRequest.getRemoteAddr(FilterInvocation.java:358)




	at com.foo.security.vote.IPRestrictionAccessVoter.vote(IPRestrictionAccessVoter.java:80)




	at com.foo.security.vote.IPRestrictionAccessVoter.vote(IPRestrictionAccessVoter.java:37)




	at org.springframework.security.access.vote.UnanimousBased.decide(UnanimousBased.java:77)




	at org.springframework.security.config.http.DefaultFilterChainValidator.checkLoginPageIsntProtected(DefaultFilterChainValidator.java:170)




	at org.springframework.security.config.http.DefaultFilterChainValidator.validate(DefaultFilterChainValidator.java:35)




	at org.springframework.security.web.FilterChainProxy.afterPropertiesSet(FilterChainProxy.java:148)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1514)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1452)




	... 155 more





</description>
			<version>3.1.0</version>
			<fixedVersion>3.1.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.DefaultFilterChainValidator.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1886</link>
			<link type="Duplicate" description="duplicates">1878</link>
		</links>
	</bug>
	<bug id="60" master="1133" duplicate="1388" opendate="2009-04-01 20:45:14" fixdate="2010-08-14 07:11:35" resolution="Complete">
		<buginformation>
			<summary>Allow setting authenticationDetailsSource ref via form-login namespace URL Support for custom AuthenticationDetailsSource in form-login tag.</summary>
			<description> When using the &amp;lt;form-login /&amp;gt; tag, theres no way to configure a custom AuthenticationDetailsSource.
The workaround is to reconfigure UsernamePasswordAuthenticationFilter as a custom filter and reconfigure LoginUrlAuthenticationEntryPoint with its loginFormUrl property. Spring XML becomes more polluted and some minor functionality like the &amp;lt;http&amp;gt; auto-config and the built-in form login page are lost.</description>
			<version>3.0.1</version>
			<fixedVersion>3.1.0.M1</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.AuthenticationConfigBuilder.java</file>
			<file type="M">org.springframework.security.config.http.FormLoginBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.http.HttpSecurityBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1388</link>
			<link type="Duplicate" description="duplicates">1133</link>
		</links>
	</bug>
	<bug id="61" master="3109" duplicate="3122" opendate="2015-09-18 14:19:14" fixdate="2015-10-26 22:27:19" resolution="Fixed">
		<buginformation>
			<summary>Concurrent/ThreadPoolTaskScheduler don&amp;apos;t work with DelegatingSecurityContextExecutor DelegatingSecurityContextScheduledExecutorService only sets SecurityContext at first run of a scheduled task - subsequent runs do not have the SecurityContext set</summary>
			<description>We have a setup with Spring Boot with scheduling. To use method security with background jobs we want to use the DelegatingSecurityContextScheduledExecutorService like described here: http://www.petrikainulainen.net/programming/spring-framework/spring-from-the-trenches-invoking-a-secured-method-from-a-scheduled-job/ (see "Spring Security 3.2: It Is Almost Like Magic!").
I suspect this stopped working with SEC-3031, because now DelegatingSecurityContextRunnable/Callable doesn&amp;amp;apos;t set/clear the security context if run on the same thread as they were created.
As Concurrent/TheadPoolTaskScheduler uses a ReschedulingRunnable for the trigger mechanic (we use cron triggers), so the rescheduling is done on the pool thread. So random subsequent calls executed on the same pool thread might fail, because the SecurityContext is not set.
Getting DelegatingSecurityContextExecutor to set the enableOnOriginalThread property on DelegatingSecurityContextRunnable to true would fix that issue. When using DelegatingSecurityContextScheduledExecutorService to set a security context for a scheduled task, it works perfectly fine for the first task execution, but subsequent executions are (re-)scheduled by the same thread which was used to execute the task for the first time - this is done in ReschedulingRunnable.run()
Thread.currentThread() is used to set the originalThread variable in DelegatingSecurityContextRunnable - therefore DelegatingSecurityContextRunnable thinks it&amp;amp;apos;s being executed in the original thread and does skip the set security context.
This means originalThread variable (in DelegatingSecurityContextRunnable) does contain the wrong value for all executions except the first one. Therefore all subsequent executions do fail because no security context is set ...






@Scheduled(cron="*/30 * * * * *", zone="UTC")




	public void myScheduledTask() {




//call to secured method




}









@Override




    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {




        taskRegistrar.setScheduler(taskExecutor());




    }




 




    public Executor taskExecutor() {




        ScheduledExecutorService delegateExecutor = Executors.newSingleThreadScheduledExecutor();




        SecurityContext schedulerContext = createSchedulerSecurityContext();




        return new DelegatingSecurityContextScheduledExecutorService(delegateExecutor, schedulerContext);




    }




 




    private SecurityContext createSchedulerSecurityContext() {




        SecurityContext context = SecurityContextHolder.createEmptyContext();




 




        Collection&amp;lt;GrantedAuthority&amp;gt; authorities = AuthorityUtils.createAuthorityList("ROLE_USER");




        Authentication authentication = new UsernamePasswordAuthenticationToken(




                "user",




                "user",




                authorities




        );




        context.setAuthentication(authentication);




 




        return context;




    }





</description>
			<version>4.0.2</version>
			<fixedVersion>3.2.9, 4.0.3, 4.1.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilterTests.java</file>
			<file type="M">org.springframework.security.concurrent.DelegatingSecurityContextCallableTests.java</file>
			<file type="M">org.springframework.security.concurrent.DelegatingSecurityContextRunnable.java</file>
			<file type="M">org.springframework.security.concurrent.DelegatingSecurityContextRunnableTests.java</file>
			<file type="M">org.springframework.security.concurrent.DelegatingSecurityContextCallable.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">3122</link>
			<link type="Relate" description="is related to">3031</link>
			<link type="Duplicate" description="duplicates">3109</link>
		</links>
	</bug>
	<bug id="62" master="1606" duplicate="1633" opendate="2010-11-01 14:46:17" fixdate="2010-12-08 06:01:26" resolution="Complete">
		<buginformation>
			<summary>FirewalledRequest.reset() not called when Filters in the FilterChainProxy do not complete the FilterChain jsp:forward goes into a loop</summary>
			<description>When the FilterChain is not completed within FilterChainProxy, FirewalledRequest.reset() is not called. This can cause the wrong pathInfo and servletPath to be exposed when a forward or include is performed within the FilterChainProxy&amp;amp;apos;s filters and using DefaultHttpFirewall. The reason is because the pathInfo and the servletPath are still cached from the original request and reset was never called.
The following configuration will demonstrate the issue. When an invalid username/password is submitted, the request is forwarded to /login.jsp?login_error=1. However, when the JspServlet attempts to process the URL it sees the HttpServeltRequest.servletPath as RequestWrapper.strippedServletPath (/j_spring_security_check) instead of the new servletPath /login.jsp. 
&amp;lt;http auto-config="true"&amp;gt;
  &amp;lt;intercept-url pattern="/admin/secure.jsp" access="ROLE_ADMIN"/&amp;gt;
  &amp;lt;form-login login-page="/login.jsp" authentication-failure-handler-ref="afh"/&amp;gt;		
&amp;lt;/http&amp;gt;	
&amp;lt;b:bean id="afh" class="org.springframework.security.web.authentication.SimpleUrlAuthenticationFailureHandler"
  p:defaultFailureUrl="/login.jsp?login_error=1"  
  p:useForward="true"/&amp;gt;
&amp;lt;authentication-manager&amp;gt;
  &amp;lt;authentication-provider&amp;gt;
    &amp;lt;user-service&amp;gt;
      &amp;lt;user name="un" password="pwd" authorities="ROLE_ADMIN"/&amp;gt;
    &amp;lt;/user-service&amp;gt;
  &amp;lt;/authentication-provider&amp;gt;
&amp;lt;/authentication-manager&amp;gt;
I have not yet validated this occurs in 3.1.0.M2 but marked it as impacted to ensure it at least gets looked at. I wanted to upgrade to Spring Security 2.0.6 from Spring Security 2.0.5. That is upgrade one minor version up. I use struts 1.3.10. When I replaced the 4 jar files with the ones from 2.0.6, I started getting strange error messages from Struts saying that no action path could be found. 
The following are the 4 jars that I replace with the 2.0.6 versions.
spring-security-acl-2.0.5.RELEASE.jar
spring-security-core-2.0.5.RELEASE.jar
spring-security-core-tiger-2.0.5.RELEASE.jar
spring-security-taglibs-2.0.5.RELEASE.jar
After trying various things unsuccessfully, I decided to create a bare bones functional project and try my upgrade there.
What I discovered is that 2.0.6 appears to have problems dealing with jsp forward. In 2.0.5 things work fine but 2.0.6 things go into a loop while running inside of Eclipse/Tomcat 5.5.
I create a fresh Eclipse Dynamic Web project. I add an index.jsp which has one line to perform a jsp:forward to another .jsp page. I tested with no Spring and it works as expected. I then introduce Spring Security 2.0.5 and Spring 2.5.5 into the mix and things still work as expected. (Index.jsp has intercept-url has filters=none).
I then replace the above mentioned 4 files with the 2.0.6 versions. Then when I try to navigate to the index.jsp via browser (Fire Fox 3.6.12), the tomcat server goes into a loop spewing out a very large stack trace.
I&amp;amp;apos;m attaching the eclipse project as well as the tomcat log file.
The main reason I wanted to upgrade to 2.0.6 is because for some reason, I am not able to get "access-denied-page" attribute to work on the http element.</description>
			<version>2.0.6</version>
			<fixedVersion>3.1.0.M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.firewall.RequestWrapperTests.java</file>
			<file type="M">org.springframework.security.web.firewall.RequestWrapper.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1633</link>
			<link type="Relate" description="relates to">1608</link>
			<link type="Duplicate" description="duplicates">1606</link>
		</links>
	</bug>
	<bug id="63" master="2831" duplicate="3160" opendate="2015-01-28 04:36:20" fixdate="2015-11-29 02:57:29" resolution="Complete">
		<buginformation>
			<summary>RegexRequestMatcher/AntPathRequestMatcher should not throw exception with invalid HTTP method in the request Invalid HTTP verb throws 500 not 400</summary>
			<description>Observed behavior
Unknown HTTP method will cause IllegalArgumentException in LogoutFilter &amp;gt; AntPathRequestMatcher. Stack trace:






java.lang.IllegalArgumentException: No enum constant org.springframework.http.HttpMethod.PROPFIND




	at java.lang.Enum.valueOf(Enum.java:236)




	at org.springframework.http.HttpMethod.valueOf(HttpMethod.java:27)




	at org.springframework.security.web.util.matcher.AntPathRequestMatcher.matches(AntPathRequestMatcher.java:125)




	at org.springframework.security.web.authentication.logout.LogoutFilter.requiresLogout(LogoutFilter.java:122)




	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:94)




...






This issue is more severe as this will fail on any request with unknown HTTP method (i.e. not just request to logout filter processing URI).
Note that this is not a feature request to support custom HTTP methods, but really a bug report about incorrect handling of unknown HTTP method.
Expected behavior
Request with unknown HTTP method MUST NOT end with internal server error. Such request should just not be matched if a required HTTP method is specified.
How to reproduce
Use any web application with LogoutFilter processing configured:






curl -XANY_METHOD http://host:port/context/any-path 





 Had a few cases of a bad client request which doesn&amp;amp;apos;t match a valid HTTP verb, i would expect this to be returned as a 400 Bad Request, instead our access log showed as a 500.






java.lang.IllegalArgumentException: No enum constant 




               at java.lang.Enum.valueOf(Enum.java:238)




                at org.springframework.http.HttpMethod.valueOf(HttpMethod.java:27)




                at org.springframework.security.web.util.matcher.AntPathRequestMatcher.matches(AntPathRequestMatcher.java:125)




                at org.springframework.security.web.access.intercept.DefaultFilterInvocationSecurityMetadataSource.getAttributes(DefaultFilterInvocationSecurityMetadataSource.java:86)




                at org.springframework.security.access.intercept.AbstractSecurityInterceptor.beforeInvocation(AbstractSecurityInterceptor.java:174)




                at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecur















</description>
			<version>3.2.5</version>
			<fixedVersion>3.2.6, 4.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.util.matcher.AntPathRequestMatcher.java</file>
			<file type="M">org.springframework.security.web.util.matcher.RegexRequestMatcher.java</file>
			<file type="M">org.springframework.security.web.util.matcher.AntPathRequestMatcherTests.java</file>
			<file type="M">org.springframework.security.web.util.matcher.RegexRequestMatcherTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">3160</link>
			<link type="Duplicate" description="duplicates">2831</link>
		</links>
	</bug>
	<bug id="64" master="199" duplicate="230" opendate="2006-02-23 16:04:59" fixdate="2006-04-25 15:11:27" resolution="Fixed">
		<buginformation>
			<summary>Contacts sample throws NestedServletException (500) instead of Access denied! (403) page ExceptionTranslationFilter does not catch AccessDeniedException with Spring MVC M2/M3</summary>
			<description>Logged on as 
Manually entered URL http://localhost:8080/contacts/secure/del.htm?contactId=2
NB - You have to manually enter the URL, but still, the behaviour doesn&amp;amp;apos;t appear to be as intended
Tomcat throws:
org.springframework.web.util.NestedServletException: Request processing failed; nested exception is org.acegisecurity.AccessDeniedException: Access is denied
...
root cause
org.acegisecurity.AccessDeniedException: Access is denied I am writing a SpringMVC-based web application with Acegi Security.  I have a Spring Controller object that invokes a method that is protected by an Acegi MethodSecurityInterceptor.  When the MethodSecurityInterceptor throws an AccessDeniedException, it is getting wrapped by the Spring FrameworkServlet in a org.springframework.web.util.NestedServletException.  Because of this wrapping, the ExceptionTranslationFilter never catches an AccessDeniedException, thus causing a 500 server error to bubble up instead of a 403/redirect to authenticationEntryPoint. 
I&amp;amp;apos;m not sure whose problem this is - the Acegi code could inspect the root cause of the NestedServletException, or the FrameworkServlet could pass on RuntimeExceptions without wrapping. </description>
			<version>1.0.0 RC2</version>
			<fixedVersion>1.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.ExceptionTranslationFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Depends" description="is depended on by">220</link>
			<link type="Duplicate" description="is duplicated by">230</link>
			<link type="Duplicate" description="duplicates">199</link>
		</links>
	</bug>
	<bug id="65" master="2276" duplicate="2376" opendate="2013-08-22 06:47:55" fixdate="2013-10-24 10:51:19" resolution="Complete">
		<buginformation>
			<summary>Delay storing the CsrfToken until the CsrfToken is accessed Document/Fix CSRF behavior with pre-auth</summary>
			<description>Rather than adding the CsrfToken to the HttpSession immediately, we can delay adding the CsrfToken until the token is accessed on the servlet request. This ensures that only a request that is just prior to CSRF will create the session. 3.2.0.RC1 with &amp;lt;http auto-config="true"&amp;gt;  with &amp;lt;csrf/&amp;gt; and a preauth filter
When a user first accesses a pre-authed site
1. the CSRF token is added to the session.
2. The pre-auth filter creates the Authentication and related security context
3. The SessionManagementFilter then runs, and since its a new auth and session it calls &amp;amp;apos;CsrfAuthenticationStrategy&amp;amp;apos; which removes the CSRF token from the session.
4. The return view now has an invalid CSRF token in any forms.
A 2nd GET creates a new CSRF token, and then everything works normally.
--------------------------------
I posted my workaround in the forum, but it would nice to:
1. Document the behavior/workaround in
http://docs.spring.io/spring-security/site/docs/3.2.x-SNAPSHOT/reference/html/csrf.html
so that others don&amp;amp;apos;t have the same issue.
2. Offer a better way (or workaround) to remove the CsrfAuthenticationStrategy from the session management.
Is defining my own custom CSRF filter and repository a "cleaner" workaround to defining my own session management filter?
Or is updating the xsd, and doing something like &amp;lt;csrf auth-strategy="disable"/&amp;gt; a possibility?
</description>
			<version>3.2.0.RC1</version>
			<fixedVersion>3.2.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.servlet.support.csrf.CsrfRequestDataValueProcessorTests.java</file>
			<file type="M">org.springframework.security.web.csrf.CsrfToken.java</file>
			<file type="D">org.springframework.security.web.csrf.CsrfTokenTests.java</file>
			<file type="M">org.springframework.security.web.csrf.CsrfTokenRepository.java</file>
			<file type="M">org.springframework.security.web.csrf.CsrfFilterTests.java</file>
			<file type="M">org.springframework.security.web.csrf.HttpSessionCsrfTokenRepository.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configurers.SessionManagementConfigurerServlet31Tests.java</file>
			<file type="M">org.springframework.security.web.csrf.HttpSessionCsrfTokenRepositoryTests.java</file>
			<file type="M">org.springframework.security.web.csrf.CsrfFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">2376</link>
			<link type="Duplicate" description="duplicates">2276</link>
		</links>
	</bug>
	<bug id="66" master="404" duplicate="407" opendate="2006-11-29 13:52:40" fixdate="2006-12-28 07:24:54" resolution="Fixed">
		<buginformation>
			<summary>Logout when not logged in cause NullPointerException Hitting LogoutFilter&amp;apos;s URL when not logged in causes NPE</summary>
			<description>When a user attempts to logout when they aren&amp;amp;apos;t logged in (e.g. when their session has expired) a NullPointerException occurs in TokenBasedRememberMeServices.logout(TokenBasedRememberMeServices.java:295).
The line that fails is:
        cancelCookie(request, response, "Logout of user " + authentication.getName());
I guess the cookie should still be cancelled, so the change might simply be to change the line to something like:
        cancelCookie(request, response, "Logout of user " + authentication == null ? "Unknown" : authentication.getName());
Regards,
Damien After upgrading to 1.0.3, I&amp;amp;apos;m getting the following error when running
some tests:
[INFO] [talledLocalContainer] ERROR - StandardWrapperValve.invoke(260)


 Servlet.service() for servlet jsp threw exception
[INFO] [talledLocalContainer] java.lang.NullPointerException
[INFO] [talledLocalContainer]   at
org.acegisecurity.ui.rememberme.TokenBasedRememberMeServices.logout(TokenBasedRememberMeServices.java:295)
[INFO] [talledLocalContainer]   at
org.acegisecurity.ui.logout.LogoutFilter.doFilter(LogoutFilter.java:98)


Here&amp;amp;apos;s what I have in my security.xml context file:
   &amp;lt;bean id="filterChainProxy" class="org.acegisecurity.util.FilterChainProxy"&amp;gt;
       &amp;lt;property name="filterInvocationDefinitionSource"&amp;gt;
           &amp;lt;value&amp;gt;
               CONVERT_URL_TO_LOWERCASE_BEFORE_COMPARISON
               PATTERN_TYPE_APACHE_ANT
/**=httpSessionContextIntegrationFilter,logoutFilter,authenticationProcessingFilter,securityContextHolderAwareRequestFilter,rememberMeProcessingFilter,anonymousProcessingFilter,exceptionTranslationFilter,filterInvocationInterceptor
           &amp;lt;/value&amp;gt;
           &amp;lt;!-- Put channelProcessingFilter before
securityContextHolderAwareRequestFilter to turn on SSL switching --&amp;gt;
           &amp;lt;!-- It&amp;amp;apos;s off by default b/c Canoo WebTest doesn&amp;amp;apos;t support
SSL out-of-the-box --&amp;gt;
       &amp;lt;/property&amp;gt;
   &amp;lt;/bean&amp;gt;
   &amp;lt;bean id="httpSessionContextIntegrationFilter"
class="org.acegisecurity.context.HttpSessionContextIntegrationFilter"/&amp;gt;
   &amp;lt;bean id="logoutFilter" class="org.acegisecurity.ui.logout.LogoutFilter"&amp;gt;
       &amp;lt;constructor-arg value="/index.jsp"/&amp;gt; &amp;lt;!-- URL redirected to
after logout --&amp;gt;
       &amp;lt;constructor-arg&amp;gt;
           &amp;lt;list&amp;gt;
               &amp;lt;ref bean="rememberMeServices"/&amp;gt;
               &amp;lt;bean
class="org.acegisecurity.ui.logout.SecurityContextLogoutHandler"/&amp;gt;
           &amp;lt;/list&amp;gt;
       &amp;lt;/constructor-arg&amp;gt;
       &amp;lt;property name="filterProcessesUrl" value="/logout.jsp"/&amp;gt;
   &amp;lt;/bean&amp;gt;
The problem appears to be caused by trying to logout before you&amp;amp;apos;ve
tried to login.  This worked fine in previous releases where the
LogoutFilter was present.</description>
			<version>1.0.3</version>
			<fixedVersion>1.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.rememberme.TokenBasedRememberMeServices.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">433</link>
			<link type="Duplicate" description="is duplicated by">464</link>
			<link type="Duplicate" description="is duplicated by">407</link>
			<link type="Duplicate" description="duplicates">404</link>
		</links>
	</bug>
	<bug id="67" master="99" duplicate="424" opendate="2005-11-14 14:27:20" fixdate="2008-03-24 11:45:11" resolution="Fixed">
		<buginformation>
			<summary>MethodDefinitionMap must support superclass declared methods MethodDefinitionMap - Can&amp;apos;t access inherited methods</summary>
			<description>As reported by Tom Dunstan, MethodDefinitionMap line 168 by default will only locate methods declared for the class, and not for superclasses (ie uses clazz.getMethods() instead of clazz.getDeclaredMethods()). Whilst this is consistent with Spring&amp;amp;apos;s transaction handling, it does present an issue for those relying on generic superclasses and wanting to define authorization configuration attributes against them. It is proposed to add a new keyword to the property editor to direct MethodDefinitionMap to use getDeclaredMethods() vs getMethods(), such that by default the existing behaviour is preserved (to be consistent with transaction services) but the superclass search behaviour can be used instead. Alternatively, we could introduce an optional prefix the method name, such as "+", which denotes "locate the matching methods in the superclass". This would have the added advantage of ensuring only patterns where you deliberately want to use getDeclaredMethods() will use that method. See : http://forum.springframework.org/showthread.php?p=94634
The MethodDefinitionMap can&amp;amp;apos;t secure any inherited method. Line 123 of the java file has to be modified as follows :





Eclipse Workspace Patch 1.0
#P acegisecurity
Index: core/src/main/java/org/acegisecurity/intercept/method/MethodDefinitionMap.java
===================================================================
RCS file: /cvsroot/acegisecurity/acegisecurity/core/src/main/java/org/acegisecurity/intercept/method/MethodDefinitionMap.java,v
retrieving revision 1.6
diff -u -r1.6 MethodDefinitionMap.java


core/src/main/java/org/acegisecurity/intercept/method/MethodDefinitionMap.java	17 Nov 2005 00:56:09 -0000	1.6
+++ core/src/main/java/org/acegisecurity/intercept/method/MethodDefinitionMap.java	9 Jan 2007 14:45:34 -0000
@@ -165,7 +165,7 @@
                 + "] with attributes [" + attr + "]");
         }






Method[] methods = clazz.getDeclaredMethods();
+        Method[] methods = clazz.getMethods();
         List matchingMethods = new ArrayList();

         for (int i = 0; i &amp;lt; methods.length; i++) {</description>
			<version>1.0.4</version>
			<fixedVersion>2.0.0 RC1</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.intercept.method.MethodDefinitionSourceEditorTests.java</file>
			<file type="D">org.springframework.security.annotation.Jsr250SecurityAnnotationAttributes.java</file>
			<file type="D">org.springframework.security.intercept.method.MethodDefinitionMap.java</file>
			<file type="M">org.springframework.security.util.SimpleMethodInvocation.java</file>
			<file type="M">org.springframework.security.intercept.method.MethodInvocationPrivilegeEvaluatorTests.java</file>
			<file type="M">org.springframework.security.intercept.method.MethodDefinitionAttributesTests.java</file>
			<file type="M">org.springframework.security.intercept.method.MethodDefinitionSourceEditor.java</file>
			<file type="M">org.springframework.security.intercept.method.aopalliance.MethodDefinitionSourceAdvisor.java</file>
			<file type="M">org.springframework.security.config.AnnotationDrivenBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.intercept.method.MockMethodDefinitionSource.java</file>
			<file type="M">org.springframework.security.OtherTargetObject.java</file>
			<file type="M">org.springframework.security.intercept.method.aopalliance.MethodDefinitionSourceAdvisorTests.java</file>
			<file type="M">org.springframework.security.config.InterceptMethodsBeanDefinitionDecorator.java</file>
			<file type="M">org.springframework.security.ConfigAttributeDefinition.java</file>
			<file type="M">org.springframework.security.intercept.method.MethodDefinitionSource.java</file>
			<file type="M">org.springframework.security.intercept.method.aspectj.AspectJSecurityInterceptorTests.java</file>
			<file type="M">org.springframework.security.context.rmi.ContextPropagatingRemoteInvocationTests.java</file>
			<file type="M">org.springframework.security.annotation.MethodDefinitionSourceEditorTigerTests.java</file>
			<file type="M">org.springframework.security.intercept.method.aopalliance.MethodSecurityInterceptorTests.java</file>
			<file type="M">org.springframework.security.MockJoinPoint.java</file>
			<file type="D">org.springframework.security.annotation.SecurityAnnotationAttributes.java</file>
			<file type="D">org.springframework.security.annotation.SecurityAnnotationAttributesTests.java</file>
			<file type="M">org.springframework.security.util.MethodInvocationUtils.java</file>
			<file type="M">org.springframework.security.intercept.method.MethodDefinitionAttributes.java</file>
			<file type="M">org.springframework.security.vote.BasicAclEntryVoterTests.java</file>
			<file type="M">org.springframework.security.config.BeanIds.java</file>
			<file type="D">org.springframework.security.annotation.Jsr250SecurityAnnotationAttributesTests.java</file>
		</fixedFiles>
		<links>
			<link type="Depends" description="is depended on by">428</link>
			<link type="Duplicate" description="is duplicated by">424</link>
			<link type="Duplicate" description="is duplicated by">353</link>
			<link type="Related" description="is related to">734</link>
			<link type="Duplicate" description="duplicates">99</link>
		</links>
	</bug>
	<bug id="68" master="1940" duplicate="1917" opendate="2012-02-17 01:06:19" fixdate="2012-07-30 12:13:32" resolution="Fixed">
		<buginformation>
			<summary>ProviderManager does not publish AccountStatusException DefaultAuthenticationEventPublisher is never used when an AccountStatusException is thrown</summary>
			<description>When using a simple configuration, an authentication provider throwing a LockedException doesn&amp;amp;apos;t cause an AuthenticationFailureLockedEvent to be published. The writeup&amp;amp;apos;s in the Spring forum reference. I can&amp;amp;apos;t be sure this is a bug, but it seems too weird to be expected behavior. The ProviderManager created by http namespace coded in 
org.springframework.security.config.http.HttpSecurityBeanDefinitionParser#createAuthenticationManager does not register a DefaultAuthenticationEventPublisher to the bean registration. This, in combination with the AccountStatusException handling in org.springframework.security.authentication.ProviderManager#authenticate where the exception is always rethrown, renders the DefaultAuthenticationEventPublisher of the parent ProviderManager invisible.
If you consider also that the org.springframework.security.core.AuthenticationException#getAuthentication has been deprecated, I cannot find a way to retrieve the cause and the identity of the failed authentication.</description>
			<version>3.1.0</version>
			<fixedVersion>3.1.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.authentication.ProviderManager.java</file>
			<file type="M">org.springframework.security.authentication.ProviderManagerTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1917</link>
			<link type="Relate" description="is related to">546</link>
			<link type="Duplicate" description="duplicates">1940</link>
		</links>
	</bug>
</bugrepository>